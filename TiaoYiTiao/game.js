define("game.js", function(require, module, exports){ 			
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(30);

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

var _block = __webpack_require__(12);

var _block2 = _interopRequireDefault(_block);

var _ui = __webpack_require__(26);

var _ui2 = _interopRequireDefault(_ui);

var _wave = __webpack_require__(29);

var _wave2 = _interopRequireDefault(_wave);

var _ground = __webpack_require__(18);

var _ground2 = _interopRequireDefault(_ground);

var _bottle = __webpack_require__(13);

var _bottle2 = _interopRequireDefault(_bottle);

var _config = __webpack_require__(2);

var _audioManager = __webpack_require__(27);

var _audioManager2 = _interopRequireDefault(_audioManager);

var _tailSystem = __webpack_require__(25);

var _tailSystem2 = _interopRequireDefault(_tailSystem);

var _pointInPolygon = __webpack_require__(31);

var _pointInPolygon2 = _interopRequireDefault(_pointInPolygon);

var _network = __webpack_require__(3);

var _network2 = _interopRequireDefault(_network);

var _storage = __webpack_require__(5);

var _storage2 = _interopRequireDefault(_storage);

var _session = __webpack_require__(6);

var _session2 = _interopRequireDefault(_session);

var _rankSystem = __webpack_require__(23);

var _rankSystem2 = _interopRequireDefault(_rankSystem);

var _socket = __webpack_require__(20);

var _socket2 = _interopRequireDefault(_socket);

var _full2D = __webpack_require__(21);

var _full2D2 = _interopRequireDefault(_full2D);

var _singleSettlementPage = __webpack_require__(22);

var _singleSettlementPage2 = _interopRequireDefault(_singleSettlementPage);

var _shareApp = __webpack_require__(7);

var _viewer = __webpack_require__(28);

var _viewer2 = _interopRequireDefault(_viewer);

var _animation = __webpack_require__(4);

var _historyTimes = __webpack_require__(24);

var _historyTimes2 = _interopRequireDefault(_historyTimes);

var _reporter = __webpack_require__(19);

var _reporter2 = _interopRequireDefault(_reporter);

var _gameCtrl = __webpack_require__(15);

var _gameCtrl2 = _interopRequireDefault(_gameCtrl);

var _gameView = __webpack_require__(17);

var _gameView2 = _interopRequireDefault(_gameView);

var _gameModel = __webpack_require__(16);

var _gameModel2 = _interopRequireDefault(_gameModel);

var _random = __webpack_require__(9);

var _instructionCtrl = __webpack_require__(14);

var _instructionCtrl2 = _interopRequireDefault(_instructionCtrl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//window.console = { log: function() {}, error: function() {}, warn: function() {} };
var HEIGHT = window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth;
var WIDTH = window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth;
var TIMEOUT = 9000;
var SERVERCONFIG = 60000;
// const SERVERCONFIG = 1000
var SYCTIME = 10000;
var REPORTERTIMEOUT = 60001;
// const REPORTERTIMEOUT = 1000
var system = wx.getSystemInfoSync() || {};
var isIPhone = system.platform == 'ios';
var model = system.model;

var Game = function () {
  function Game(options) {
    _classCallCheck(this, Game);

    // 模式：单机，围观(玩家，观察者），挑战，首屏，loading, viewerWating, viewer,viewergg,viewerout
    //console.log('options', options)
    this.options = options;
    this.is_from_wn = 0;
    // this.is_from_wn = 1

    this.firstInit = true;
    this.distance = 0;

    this.heightestScore = 0;

    // 目前stage有 game,friendRankList,singleSettlementPgae,groupShareList,battlePage
    this.stage = '';
    this.succeedTime = 0;
    this.lastAddBonus = -2;

    this.lastStage = '';

    // 定时器，死亡碰撞
    this.deadTimeout = null;

    // 本小局分数
    this.currentScore = 0;
    this.seq = 0;

    this.thirdBlock = null;

    this.straight = true;

    this.firstBlood = false;

    this.lastHardLevel = 200;
    this.guider = false;

    this.hardDistances = [];

    this.duration = [];
    this.quickArr = [];
    this.socketFirstSync = false;
    this.init();

    this.randomSeed = Date.now();
    (0, _random.setRandomSeed)(this.randomSeed);
    this.actionList = [];
    this.musicList = [];
    this.touchList = [];
    this.blocks = [];

    this.liveTime = 0;

    wx.setKeepScreenOn && wx.setKeepScreenOn({
      keepScreenOn: true
    });
  }

  _createClass(Game, [{
    key: 'moveGradually',
    value: function moveGradually(vector, duration) {
      if (this.animating && !this.guider) {
        //console.log("moveGradually", vector, duration);
        (0, _animation.TweenAnimation)(this.bottle.obj.position.x, this.bottle.obj.position.x - vector.x, duration * 500, 'Linear', function (value, complete) {
          this.bottle.obj.position.x = value;
          if (complete) {
            this.bottle.obj.position.x = -0.098;
          }
        }.bind(this));

        // TweenAnimation(this.bottle.obj.position.z, this.bottle.obj.position.z - vector.z, duration * 500, 'Linear', function (value) {
        //   this.bottle.obj.position.z = value
        // }.bind(this))

        for (var i = 0, len = this.blocksInUse.length; i < len; ++i) {
          (0, _animation.TweenAnimation)(this.blocksInUse[i].obj.position.x, this.blocksInUse[i].obj.position.x - vector.x, duration * 500, 'Linear', function (value) {
            this.obj.position.x = value;
          }.bind(this.blocksInUse[i]));
          // TweenAnimation(this.blocksInUse[i].obj.position.z, this.blocksInUse[i].obj.position.z - vector.z, duration * 500, 'Linear', function (value) {
          //   this.obj.position.z = value
          // }.bind(this.blocksInUse[i]))
        }
        if (this.blocks[0]) {
          (0, _animation.TweenAnimation)(this.blocks[0].obj.position.x, this.blocks[0].obj.position.x - vector.x, duration * 500, 'Linear', function (value) {
            this.obj.position.x = value;
          }.bind(this.blocks[0]));
        }
      } else {
        (0, _animation.TweenAnimation)(this.camera.position.x, this.camera.position.x + vector.x, duration * 500, 'Quad.easeOut', function (value) {
          this.camera.position.x = value;
        }.bind(this));
        (0, _animation.TweenAnimation)(this.camera.position.z, this.camera.position.z + vector.z, duration * 500, 'Quad.easeOut', function (value) {
          this.camera.position.z = value;
        }.bind(this));
        //TweenMax.to(this.camera.position, duration, { ease: Power2.easeOut, x: this.camera.position.x + vector.x, z: this.camera.position.z + vector.z });
      }
    }
  }, {
    key: 'update',
    value: function update(tickTime) {
      var _this = this;

      // 更新尾巴
      if (this.tailSystem) {
        this.tailSystem.update(tickTime * 1000);
      }

      this.bottle.update(tickTime);
      this.UI.update();
      if (this.renderer.shadowMap.enabled) {
        this.shadowTarget.position.x = this.bottle.obj.position.x;
        this.shadowTarget.position.z = this.bottle.obj.position.z;
        this.shadowLight.position.x = this.bottle.obj.position.x + 0;
        this.shadowLight.position.z = this.bottle.obj.position.z + 10;
      }
      for (var i = 0, len = this.blocksInUse.length; i < len; ++i) {
        this.blocksInUse[i].update();
      }

      if (this.guider && this.blocks[0]) this.blocks[0].update();

      if ((this.bottle.status === 'forerake' || this.bottle.status === 'hypsokinesis') && this.hit != 5) {
        var boxes = this.bottle.getBox();
        var blockBox = this.bottle.status === 'forerake' ? this.nextBlock.getBox() : this.currentBlock.getBox();
        for (var i = 0, len = boxes.length; i < len; ++i) {
          if (boxes[i].intersectsBox(blockBox)) {
            //   var box = new THREE.BoxHelper(this.bottle.middle, 0xffff00 );
            // var box2 = new THREE.BoxHelper(this.bottle.head, 0xffff00 );
            // var box3 = new THREE.BoxHelper(this.currentBlock.body, 0xffff00);
            // this.scene.add(box3);
            // this.scene.add(box2);
            // this.scene.add( box );
            if (i == 0) {
              this.bottle.rotate();
              if (this.suspendTimer) {
                clearTimeout(this.suspendTimer);
                this.suspendTimer = null;
              }
            } else if (i == 1) {
              this.bottle.suspend();
              if (this.suspendTimer) {
                clearTimeout(this.suspendTimer);
                this.suspendTimer = null;
              }
            } else if (i == 2 && !this.suspendTimer) {
              this.suspendTimer = setTimeout(function () {
                _this.bottle.suspend();
                _this.suspendTimer = null;
              }, 90 * this.distance);
            }
            break;
          }
        }
      }

      // 物理碰撞
      if (this.bottle.obj.position.y <= _config.BLOCK.height / 2 + 0.1 && this.bottle.status === 'jump' && this.bottle.flyingTime > 0.3 && !this.pendingReset) {
        if (this.hit === 1 || this.hit === 7) {
          this.bottle.stop();
          this.succeed();
          if (this.animating) return;
          //this.addWave(Math.min(1, 4));
          if (this.hit === 1) {
            //this.bottle.showAddScore(1, true);
            // 播放命中靶心
            this.audioManager['combo' + Math.min(this.doubleHit + 1, 8)].seek(0);
            this.audioManager['combo' + Math.min(this.doubleHit + 1, 8)].play();

            ++this.doubleHit;
            this.addWave(Math.min(this.doubleHit, 4));
            this.bottle.showAddScore(1, true, this.quick);
            this.UI.addScore(1, true, this.quick);
            this.currentScore = this.UI.score;

            if (this.mode != 'observe') {
              this.showCombo();
            }
          } else {

            // 播放成功音乐
            this.doubleHit = 0;
            this.UI.addScore(1, false, this.quick);
            this.currentScore = this.UI.score;
            this.bottle.showAddScore(1, false, this.quick);
          }
          this.audioManager.success.seek(0);
          this.audioManager.success.play();

          if (this.mode != 'observe') {

            // 更新超越头像
            this.rankSystem.update();
          }
        } else if (this.hit === 2) {
          this.bottle.stop();
          this.bottle.obj.position.y = _config.BLOCK.height / 2;
          this.bottle.obj.position.x = this.bottle.destination[0];
          this.bottle.obj.position.z = this.bottle.destination[1];
        } else if (this.hit === 3) {
          this.bottle.hypsokinesis();
          this.audioManager.fall_2.play();
          this.bottle.obj.position.y = _config.BLOCK.height / 2;
        } else if (this.hit === 4 || this.hit === 5) {
          this.bottle.forerake();
          this.audioManager.fall_2.play();
          this.bottle.obj.position.y = _config.BLOCK.height / 2;
        } else if (this.hit === 0) {
          this.bottle.fall();
          this.audioManager.fall.play();
          this.bottle.obj.position.y = _config.BLOCK.height / 2;
        } else if (this.hit === 6) {
          this.bottle.stop();
          this.audioManager.fall.play();
          this.bottle.obj.position.y = _config.BLOCK.height / 2;
        } else if (this.hit === -1) {
          this.bottle.stop();
          this.bottle.obj.position.y = _config.BLOCK.height / 2;
          this.bottle.obj.position.x = 0;
        }
        if (this.hit === 0 || this.hit === 3 || this.hit === 4 || this.hit === 5 || this.hit === 6) {
          if (this.guider) {
            if (this.UI.score > 0) {
              this.guider = false;
            } else {
              if (this.liveTime > 3) {
                this.guider = false;
                this.full2D.hide2DGradually();
              } else {
                this.live();
                return;
              }
            }
          }
          this.pendingReset = true;
          this.currentScore = this.UI.score;
          this.gameCtrl.gameOver(this.currentScore);
          this.deadTimeout = setTimeout(function () {
            _animation.TweenAnimation.killAll();
            _this.gameCtrl.gameOverShowPage();
            _this.pendingReset = false;
            if (_this.mode == 'observe') {
              _this.instructionCtrl.onCmdComplete();
            }
          }, 2000);
        } else {
          if (this.mode == 'observe') {
            this.instructionCtrl.onCmdComplete();
          }
        }
      }
      //var a = Date.now();
      this.renderer.render(this.scene, this.camera);
    }
  }, {
    key: 'succeed',
    value: function succeed() {
      var _this2 = this;

      ++this.succeedTime;
      this.musicScore = false;
      this.lastSucceedTime = Date.now();
      if (this.succeedTime % 15 == 0) {
        this.ground.changeColor();
      }
      if (this.blocksInUse.length >= 9) {
        var temp = this.blocksInUse.shift();
        temp.obj.visible = false;
        this.blocksPool.push(temp);
      }
      var firstV = this.nextBlock.obj.position.clone().sub(this.currentBlock.obj.position);
      this.bottle.obj.position.x = this.bottle.destination[0];
      this.bottle.obj.position.z = this.bottle.destination[1];
      this.bottle.squeeze();
      var block = this.thirdBlock;
      if (this.firstAnimating) return;
      if (this.guider) {
        this.guider = false;
        this.full2D.hide2DGradually();
      }
      if (this.animating) {} else {
        if (this.nextBlock.order == 15) {
          this.nextBlock.glow();
        } else if (this.nextBlock.order == 19) {
          var box = this.nextBlock;
          // this.audioManager.register('sing', () => {
          //    box.playMusic();
          //  });
          this.musicTimer = setTimeout(function () {
            _this2.audioManager.sing.seek(0);
            _this2.audioManager.sing.play();
            box.playMusic();
            _this2.musicScore = true;
            _this2.UI.addScore(30, false, false, true);
            _this2.bottle.showAddScore(30, false, false, true);
          }, 2000);
        } else if (this.nextBlock.order == 24) {
          var box = this.nextBlock;
          this.audioManager.register('store', function () {
            box.openDoor();
          }, function () {
            box.closeDoor();
          });
          this.musicTimer = setTimeout(function () {
            _this2.audioManager.store.seek(0);
            _this2.audioManager.store.play();
            _this2.musicScore = true;
            _this2.UI.addScore(15, false, false, true);
            _this2.bottle.showAddScore(15, false, false, true);
          }, 2000);
        } else if (this.nextBlock.order == 26) {
          this.musicTimer = setTimeout(function () {
            _this2.audioManager.water.seek(0);
            _this2.audioManager.water.play();
            _this2.UI.addScore(5, false, false, true);
            _this2.musicScore = true;
            _this2.bottle.showAddScore(5, false, false, true);
          }, 2000);
        } else if (this.nextBlock.order == 17) {
          var box = this.nextBlock;
          this.musicTimer = setTimeout(function () {
            box.rotateBox();
            _this2.musicScore = true;
            _this2.UI.addScore(10, false, false, true);
            _this2.bottle.showAddScore(10, false, false, true);
          }, 2000);
        }
        var nextPosition = this.nextBlock.obj.position.clone();
        var distance = this.nextBlock.radius + this.distance + block.radius;
        var straight = this.straight;
        var straight = this.straight;
        if (straight) {
          nextPosition.x += distance;
          this.bottle.lookAt('straight', nextPosition.clone());
        } else {
          nextPosition.z -= distance;
          this.bottle.lookAt('left', nextPosition.clone());
        }
        block.obj.position.x = nextPosition.x;
        block.obj.position.z = nextPosition.z;
        this.audioManager['pop'].seek(0);
        this.audioManager['pop'].play();
      }
      block.popup();
      var secondV = block.obj.position.clone().sub(this.nextBlock.obj.position);
      var cameraV = firstV.add(secondV);
      cameraV.x /= 2;
      cameraV.z /= 2;
      // this.blocksInUse.push(block);
      this.scene.add(block.obj);
      this.currentBlock = this.nextBlock;
      this.nextBlock = block;

      var duration = cameraV.length() / 10;
      if (_config.GAME.canShadow) this.bottle.scatterParticles();
      if (this.animating) cameraV.x = 19.8;
      this.moveGradually(cameraV, duration);
      this.bottle.human.rotation.z = 0;
      this.bottle.human.rotation.x = 0;
    }
  }, {
    key: 'handleWxOnHideEvent',
    value: function handleWxOnHideEvent() {
      this.show = false;

      if (this.animateTimer) {
        clearTimeout(this.animateTimer);
        this.animateTimer = null;
      }

      if (this.onshowAnimateTimer) {
        clearTimeout(this.onshowAnimateTimer);
        this.onshowAnimateTimer = null;
      }

      this.gameCtrl.wxOnhide();
    }
  }, {
    key: 'init',
    value: function init() {
      var _this3 = this;

      var fb = _storage2.default.getFirstBlood();
      if (!fb && !this.options.query.mode) {
        this.guider = true;
      }
      this.gameCtrl = new _gameCtrl2.default(this);
      this.gameView = new _gameView2.default(this);
      this.gameModel = new _gameModel2.default(this);
      this.instructionCtrl = new _instructionCtrl2.default(this);

      /**
       * 历史玩过的次数
       */
      this.historyTimes = new _historyTimes2.default(this);

      /**
       * 数据上报
       */
      this.reporter = new _reporter2.default();

      /**
       * 数据初始化
       */
      this.audioManager = new _audioManager2.default(this);
      this.gameSocket = new _socket2.default(this);

      /**
       * 初始化场景
       */
      this.scene = new THREE.Scene();
      //this.scene.fog = new THREE.Fog(0xf7d9aa, 100, 950);

      var frustumSize = _config.FRUSTUMSIZE;
      var aspect = WIDTH / HEIGHT;
      this.camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, -10, 85);
      this.camera.position.set(-17, 30, 26);
      this.camera.lookAt(new THREE.Vector3(13, 0, -4));
      this.scene.add(this.camera);

      // var CameraHelper = new THREE.CameraHelper(this.camera);
      // this.scene.add(CameraHelper);

      this.renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvas, preserveDrawingBuffer: true });
      window.renderer = this.renderer;
      //this.renderer.sortObjects = false
      //this.renderer.setPixelRatio(1)
      //this.renderer.setPixelRatio(window.devicePixelRatio ? (isIPhone ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio) : 1);


      // 坐标轴
      //var AxesHelper = new THREE.AxesHelper(1000);
      //this.scene.add(AxesHelper);

      this.blocksPool = [];
      this.blocksInUse = [];
      this.doubleHit = 0;
      if (isIPhone && (model.indexOf('iPhone 4') >= 0 || model.indexOf('iPhone 5') >= 0 || system.system.indexOf('iOS 9') >= 0 || system.system.indexOf('iOS 8') >= 0 || model.indexOf('iPhone 6') >= 0 && model.indexOf('iPhone 6s') < 0)) {
        this.renderer.shadowMap.enabled = false;
        _config.GAME.canShadow = false;
        this.renderer.setPixelRatio(1.5);
        //wx.setPreferredFramesPerSecond && wx.setPreferredFramesPerSecond(45); 
      } else {
        if (typeof system.benchmarkLevel != 'undefined' && system.benchmarkLevel < 5 && system.benchmarkLevel != -1) {
          _config.GAME.canShadow = false;
          this.renderer.shadowMap.enabled = false;
          this.renderer.setPixelRatio(window.devicePixelRatio ? isIPhone ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio : 1);
        } else {
          //GAME.canShadow = false;
          this.renderer.setPixelRatio(window.devicePixelRatio ? isIPhone ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio : 1);
          this.renderer.shadowMap.enabled = true;
        }
      }
      this.renderer.setSize(WIDTH, HEIGHT);
      this.renderer.localClippingEnabled = true;
      //this.renderer.setClearColor( 0x000000, 0 );
      this.ground = new _ground2.default();
      this.ground.obj.position.z = -84;
      //this.ground.obj.rotation.x = -0.8;
      // window.rrr = this.ground.obj.position;

      this.camera.add(this.ground.obj);

      this.waves = [];
      for (var i = 0; i < 4; ++i) {
        var wave = new _wave2.default();
        this.waves.push(wave);
        wave.obj.visible = false;
        this.scene.add(wave.obj);
      }
      var basicMaterial = new THREE.MeshBasicMaterial({ color: 0xF5F5F5 });
      this.combo = new THREE.Mesh(new THREE.CircleGeometry(0.6, 40), basicMaterial);
      this.combo.name = 'combo';
      this.combo.position.x = -50;
      this.combo.rotation.x = -Math.PI / 2;
      this.scene.add(this.combo);

      if (this.renderer.shadowMap.enabled) {
        this.shadowTarget = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), basicMaterial);
        this.shadowTarget.visible = false;
        this.shadowTarget.name = 'shadowTarget';
        this.scene.add(this.shadowTarget);
      }
      this.currentBlock = new _block2.default(0);

      this.initNextBlock = this.nextBlock = new _block2.default(1);
      this.nextBlock.obj.position.x = 20;
      this.bottle = new _bottle2.default();
      this.bottle.obj.position.set(-10, -_config.BLOCK.height / 2, 0);
      this.scene.add(this.bottle.obj);
      if (this.guider) {
        this.bottle.obj.position.set(-11, 50, 0);
        this.camera.position.x -= 19;
        setTimeout(function () {
          _this3.bottle.showup();
        }, 800);
        this.currentBlock.obj.position.x = -11;
        this.currentBlock.change(null, 'gray', 0.7);
        this.scene.add(this.currentBlock.obj);
        this.guiderTimer = setInterval(function () {
          _this3.bottle.velocity.vz = 0;
          _this3.bottle.velocity.vy = 150;
          _this3.direction = new THREE.Vector2(1, 0);
          var direction = new THREE.Vector3(1, 0, 0);
          _this3.bottle.jump(direction.normalize());
          _this3.hit = _this3.checkHit2(_this3.bottle, _this3.currentBlock);
        }, 3000);
      }
      this.blocksInUse.push(this.nextBlock);
      this.blocksInUse.push(this.currentBlock);

      for (var i = 2; i < 30; ++i) {
        var block = new _block2.default(i);
        this.blocksPool.push(block);
        //this.scene.add(block.obj);
      }

      this.full2D = new _full2D2.default({
        camera: this.camera,
        // --- 结算页：点击排行榜的回调
        onClickRank: this.gameCtrl.clickRank.bind(this.gameCtrl),
        // 在玩一局
        onClickReplay: this.gameCtrl.clickReplay.bind(this.gameCtrl),
        // 分享挑战
        onClickShare: this.gameCtrl.shareBattleCard.bind(this.gameCtrl),
        // -- 首页：游戏开始
        onClickStart: this.gameCtrl.clickStart.bind(this.gameCtrl),
        // 点击排行
        onShowFriendRank: this.gameCtrl.showFriendRank.bind(this.gameCtrl),
        // -- 挑战页面
        onBattlePlay: this.gameCtrl.onBattlePlay.bind(this.gameCtrl),
        // -- 好友排行，群分享
        onGroupShare: this.gameCtrl.shareGroupRank.bind(this.gameCtrl),
        // 返回上一页
        friendRankReturn: this.gameCtrl.friendRankReturn.bind(this.gameCtrl),
        // -- 群排行，我也玩一局
        groupPlayGame: this.gameCtrl.groupPlayGame.bind(this.gameCtrl),
        // -- 围观页，开启新的一局
        onLookersStart: this.gameCtrl.onViewerStart.bind(this.gameCtrl),
        // -- 返回微信
        onReturnWechat: function onReturnWechat() {
          wx.exitMiniProgram();
        },
        // -- 纯分享
        onClickPureShare: function onClickPureShare(type) {
          (0, _shareApp.pureShare)(type, _this3.gameModel.currentScore);
        }
      });

      this.UI = new _ui2.default(this.scene, this.camera, this.full2D, this);

      if (_config.GAME.canShadow) {
        this.tailSystem = new _tailSystem2.default(this.scene, this.bottle);
      }

      this.addLight();
      this.bindEvent();
      // this.moveCamera = new Camera(this.camera, [this.shadowLight]);

      // 围观群众
      this.viewer = new _viewer2.default(this.camera);

      // 初始化好友超越机制
      this.rankSystem = new _rankSystem2.default(this);

      // 绑定当服务器
      // Network.onServerConfigForbid(this.gameCtrl.onServerConfigForbid.bind(this.gameCtrl))

      this.audioManager.icon.play();
      this.UI.hideScore();

      // 这个一定要放在最底下
      this.gameModel.init();
      this.gameCtrl.init();
      this.gameView.init();

      /**
       * 系统事件绑定
      */
      wx.onShow(this.handleWxOnShowEvent.bind(this));
      wx.onHide(this.handleWxOnHideEvent.bind(this));
      wx.onError(this.handleWxOnError.bind(this));
      wx.onAudioInterruptionBegin && wx.onAudioInterruptionBegin(this.handleInterrupt.bind(this));

      this.gameCtrl.firstInitGame(this.options);
    }
  }, {
    key: 'loopAnimate',
    value: function loopAnimate() {
      var _this4 = this;

      var duration = 0.7;
      this.bottle.velocity.vz = Math.min(duration * _config.BOTTLE.velocityZIncrement, 180);
      this.bottle.velocity.vy = Math.min(_config.BOTTLE.velocityY + duration * _config.BOTTLE.velocityYIncrement, 180);
      var direction = new THREE.Vector3(this.nextBlock.obj.position.x - this.bottle.obj.position.x, 0, this.nextBlock.obj.position.z - this.bottle.obj.position.z);
      this.direction = new THREE.Vector2(this.nextBlock.obj.position.x - this.bottle.obj.position.x, this.nextBlock.obj.position.z - this.bottle.obj.position.z);
      this.hit = this.checkHit2(this.bottle, this.currentBlock, this.nextBlock);
      this.thirdBlock = this.generateNextBlock();
      this.thirdBlock.obj.position.set(39.7, 0, 0);
      if (this.tailSystem) {

        this.tailSystem.correctPosition();
      }
      this.bottle.jump(direction.normalize());
      this.animateTimer = setTimeout(function () {
        _this4.loopAnimate();
      }, 3000);
    }
  }, {
    key: 'animate',
    value: function animate() {
      var _this5 = this;

      this.firstAnimating = true;
      var that = this;
      for (var i = 0; i < 7; ++i) {
        setTimeout(function (i) {
          return function () {
            if ((that.mode == 'single' && (that.stage == 'startPage' || that.stage == 'friendRankList') || that.guider) && that.blocks && that.blocks.length < 7) {
              var block = new _block2.default(-1, i);
              block.showup(i);
              that.scene.add(block.obj);
              that.blocks.push(block);
              if (i == 0) this.nextBlock = block;
            }
          };
        }(i), i * 200);
      }
      setTimeout(function () {
        if (!(that.mode == 'single' && (that.stage == 'startPage' || that.stage == 'friendRankList')) && !that.guider) return;
        var duration = 0.4;
        _this5.bottle.velocity.vz = Math.min(duration * _config.BOTTLE.velocityZIncrement, 180);
        _this5.bottle.velocity.vy = Math.min(_config.BOTTLE.velocityY + duration * _config.BOTTLE.velocityYIncrement, 180);
        _this5.direction = new THREE.Vector2(_this5.nextBlock.obj.position.x - _this5.bottle.obj.position.x, _this5.nextBlock.obj.position.z - _this5.bottle.obj.position.z);
        var direction = new THREE.Vector3(_this5.nextBlock.obj.position.x - _this5.bottle.obj.position.x, 0, _this5.nextBlock.obj.position.z - _this5.bottle.obj.position.z);
        _this5.bottle.jump(direction.normalize());
        _this5.hit = -1;
        _this5.nextBlock = _this5.initNextBlock;
        for (var i = 0, len = _this5.blocks.length; i < len; ++i) {
          _animation.customAnimation.to(_this5.blocks[i].hitObj.material, 1, { opacity: 0, delay: i * 0.2 + 0.5 });
        }
        for (var i = 1, len = _this5.blocks.length; i < len; ++i) {
          _animation.customAnimation.to(_this5.blocks[i].obj.position, 0.5, { z: i % 2 == 0 ? 60 : -60, delay: i * 0.1 + 2.2 });
        }
        if (_this5.guider) {
          _animation.customAnimation.to(_this5.currentBlock.obj.position, 0.5, { z: -60, delay: 2.1 });
          var currentBlock = _this5.currentBlock;
          setTimeout(function () {
            currentBlock.obj.visible = false;
          }, 3000);
        }
        _this5.currentBlock = _this5.blocks[0];
        setTimeout(function () {
          if (!(that.mode == 'single' && (that.stage == 'startPage' || that.stage == 'friendRankList')) && !that.guider) return;
          if (that.guider) {
            //this.nextBlock.change(null, null, 1);
            //this.nextBlock.obj.position.x = 14;
            _this5.full2D.showBeginnerPage();
          }
          _this5.nextBlock.popup();
          _this5.nextBlock.greenMaterial.color.setHex(0x5d5d5d);
          _this5.nextBlock.whiteMaterial.color.setHex(0xaaaaaa);
          _this5.scene.add(_this5.nextBlock.obj);
          for (var i = 1, len = _this5.blocks.length; i < len; ++i) {
            _this5.blocks[i].obj.visible = false;
          }
          if (_this5.guider) {
            _this5.animating = false;
          }
          _this5.firstAnimating = false;
        }, 3000);
        setTimeout(function () {
          if (!(that.mode == 'single' && (that.stage == 'startPage' || that.stage == 'friendRankList'))) return;
          if (!that.show) return;
          _this5.loopAnimate();
        }, 4500);
      }, 1500);
    }
  }, {
    key: 'handleWxOnShowEvent',
    value: function handleWxOnShowEvent(options) {
      //this.handleInterrupt();

      var that = this;
      wx.setKeepScreenOn && wx.setKeepScreenOn({ keepScreenOn: true });
      this.show = true;

      this.reporter.enterReport(options.scene);

      if (!this.firstInit) this.guider = false;

      if (this.guiderTimer && !this.guider) {
        clearInterval(this.guiderTimer);
        this.guiderTimer = null;
      }

      // 处理第一次提交

      this.onshowAnimateTimer = setTimeout(function (firstInit) {
        return function () {
          if (that.mode == 'single' && that.stage == 'startPage' && !that.animateTimer && that.show) {
            if (that.blocks && that.blocks.length > 0 && !that.firstAnimating) {
              that.loopAnimate();
            } else if (!that.animating && firstInit && !that.guider) {

              that.animating = true;
              that.animate();
            }
          }
        };
      }(this.firstInit), 1000);

      if (this.firstInit) {
        this.firstInit = false;
        return;
      }

      this.gameCtrl.wxOnShow(options);
    }
  }, {
    key: 'showCombo',
    value: function showCombo() {
      var _this6 = this;

      setTimeout(function () {
        _this6.combo.position.set(_this6.nextBlock.obj.position.x, _config.BLOCK.height / 2 + 0.15, _this6.nextBlock.obj.position.z);
      }, 200);
    }
  }, {
    key: 'hideCombo',
    value: function hideCombo() {
      this.combo.position.set(-30, 0, 0);
    }
  }, {
    key: 'replayGame',
    value: function replayGame(seed) {
      this.currentScore = 0;
      this.gameCtrl.onReplayGame();
      this.audioManager.restart.seek(0);
      this.audioManager.restart.play();
      if (this.guider) {
        if (this.guiderTimer) {
          clearInterval(this.guiderTimer);
          this.guiderTimer = null;
        }
        this.animating = true;
        this.animate();
        this.moveGradually(new THREE.Vector3(19, 0, 0), 3);
      } else {
        // 播放重新开始音效
        this.resetScene(seed);
        this.bottle.showup();
      }
    }
  }, {
    key: 'addWave',
    value: function addWave(amount) {
      var that = this;
      for (var i = 0; i < amount; ++i) {
        setTimeout(function (i) {
          return function () {
            that.waves[i].obj.visible = true;
            //that.waves[i].obj.material.opacity = 1;
            that.waves[i].obj.position.set(that.bottle.obj.position.x, _config.BLOCK.height / 2 + i * 0.1 + 1, that.bottle.obj.position.z);

            (0, _animation.TweenAnimation)(that.waves[i].obj.scale.x, 4, 2 / (i / 2.5 + 2) * 500, 'Linear', function (value, complete) {
              that.waves[i].obj.scale.x = value;
              that.waves[i].obj.scale.y = value;
              that.waves[i].obj.scale.z = value;
            });

            (0, _animation.TweenAnimation)(that.waves[i].obj.material.opacity, 0, 2 / (i / 2.5 + 2) * 500, 'Linear', function (value, complete) {
              that.waves[i].obj.material.opacity = value;
              if (complete) {
                that.waves[i].reset();
              }
            });

            /*           TweenMax.to(that.waves[i].obj.scale, 2 / (i / 2.5 + 2), { x: 4, y: 4, z: 4 }); */
            // TweenMax.to(that.waves[i].obj.material, 2 / (i / 2.5 + 2), {
            // opacity: 0, onComplete: function () {
            // that.waves[i].reset();
            // }
            /* }); */
          };
        }(i), i * 200);
      }
    }
  }, {
    key: 'addLight',
    value: function addLight() {
      var ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      this.shadowLight = new THREE.DirectionalLight(0xffffff, 0.28);
      this.shadowLight.position.set(0, 15, 10);
      if (this.renderer.shadowMap.enabled) {
        this.shadowLight.castShadow = true;
        this.shadowLight.target = this.shadowTarget;
        this.shadowLight.shadow.camera.near = 5;
        this.shadowLight.shadow.camera.far = 30;
        this.shadowLight.shadow.camera.left = -10;
        this.shadowLight.shadow.camera.right = 10;
        this.shadowLight.shadow.camera.top = 10;
        this.shadowLight.shadow.camera.bottom = -10;
        this.shadowLight.shadow.mapSize.width = 512;
        this.shadowLight.shadow.mapSize.height = 512;
        var shadowGeometry = new THREE.PlaneGeometry(65, 25);
        this.shadowGround = new THREE.Mesh(shadowGeometry, new THREE.ShadowMaterial({ transparent: true, color: 0x000000, opacity: 0.3 }));
        this.shadowGround.receiveShadow = true;
        //this.shadowGround.position.z = 0;
        this.shadowGround.position.x = -25;
        this.shadowGround.position.y = -18;
        this.shadowGround.position.z = -15;
        this.shadowGround.rotation.x = -Math.PI / 2;
        this.shadowLight.add(this.shadowGround);
      }
      //this.shadowLight.shadow.radius = 1024;
      // var helper = new THREE.CameraHelper(this.shadowLight.shadow.camera);
      // this.scene.add( helper );

      // var light = new THREE.DirectionalLight(0xffffff, 0.15);
      // light.position.set(-5, 2, 20);
      // this.scene.add(light);

      //this.scene.add(hemisphereLight);
      this.scene.add(this.shadowLight);

      this.scene.add(ambientLight);
    }
  }, {
    key: 'checkHit2',
    value: function checkHit2(bottle, currentBlock, nextBlock, initY) {
      var flyingTime = bottle.velocity.vy / _config.GAME.gravity * 2;
      initY = initY || +bottle.obj.position.y.toFixed(2);
      var destinationY = _config.BLOCK.height / 2;

      var differenceY = destinationY - initY;
      var time = +((-bottle.velocity.vy + Math.sqrt(Math.pow(bottle.velocity.vy, 2) - 2 * _config.GAME.gravity * differenceY)) / -_config.GAME.gravity).toFixed(2);
      flyingTime -= time;
      flyingTime = +flyingTime.toFixed(2);
      var destination = [];
      var bottlePosition = new THREE.Vector2(bottle.obj.position.x, bottle.obj.position.z);
      var translate = this.direction.setLength(bottle.velocity.vz * flyingTime);
      bottlePosition.add(translate);
      bottle.destination = [+bottlePosition.x.toFixed(2), +bottlePosition.y.toFixed(2)];
      destination.push(+bottlePosition.x.toFixed(2), +bottlePosition.y.toFixed(2));
      if (this.animating) return 7;
      if (nextBlock) {
        var nextDiff = Math.pow(destination[0] - nextBlock.obj.position.x, 2) + Math.pow(destination[1] - nextBlock.obj.position.z, 2);
        var nextPolygon = nextBlock.getVertices();
        var result1;
        if ((0, _pointInPolygon2.default)(destination, nextPolygon)) {
          if (Math.abs(nextDiff) < 0.5) {
            return 1;
          } else {
            return 7;
          }
        } else if ((0, _pointInPolygon2.default)([destination[0] - _config.BOTTLE.bodyWidth / 2, destination[1]], nextPolygon) || (0, _pointInPolygon2.default)([destination[0], destination[1] + _config.BOTTLE.bodyDepth / 2], nextPolygon)) {
          result1 = 5;
        } else if ((0, _pointInPolygon2.default)([destination[0], destination[1] - _config.BOTTLE.bodyDepth / 2], nextPolygon) || (0, _pointInPolygon2.default)([destination[0] + _config.BOTTLE.bodyDepth / 2, destination[1]], nextPolygon)) {
          result1 = 3;
        }
      }

      var currentPolygon = currentBlock.getVertices();
      var result2;
      if ((0, _pointInPolygon2.default)(destination, currentPolygon)) {
        return 2;
      } else if ((0, _pointInPolygon2.default)([destination[0], destination[1] + _config.BOTTLE.bodyDepth / 2], currentPolygon) || (0, _pointInPolygon2.default)([destination[0] - _config.BOTTLE.bodyWidth / 2, destination[1]], currentPolygon)) {
        if (result1) return 6;
        return 4;
      }
      return result1 || result2 || 0;
    }
  }, {
    key: 'shuffleArray',
    value: function shuffleArray(array) {
      for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor((0, _random.random)() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
    }
  }, {
    key: 'generateNextBlock',
    value: function generateNextBlock() {
      var block;
      var interval = 5;
      if (this.UI.score > 1000) {
        interval = 6;
      } else if (this.succeedTime > 3000) {
        interval = 7;
      }
      if (!this.animating) {
        this.shuffleArray(this.blocksPool);
      }
      for (var i = 0, len = this.blocksPool.length; i < len; ++i) {
        if (this.succeedTime - this.lastAddBonus >= interval && this.blocksPool[i].order >= 13 || this.succeedTime - this.lastAddBonus < interval && this.blocksPool[i].order < 13) {
          block = this.blocksPool[i];
          if (block.order >= 13) {
            if (this.lastBonusOrder && this.lastBonusOrder == block.order || this.UI.score < 100 && block.order == 29) {
              continue;
            }
            this.lastAddBonus = this.succeedTime;
            this.lastBonusOrder = block.order;
          }
          this.blocksInUse.push(block);
          this.blocksPool.splice(i, 1);
          break;
        }
      }
      if (!block) {
        var temp = this.blocksInUse.shift();
        while (temp.order >= 13) {
          temp.obj.visible = false;
          this.blocksPool.push(temp);
          temp = this.blocksInUse.shift();
        }
        block = temp;
        this.blocksInUse.push(block);
      }
      block.obj.visible = false;
      block.change();
      return block;
    }
  }, {
    key: 'live',
    value: function live() {
      var _this7 = this;

      ++this.liveTime;
      this.firstAnimating = false;
      if (this.animateTimer) {
        clearTimeout(this.animateTimer);
        this.animateTimer = null;
      }
      _animation.TweenAnimation.killAll();
      this.animating = false;
      _config.BLOCK.minRadiusScale = 0.8;
      _config.BLOCK.maxRadiusScale = 1;
      _config.BLOCK.minDistance = 1;
      _config.BLOCK.maxDistance = 17;
      setTimeout(function () {
        _this7.bottle.reset();
        _this7.bottle.obj.position.x = 0;
        _this7.bottle.showup();
      }, 2000);
      this.actionList = [];
      this.musicList = [];
      this.touchList = [];
      wx.triggerGC && wx.triggerGC();
    }
  }, {
    key: 'resetScene',
    value: function resetScene(seed) {
      this.firstAnimating = false;
      for (var i = 0, len = this.blocks.length; i < len; ++i) {
        this.scene.remove(this.blocks[i].obj);
      }
      this.blocks = [];
      if (this.mode == 'observe') {
        this.audioManager.scale_intro.stop();
        this.audioManager.scale_loop.stop();
      }
      this.randomSeed = seed || Date.now();
      (0, _random.setRandomSeed)(this.randomSeed);
      this.actionList = [];
      this.musicList = [];
      this.touchList = [];
      if (this.animateTimer) {
        clearTimeout(this.animateTimer);
        this.animateTimer = null;
      }

      // 修复围观在蓄力到一半的情况下resetScene底座压缩到一半没回弹的情况
      if (this.currentBlock) {
        this.currentBlock.reset();
      }
      _animation.TweenAnimation.killAll();
      this.animating = false;
      _config.BLOCK.minRadiusScale = 0.8;
      _config.BLOCK.maxRadiusScale = 1;
      _config.BLOCK.minDistance = 1;
      _config.BLOCK.maxDistance = 17;
      // this.AudioManager.restart.currentTime = 0
      // this.audioManager.restart.play()
      for (var i = 0, len = this.blocksInUse.length; i < len; ++i) {
        var block = this.blocksInUse.pop();
        block.obj.visible = false;
        block.reset();
        this.blocksPool.push(block);
      }
      for (var i = 0, len = this.waves.length; i < len; ++i) {
        this.waves[i].reset();
      }

      this.blocksPool.sort(function (a, b) {
        return a.order - b.order;
      });
      this.currentBlock = this.blocksPool.shift();
      this.currentBlock.obj.visible = true;
      this.scene.add(this.currentBlock.obj);
      this.blocksInUse.push(this.currentBlock);
      this.shadowTarget && this.shadowTarget.position.set(0, 0, 0);
      this.nextBlock = this.blocksPool.shift();
      this.currentBlock.change(null, null, 1);
      this.nextBlock.change(null, null, 1);
      this.nextBlock.obj.position.set(20, 0, 0);
      this.currentBlock.obj.position.set(0, 0, 0);
      this.nextBlock.obj.visible = true;
      this.scene.add(this.nextBlock.obj);
      this.blocksInUse.push(this.nextBlock);
      this.bottle.reset();

      this.thirdBlock = null;

      this.UI.reset();

      this.rankSystem.reset();

      this.lastAddBonus = -2;
      this.succeedTime = 0;

      //this.moveCamera.reset();
      this.doubleHit = 0;
      this.camera.position.set(-17, 30, 26);
      this.shadowLight.position.set(0, 15, 10);
      // this.UI.showScore();
      wx.triggerGC && wx.triggerGC();
    }
  }, {
    key: 'generateHardDistances',
    value: function generateHardDistances() {
      var amount = 2 + Math.floor((0, _random.random)() * 2);
      var distances = [];
      for (var i = 0; i < amount; ++i) {
        if (i < amount - 1) {
          distances.push(_config.BLOCK.minDistance + (0, _random.random)() * 2);
        } else {
          distances.push(_config.BLOCK.maxDistance - (0, _random.random)() * 2);
        }
      }
      return distances;
    }
  }, {
    key: 'bindEvent',
    value: function bindEvent() {
      var that = this;
      that.instructionCtrl.bindCmdHandler(function (data) {
        if (data.type == -1) {
          that.gameCtrl.showPlayerGG(data.s);
          that.instructionCtrl.onCmdComplete();
          return;
        } else if (data.type == 0) {
          // that.gameCtrl.showPlayerWaiting()
          // that.replayGame(data.seed)
          that.socketFirstSync = true;
          that.bottle.reset();
          that.UI.scoreText.changeStyle({ textAlign: 'center' });
          that.UI.setScore(0);
          that.instructionCtrl.onCmdComplete();
          return;
        } else {
          that.gameCtrl.showPlayerWaiting();
          if (data.score != that.UI.score) {
            that.UI.score = data.score;
            that.UI.setScore(data.score);
          }
        }

        if (!data || !data.b || !data.b.vy) {
          that.instructionCtrl.onCmdComplete();
          return;
        }
        if (that.socketFirstSync) {
          that.socketFirstSync = false;
          that.camera.position.set(data.ca.x, data.ca.y, data.ca.z);
          that.ground.obj.position.set(data.gd.x, data.gd.y, data.gd.z);
        }
        // 如果两个序号不一样，就重置两个队列
        if (that.currentBlock.order != data.c.order || that.nextBlock.order != data.n.order) {
          for (var i = 0, len = that.blocksInUse.length; i < len; ++i) {
            var block = that.blocksInUse.pop();
            that.scene.remove(block.obj);
            that.blocksPool.push(block);
          }
          var cIn = that.blocksPool.findIndex(function (el) {
            return el.order == data.c.order;
          });
          that.currentBlock = that.blocksPool[cIn];
          var temp = that.blocksPool.splice(cIn, 1);
          that.blocksInUse.push(temp[0]);

          var nIn = that.blocksPool.findIndex(function (el) {
            return el.order == data.n.order;
          });
          that.nextBlock = that.blocksPool[nIn];
          var temp = that.blocksPool.splice(nIn, 1);
          that.blocksInUse.push(temp[0]);
        }
        that.scene.add(that.currentBlock.obj);
        that.scene.add(that.nextBlock.obj);
        that.currentBlock.obj.visible = true;
        that.nextBlock.obj.visible = true;
        that.currentBlock.obj.position.x = data.c.x;
        that.currentBlock.obj.position.z = data.c.z;
        that.currentBlock.change(data.c.r, data.c.type, data.c.rs);

        that.nextBlock.obj.position.x = data.n.x;
        that.nextBlock.obj.position.z = data.n.z;
        that.nextBlock.change(data.n.r, data.n.type, data.n.rs);

        that.bottle.obj.position.set(data.b.x, _config.BLOCK.height / 2, data.b.z);
        that.bottle.velocity.vz = data.b.vz;
        that.bottle.velocity.vy = data.b.vy;
        that.distance = data.di;
        that.straight = data.s;
        var direction = new THREE.Vector3(that.nextBlock.obj.position.x - that.bottle.obj.position.x, 0, that.nextBlock.obj.position.z - that.bottle.obj.position.z);
        that.direction = new THREE.Vector2(that.nextBlock.obj.position.x - that.bottle.obj.position.x, that.nextBlock.obj.position.z - that.bottle.obj.position.z);
        that.checkHit2(that.bottle, that.currentBlock, that.nextBlock, data.b.y);
        that.quick = data.q;
        // 先在pool里面找第三块
        if (data.t) {

          var tIn = that.blocksPool.findIndex(function (el) {
            return el.order == data.t.order;
          });
          if (tIn > -1) {
            that.thirdBlock = that.blocksPool[tIn];
            var temp = that.blocksPool.splice(tIn, 1);
            that.blocksInUse.push(that.thirdBlock);
          } else {
            that.thirdBlock = that.blocksInUse.find(function (el) {
              return el.order == data.t.order;
            });
            that.scene.remove(that.thirdBlock.obj);
          }

          that.thirdBlock.change(data.t.r, data.t.type, data.t.rs);
        }
        that.hit = data.h;
        if (that.tailSystem) {

          that.tailSystem.correctPosition();
        }

        //that.audioManager.scale_intro.stop();
        that.audioManager.scale_intro.seek(0);
        that.audioManager.scale_intro.play();
        that.bottle.prepare();
        that.currentBlock.shrink();

        var caPos = {
          x: data.ca.x,
          y: data.ca.y,
          z: data.ca.z
        };
        var gdPos = {
          x: data.gd.x,
          y: data.gd.y,
          z: data.gd.z
        };
        that.stopBlockMusic();
        that.instructionCtrl.icTimeout = setTimeout(function () {
          that.audioManager.scale_intro.stop();
          that.audioManager.scale_loop.stop();
          if (that.currentBlock.order == 15) {
            that.currentBlock.hideGlow();
          }
          that.currentBlock.rebound();
          that.camera.position.set(caPos.x, caPos.y, caPos.z);
          that.ground.obj.position.set(gdPos.x, gdPos.y, gdPos.z);
          caPos = null;
          gdPos = null;
          that.bottle.jump(direction.normalize());
        }, data.d * 1000);
        data = null;
      });
      that.gameSocket.onReciveCommand(function (seq, data) {
        if (that.mode != 'observe') {
          return;
        }
        that.instructionCtrl.onReceiveCommand(data, seq);
      });

      that.gameSocket.onPeopleCome(function (data) {
        that.gameCtrl.onPeopleCome(data);
      });

      that.gameSocket.onPlayerOut(function () {
        that.gameCtrl.onPlayerOut();
      });

      that.gameSocket.onJoinSuccess(function (success) {
        that.gameCtrl.socketJoinSuccess(success);
        if (that.mode == 'observe') {
          // 展示初始画面
          that.bottle.obj.position.set(8, -_config.BLOCK.height / 2, 0);
          that.camera.position.set(-17, 30, 26);
          that.shadowLight.position.set(0, 15, 10);
          if (that.currentBlock) {
            that.currentBlock.obj.visible = false;
          }
          if (that.nextBlock) {
            that.nextBlock.obj.visible = false;
          }
        }
      });

      canvas.addEventListener('touchstart', function (e) {
        // that.full2D.doTouchStartEvent(e); return;
        /**
         * 全局都能触发的事件
         */

        if (that.mode == 'single' || that.mode == 'player') {
          if (that.stage == 'game' && !that.is_from_wn && !that.guider) {
            if (e.changedTouches[0].clientX < WIDTH * 0.13 && e.changedTouches[0].clientY > HEIGHT * (1 - 0.12)) {
              that.gameCtrl.shareObservCard();
              return;
            }
          }
        }

        /**
         *  根据stage来改变派发事件
         */
        if (that.stage == 'friendRankList' || that.stage == 'battlePage' || that.stage == 'groupRankList' || that.stage == 'singleSettlementPgae' || that.stage == 'startPage') {
          that.full2D.doTouchStartEvent(e);
          return;
        }

        if (that.stage == 'viewerWaiting' || that.stage == 'viewerGG' || that.stage == 'viewerOut') {
          that.full2D.doTouchEndEvent(e);
          return;
        }

        if (that.stage == 'game') {
          if (that.mode === 'observe') return;
          //that.audioManager.scale_loop.stop()
          //that.audioManager.scale_intro.stop()
          if (that.bottle.status === 'stop' && !that.pendingReset && !(that.guider && that.animating)) {
            // 缩放声音开始
            // that.audioManager.scale.currentTime = 0
            that.stopBlockMusic();
            that.audioManager.scale_intro.seek(0);
            that.audioManager.scale_intro.play();
            that.bottle.prepare();
            that.currentBlock.shrink();
            that.mouseDownTime = Date.now();
            //console.log("touchend", that.mouseDownTime)
          }
          return;
        }
      });

      var touchEnd = function touchEnd(e) {
        //console.log('touchEnd', that.stage, that.mode)
        // that.full2D.doTouchEndEvent(e); return;
        var x = e.changedTouches[0].clientX;
        var y = e.changedTouches[0].clientY;

        if (that.bottle.status === 'prepare' && !that.pendingReset && !(that.guider && that.animating) && that.stage != 'game') {
          that.handleWxOnError({
            'message': 'touchstart triggered and bottle prepare but touchend error.  stage: ' + that.stage,
            'stack': ''
          });
        }

        if (that.stage == 'singleSettlementPgae' || that.stage == 'startPage') {
          that.full2D.doTouchEndEvent(e);
          return;
        }
        if (that.stage == 'viewerWaiting' || that.stage == 'viewerGG' || that.stage == 'viewerOut') {
          that.full2D.doTouchEndEvent(e);
          return;
        }

        if (that.stage == 'friendRankList') {
          that.full2D.doTouchEndEvent(e);
          return;
        }

        if (that.stage == 'battlePage') {
          that.full2D.doTouchEndEvent(e);
          return;
        }

        if (that.stage == 'groupRankList') {
          // console.log('groupRankList', 'touch')
          that.full2D.doTouchEndEvent(e);
        }

        if (that.stage == 'game') {
          if (that.bottle.status === 'prepare' && !that.pendingReset && !(that.guider && that.animating)) {
            // console.log(that.blocksPool, that.blocksInUse)
            // 缩放声音结束
            that.audioManager.scale_intro.stop();
            that.audioManager.scale_loop.stop();
            // that.audioManager['jump_' + jumpType].seek(0);
            // that.audioManager['jump_' + jumpType].play();
            that.currentBlock.rebound();
            var duration = (Date.now() - that.mouseDownTime) / 1000;
            // that.duration.push(duration);

            that.bottle.velocity.vz = Math.min(duration * _config.BOTTLE.velocityZIncrement, 150);
            that.bottle.velocity.vz = +that.bottle.velocity.vz.toFixed(2);
            that.bottle.velocity.vy = Math.min(_config.BOTTLE.velocityY + duration * _config.BOTTLE.velocityYIncrement, 180);
            that.bottle.velocity.vy = +that.bottle.velocity.vy.toFixed(2);
            that.direction = new THREE.Vector2(that.nextBlock.obj.position.x - that.bottle.obj.position.x, that.nextBlock.obj.position.z - that.bottle.obj.position.z);
            that.direction.x = +that.direction.x.toFixed(2);
            that.direction.y = +that.direction.y.toFixed(2);
            var direction = new THREE.Vector3(that.direction.x, 0, that.direction.y);
            that.bottle.jump(direction.normalize());
            that.hideCombo();
            that.hit = that.checkHit2(that.bottle, that.currentBlock, that.nextBlock);
            if (that.currentBlock.order == 15) {
              that.currentBlock.hideGlow();
            }
            // if (that.UI.score - that.lastHardLevel > 15000 && that.hardDistances.length == 0) {
            //   that.lastHardLevel = that.UI.score;
            //   that.hardDistances = that.generateHardDistances();
            // }
            // if (that.hardDistances.length > 0) {
            //   that.distance = that.hardDistances.shift();
            // }
            // else {

            that.distance = _config.BLOCK.minDistance + (0, _random.random)() * (_config.BLOCK.maxDistance - _config.BLOCK.minDistance);
            that.distance = +that.distance.toFixed(2);
            that.straight = (0, _random.random)() > 0.5 ? 1 : 0;

            if (that.hit === 1 || that.hit === 7) {
              var block = that.generateNextBlock();
              that.thirdBlock = block;
              that.quick = Date.now() - that.lastSucceedTime < 800 || false;
              that.quickArr.push(that.quick);
              if (that.mode === 'player') {
                ++that.seq;
                that.gameSocket.sendCommand(that.seq, {
                  type: 1,
                  c: { x: that.currentBlock.obj.position.x, z: that.currentBlock.obj.position.z, order: that.currentBlock.order, type: that.currentBlock.type, r: that.currentBlock.radius, rs: that.currentBlock.radiusScale },
                  n: { x: that.nextBlock.obj.position.x, z: that.nextBlock.obj.position.z, order: that.nextBlock.order, type: that.nextBlock.type, r: that.nextBlock.radius, rs: that.nextBlock.radiusScale },
                  d: duration,
                  b: { x: that.bottle.obj.position.x, y: +that.bottle.obj.position.y.toFixed(2), z: that.bottle.obj.position.z, vy: that.bottle.velocity.vy, vz: that.bottle.velocity.vz },
                  t: { order: that.thirdBlock.order, type: that.thirdBlock.type, r: that.thirdBlock.radius, rs: that.thirdBlock.radiusScale },
                  h: that.hit,
                  di: that.distance,
                  s: that.straight,
                  q: that.quick,
                  ca: { x: that.camera.position.x, y: that.camera.position.y, z: that.camera.position.z },
                  gd: { x: that.ground.obj.position.x, y: that.ground.obj.position.y, z: that.ground.obj.position.z },
                  score: that.UI.score
                  // nickname: myUserInfo.nickname,
                  // img: myUserInfo.headimg
                });
              }
            } else {
              if (that.mode === 'player') {
                ++that.seq;
                that.gameSocket.sendCommand(that.seq, {
                  type: 1,
                  c: { x: that.currentBlock.obj.position.x, z: that.currentBlock.obj.position.z, order: that.currentBlock.order, type: that.currentBlock.type, r: that.currentBlock.radius, rs: that.currentBlock.radiusScale },
                  n: { x: that.nextBlock.obj.position.x, z: that.nextBlock.obj.position.z, order: that.nextBlock.order, type: that.nextBlock.type, r: that.nextBlock.radius, rs: that.nextBlock.radiusScale },
                  d: duration,
                  b: { x: that.bottle.obj.position.x, y: +that.bottle.obj.position.y.toFixed(2), z: that.bottle.obj.position.z, vy: that.bottle.velocity.vy, vz: that.bottle.velocity.vz },
                  // t: { order: that.thirdBlock.order, type: that.thirdBlock.type, r: that.thirdBlock.radius, rs: that.thirdBlock.radiusScale },
                  h: that.hit,
                  di: that.distance,
                  s: that.straight,
                  q: that.quick,
                  ca: { x: that.camera.position.x, y: that.camera.position.y, z: that.camera.position.z },
                  gd: { x: that.ground.obj.position.x, y: that.ground.obj.position.y, z: that.ground.obj.position.z },
                  score: that.UI.score
                  // nickname: myUserInfo.nickname,
                  // img: myUserInfo.headimg
                });
              }
            }
            if (that.mode != 'observe') {
              that.actionList.push([duration, +that.bottle.obj.position.y.toFixed(2), that.quick]);
              that.musicList.push(that.musicScore);
              if (e.changedTouches && e.changedTouches[0]) {
                that.touchList.push([e.changedTouches[0].clientX, e.changedTouches[0].clientY]);
              }
            }
          }
        }
      };

      canvas.addEventListener('touchend', touchEnd);
      canvas.addEventListener('touchmove', function (e) {
        // that.full2D.doTouchMoveEvent(e); return;
        if (that.stage == 'battlePage' || that.stage == 'friendRankList' || that.stage == 'groupRankList') {
          that.full2D.doTouchMoveEvent(e);
          return;
        }
      });
    }
  }, {
    key: 'stopBlockMusic',
    value: function stopBlockMusic() {
      if (this.currentBlock.order == 19) {
        this.audioManager.sing.stop();
        this.currentBlock.stopMusic();
      } else if (this.currentBlock.order == 24) {
        this.audioManager.store.stop();
        this.currentBlock.closeDoor();
      } else if (this.currentBlock.order == 26) {
        this.audioManager.water.stop();
      }
      this.audioManager.clearTimer();
      if (this.musicTimer) {
        clearTimeout(this.musicTimer);
        this.musicTimer = null;
      }
    }
  }, {
    key: 'handleNetworkFucked',
    value: function handleNetworkFucked(show) {
      var word = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '网络异常,点击确定进入游戏';

      this.rollBackToSingle();

      if (show) {
        wx.showModal({
          title: '提示',
          content: word,
          showCancel: false
        });
      }
    }
  }, {
    key: 'handleSocketFucked',
    value: function handleSocketFucked() {
      // console.log('handleSocketFucked')
      this.gameSocket.close();
      if (this.mode == 'player') {
        this.shareObservCardFail();
        this.updateUI();
      }
      if (this.mode == 'observe') {
        this.handleNetworkFucked(true);
      }
    }
  }, {
    key: 'handleInterrupt',
    value: function handleInterrupt() {
      if (this.bottle.status == 'prepare') {
        this.bottle.stopPrepare();
        this.currentBlock.reset();
        this.audioManager.scale_loop.stop();
      }
    }
  }, {
    key: 'handleWxOnError',
    value: function handleWxOnError(error) {
      var serverRation = _session2.default.serverConfig.bad_js_ratio == undefined ? 1000000 : _session2.default.serverConfig.bad_js_ratio;
      var ratio = serverRation / 1000000 || 1;
      // var ratio = 1;
      if (Math.random() <= ratio) {
        _network2.default.badReport(error.message, error.stack);
      }
    }
  }, {
    key: 'sendServerError',
    value: function sendServerError(word) {
      _network2.default.sendServerError(word);
    }
  }]);

  return Game;
}();

if (wx.getLaunchOptionsSync) {
  var options = wx.getLaunchOptionsSync();

  var controller = new Game(options);
} else {

  var controller = new Game();
}

var lastFrameTime = Date.now();

// var Stats = function () {

//   var beginTime = Date.now(), prevTime = beginTime, frames = 0, count = 0, flag = true;

//   return {

//     begin: function () {

//       beginTime = Date.now();

//     },

//     stop: function () {
//       flag = false;
//       if (count > 3) controller.removeShadow();
//     },

//     end: function () {
//       //if (!flag) return;
//       frames++;

//       var time = Date.now();

//       //console.log("prevy", prevTime, time);
//       if (time >= prevTime + 1000) {
//         console.log("frames", frames * 1000 / (time - prevTime));

//         prevTime = time;
//         frames = 0;

//       }

//       return time;

//     }

//   };

// };

// var stats = new Stats();

var oRequestAnimation = requestAnimationFrame;
var frameCallbacks = [];
var lastestFrameCallback = void 0;

var requestAnimationFrameHandler = function requestAnimationFrameHandler() {
  var _frameCallbacks = [];
  var _lastestFrameCallback = lastestFrameCallback;

  frameCallbacks.forEach(function (cb) {
    _frameCallbacks.push(cb);
  });
  lastestFrameCallback = undefined;
  frameCallbacks.length = 0;

  _frameCallbacks.forEach(function (cb) {
    typeof cb === 'function' && cb();
  });
  if (typeof _lastestFrameCallback === 'function') {
    _lastestFrameCallback();
  }

  oRequestAnimation(requestAnimationFrameHandler);
};

window.requestAnimationFrame = function (callback, isLastest) {
  if (!isLastest) {
    frameCallbacks.push(callback);
  } else {
    lastestFrameCallback = callback;
  }
};

requestAnimationFrameHandler();

animate();
function animate() {
  //stats.begin();
  var now = Date.now();
  var tickTime = now - lastFrameTime;
  lastFrameTime = now;
  requestAnimationFrame(animate, true);
  if (tickTime > 100) return;
  controller.update(tickTime / 1000);
  //stats.end();
}

// setTimeout(() => {
//   stats.stop();
// }, 5000)

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};(function(global,factory){( false?'undefined':_typeof(exports))==='object'&&typeof module!=='undefined'?factory(exports): true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):factory(global.THREE=global.THREE||{});})(undefined,function(exports){'use strict';// Polyfills
if(Number.EPSILON===undefined){Number.EPSILON=Math.pow(2,-52);}if(Number.isInteger===undefined){// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
Number.isInteger=function(value){return typeof value==='number'&&isFinite(value)&&Math.floor(value)===value;};}//
if(Math.sign===undefined){// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
Math.sign=function(x){return x<0?-1:x>0?1:+x;};}if('name'in Function.prototype===false){// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
Object.defineProperty(Function.prototype,'name',{get:function get(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];}});}if(Object.assign===undefined){// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
(function(){Object.assign=function(target){'use strict';if(target===undefined||target===null){throw new TypeError('Cannot convert undefined or null to object');}var output=Object(target);for(var index=1;index<arguments.length;index++){var source=arguments[index];if(source!==undefined&&source!==null){for(var nextKey in source){if(Object.prototype.hasOwnProperty.call(source,nextKey)){output[nextKey]=source[nextKey];}}}}return output;};})();}/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */function EventDispatcher(){}Object.assign(EventDispatcher.prototype,{addEventListener:function addEventListener(type,listener){if(this._listeners===undefined)this._listeners={};var listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}},hasEventListener:function hasEventListener(type,listener){if(this._listeners===undefined)return false;var listeners=this._listeners;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;},removeEventListener:function removeEventListener(type,listener){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[type];if(listenerArray!==undefined){var index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}},dispatchEvent:function dispatchEvent(event){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;var array=listenerArray.slice(0);for(var i=0,l=array.length;i<l;i++){array[i].call(this,event);}}}});var REVISION='88dev';var MOUSE={LEFT:0,MIDDLE:1,RIGHT:2};var CullFaceNone=0;var CullFaceBack=1;var CullFaceFront=2;var CullFaceFrontBack=3;var FrontFaceDirectionCW=0;var FrontFaceDirectionCCW=1;var BasicShadowMap=0;var PCFShadowMap=1;var PCFSoftShadowMap=2;var FrontSide=0;var BackSide=1;var DoubleSide=2;var FlatShading=1;var SmoothShading=2;var NoColors=0;var FaceColors=1;var VertexColors=2;var NoBlending=0;var NormalBlending=1;var AdditiveBlending=2;var SubtractiveBlending=3;var MultiplyBlending=4;var CustomBlending=5;var AddEquation=100;var SubtractEquation=101;var ReverseSubtractEquation=102;var MinEquation=103;var MaxEquation=104;var ZeroFactor=200;var OneFactor=201;var SrcColorFactor=202;var OneMinusSrcColorFactor=203;var SrcAlphaFactor=204;var OneMinusSrcAlphaFactor=205;var DstAlphaFactor=206;var OneMinusDstAlphaFactor=207;var DstColorFactor=208;var OneMinusDstColorFactor=209;var SrcAlphaSaturateFactor=210;var NeverDepth=0;var AlwaysDepth=1;var LessDepth=2;var LessEqualDepth=3;var EqualDepth=4;var GreaterEqualDepth=5;var GreaterDepth=6;var NotEqualDepth=7;var MultiplyOperation=0;var MixOperation=1;var AddOperation=2;var NoToneMapping=0;var LinearToneMapping=1;var ReinhardToneMapping=2;var Uncharted2ToneMapping=3;var CineonToneMapping=4;var UVMapping=300;var CubeReflectionMapping=301;var CubeRefractionMapping=302;var EquirectangularReflectionMapping=303;var EquirectangularRefractionMapping=304;var SphericalReflectionMapping=305;var CubeUVReflectionMapping=306;var CubeUVRefractionMapping=307;var RepeatWrapping=1000;var ClampToEdgeWrapping=1001;var MirroredRepeatWrapping=1002;var NearestFilter=1003;var NearestMipMapNearestFilter=1004;var NearestMipMapLinearFilter=1005;var LinearFilter=1006;var LinearMipMapNearestFilter=1007;var LinearMipMapLinearFilter=1008;var UnsignedByteType=1009;var ByteType=1010;var ShortType=1011;var UnsignedShortType=1012;var IntType=1013;var UnsignedIntType=1014;var FloatType=1015;var HalfFloatType=1016;var UnsignedShort4444Type=1017;var UnsignedShort5551Type=1018;var UnsignedShort565Type=1019;var UnsignedInt248Type=1020;var AlphaFormat=1021;var RGBFormat=1022;var RGBAFormat=1023;var LuminanceFormat=1024;var LuminanceAlphaFormat=1025;var RGBEFormat=RGBAFormat;var DepthFormat=1026;var DepthStencilFormat=1027;var RGB_S3TC_DXT1_Format=2001;var RGBA_S3TC_DXT1_Format=2002;var RGBA_S3TC_DXT3_Format=2003;var RGBA_S3TC_DXT5_Format=2004;var RGB_PVRTC_4BPPV1_Format=2100;var RGB_PVRTC_2BPPV1_Format=2101;var RGBA_PVRTC_4BPPV1_Format=2102;var RGBA_PVRTC_2BPPV1_Format=2103;var RGB_ETC1_Format=2151;var LoopOnce=2200;var LoopRepeat=2201;var LoopPingPong=2202;var InterpolateDiscrete=2300;var InterpolateLinear=2301;var InterpolateSmooth=2302;var ZeroCurvatureEnding=2400;var ZeroSlopeEnding=2401;var WrapAroundEnding=2402;var TrianglesDrawMode=0;var TriangleStripDrawMode=1;var TriangleFanDrawMode=2;var LinearEncoding=3000;var sRGBEncoding=3001;var GammaEncoding=3007;var RGBEEncoding=3002;var LogLuvEncoding=3003;var RGBM7Encoding=3004;var RGBM16Encoding=3005;var RGBDEncoding=3006;var BasicDepthPacking=3200;var RGBADepthPacking=3201;/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */var _Math={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){// http://www.broofa.com/Tools/Math.uuid.htm
var chars='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');var uuid=new Array(36);var rnd=0,r;return function generateUUID(){for(var i=0;i<36;i++){if(i===8||i===13||i===18||i===23){uuid[i]='-';}else if(i===14){uuid[i]='4';}else{if(rnd<=0x02)rnd=0x2000000+Math.random()*0x1000000|0;r=rnd&0xf;rnd=rnd>>4;uuid[i]=chars[i===19?r&0x3|0x8:r];}}return uuid.join('');};}(),clamp:function clamp(value,min,max){return Math.max(min,Math.min(max,value));},// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
euclideanModulo:function euclideanModulo(n,m){return(n%m+m)%m;},// Linear mapping from range <a1, a2> to range <b1, b2>
mapLinear:function mapLinear(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1);},// https://en.wikipedia.org/wiki/Linear_interpolation
lerp:function lerp(x,y,t){return(1-t)*x+t*y;},// http://en.wikipedia.org/wiki/Smoothstep
smoothstep:function smoothstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x);},smootherstep:function smootherstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(x*6-15)+10);},// Random integer from <low, high> interval
randInt:function randInt(low,high){return low+Math.floor(Math.random()*(high-low+1));},// Random float from <low, high> interval
randFloat:function randFloat(low,high){return low+Math.random()*(high-low);},// Random float from <-range/2, range/2> interval
randFloatSpread:function randFloatSpread(range){return range*(0.5-Math.random());},degToRad:function degToRad(degrees){return degrees*_Math.DEG2RAD;},radToDeg:function radToDeg(radians){return radians*_Math.RAD2DEG;},isPowerOfTwo:function isPowerOfTwo(value){return(value&value-1)===0&&value!==0;},ceilPowerOfTwo:function ceilPowerOfTwo(value){return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2));},floorPowerOfTwo:function floorPowerOfTwo(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2));}};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */function Vector2(x,y){this.x=x||0;this.y=y||0;}Object.defineProperties(Vector2.prototype,{"width":{get:function get(){return this.x;},set:function set(value){this.x=value;}},"height":{get:function get(){return this.y;},set:function set(value){this.y=value;}}});Object.assign(Vector2.prototype,{isVector2:true,set:function set(x,y){this.x=x;this.y=y;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y);},copy:function copy(v){this.x=v.x;this.y=v.y;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;},multiply:function multiply(v){this.x*=v.x;this.y*=v.y;return this;},multiplyScalar:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;return this;},divide:function divide(v){this.x/=v.x;this.y/=v.y;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},applyMatrix3:function applyMatrix3(m){var x=this.x,y=this.y;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6];this.y=e[1]*x+e[4]*y+e[7];return this;},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;},clamp:function clamp(min,max){// assumes min < max, componentwise
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));return this;},clampScalar:function(){var min=new Vector2();var max=new Vector2();return function clampScalar(minVal,maxVal){min.set(minVal,minVal);max.set(maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));},floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y;},lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y);},manhattanLength:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y);},normalize:function normalize(){return this.divideScalar(this.length()||1);},angle:function angle(){// computes the angle in radians with respect to the positive x-axis
var angle=Math.atan2(this.y,this.x);if(angle<0)angle+=2*Math.PI;return angle;},distanceTo:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;},manhattanDistanceTo:function manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);},setLength:function setLength(length){return this.normalize().multiplyScalar(length);},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function equals(v){return v.x===this.x&&v.y===this.y;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);return this;},rotateAround:function rotateAround(center,angle){var c=Math.cos(angle),s=Math.sin(angle);var x=this.x-center.x;var y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */function Matrix4(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');}}Object.assign(Matrix4.prototype,{isMatrix4:true,set:function set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){var te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;},identity:function identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;},clone:function clone(){return new Matrix4().fromArray(this.elements);},copy:function copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];return this;},copyPosition:function copyPosition(m){var te=this.elements,me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;},extractBasis:function extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;},makeBasis:function makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;},extractRotation:function(){var v1=new Vector3();return function extractRotation(m){var te=this.elements;var me=m.elements;var scaleX=1/v1.setFromMatrixColumn(m,0).length();var scaleY=1/v1.setFromMatrixColumn(m,1).length();var scaleZ=1/v1.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;return this;};}(),makeRotationFromEuler:function makeRotationFromEuler(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');}var te=this.elements;var x=euler.x,y=euler.y,z=euler.z;var a=Math.cos(x),b=Math.sin(x);var c=Math.cos(y),d=Math.sin(y);var e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce-df*b;te[4]=-a*f;te[8]=de+cf*b;te[1]=cf+de*b;te[5]=a*e;te[9]=df-ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=be*d-af;te[8]=ae*d+bf;te[1]=c*f;te[5]=bf*d+ae;te[9]=af*d-be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=ac*f+bd;te[5]=a*e;te[9]=ad*f-bc;te[2]=bc*f-ad;te[6]=b*e;te[10]=bd*f+ac;}// last column
te[3]=0;te[7]=0;te[11]=0;// bottom row
te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},makeRotationFromQuaternion:function makeRotationFromQuaternion(q){var te=this.elements;var x=q._x,y=q._y,z=q._z,w=q._w;var x2=x+x,y2=y+y,z2=z+z;var xx=x*x2,xy=x*y2,xz=x*z2;var yy=y*y2,yz=y*z2,zz=z*z2;var wx=w*x2,wy=w*y2,wz=w*z2;te[0]=1-(yy+zz);te[4]=xy-wz;te[8]=xz+wy;te[1]=xy+wz;te[5]=1-(xx+zz);te[9]=yz-wx;te[2]=xz-wy;te[6]=yz+wx;te[10]=1-(xx+yy);// last column
te[3]=0;te[7]=0;te[11]=0;// bottom row
te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},lookAt:function(){var x=new Vector3();var y=new Vector3();var z=new Vector3();return function lookAt(eye,target,up){var te=this.elements;z.subVectors(eye,target);if(z.lengthSq()===0){// eye and target are in the same position
z.z=1;}z.normalize();x.crossVectors(up,z);if(x.lengthSq()===0){// up and z are parallel
if(Math.abs(up.z)===1){z.x+=0.0001;}else{z.z+=0.0001;}z.normalize();x.crossVectors(up,z);}x.normalize();y.crossVectors(z,x);te[0]=x.x;te[4]=y.x;te[8]=z.x;te[1]=x.y;te[5]=y.y;te[9]=z.y;te[2]=x.z;te[6]=y.z;te[10]=z.z;return this;};}(),multiply:function multiply(m,n){if(n!==undefined){console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');return this.multiplyMatrices(m,n);}return this.multiplyMatrices(this,m);},premultiply:function premultiply(m){return this.multiplyMatrices(m,this);},multiplyMatrices:function multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];var a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];var a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];var a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];var b11=be[0],b12=be[4],b13=be[8],b14=be[12];var b21=be[1],b22=be[5],b23=be[9],b24=be[13];var b31=be[2],b32=be[6],b33=be[10],b34=be[14];var b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;},multiplyScalar:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;},applyToBufferAttribute:function(){var v1=new Vector3();return function applyToBufferAttribute(attribute){for(var i=0,l=attribute.count;i<l;i++){v1.x=attribute.getX(i);v1.y=attribute.getY(i);v1.z=attribute.getZ(i);v1.applyMatrix4(this);attribute.setXYZ(i,v1.x,v1.y,v1.z);}return attribute;};}(),determinant:function determinant(){var te=this.elements;var n11=te[0],n12=te[4],n13=te[8],n14=te[12];var n21=te[1],n22=te[5],n23=te[9],n24=te[13];var n31=te[2],n32=te[6],n33=te[10],n34=te[14];var n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);},transpose:function transpose(){var te=this.elements;var tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;},setPosition:function setPosition(v){var te=this.elements;te[12]=v.x;te[13]=v.y;te[14]=v.z;return this;},getInverse:function getInverse(m,throwOnDegenerate){// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
var te=this.elements,me=m.elements,n11=me[0],n21=me[1],n31=me[2],n41=me[3],n12=me[4],n22=me[5],n32=me[6],n42=me[7],n13=me[8],n23=me[9],n33=me[10],n43=me[11],n14=me[12],n24=me[13],n34=me[14],n44=me[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;var det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0){var msg="THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";if(throwOnDegenerate===true){throw new Error(msg);}else{console.warn(msg);}return this.identity();}var detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;},scale:function scale(v){var te=this.elements;var x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;},getMaxScaleOnAxis:function getMaxScaleOnAxis(){var te=this.elements;var scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];var scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];var scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));},makeTranslation:function makeTranslation(x,y,z){this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);return this;},makeRotationX:function makeRotationX(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;},makeRotationY:function makeRotationY(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;},makeRotationZ:function makeRotationZ(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;},makeRotationAxis:function makeRotationAxis(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
var c=Math.cos(angle);var s=Math.sin(angle);var t=1-c;var x=axis.x,y=axis.y,z=axis.z;var tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;},makeScale:function makeScale(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;},makeShear:function makeShear(x,y,z){this.set(1,y,z,0,x,1,z,0,x,y,1,0,0,0,0,1);return this;},compose:function compose(position,quaternion,scale){this.makeRotationFromQuaternion(quaternion);this.scale(scale);this.setPosition(position);return this;},decompose:function(){var vector=new Vector3();var matrix=new Matrix4();return function decompose(position,quaternion,scale){var te=this.elements;var sx=vector.set(te[0],te[1],te[2]).length();var sy=vector.set(te[4],te[5],te[6]).length();var sz=vector.set(te[8],te[9],te[10]).length();// if determine is negative, we need to invert one scale
var det=this.determinant();if(det<0)sx=-sx;position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
matrix.copy(this);var invSX=1/sx;var invSY=1/sy;var invSZ=1/sz;matrix.elements[0]*=invSX;matrix.elements[1]*=invSX;matrix.elements[2]*=invSX;matrix.elements[4]*=invSY;matrix.elements[5]*=invSY;matrix.elements[6]*=invSY;matrix.elements[8]*=invSZ;matrix.elements[9]*=invSZ;matrix.elements[10]*=invSZ;quaternion.setFromRotationMatrix(matrix);scale.x=sx;scale.y=sy;scale.z=sz;return this;};}(),makePerspective:function makePerspective(left,right,top,bottom,near,far){if(far===undefined){console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');}var te=this.elements;var x=2*near/(right-left);var y=2*near/(top-bottom);var a=(right+left)/(right-left);var b=(top+bottom)/(top-bottom);var c=-(far+near)/(far-near);var d=-2*far*near/(far-near);te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;},makeOrthographic:function makeOrthographic(left,right,top,bottom,near,far){var te=this.elements;var w=1.0/(right-left);var h=1.0/(top-bottom);var p=1.0/(far-near);var x=(right+left)*w;var y=(top+bottom)*h;var z=(far+near)*p;te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;},equals:function equals(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<16;i++){if(te[i]!==me[i])return false;}return true;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;for(var i=0;i<16;i++){this.elements[i]=array[i+offset];}return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}});/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */function Quaternion(x,y,z,w){this._x=x||0;this._y=y||0;this._z=z||0;this._w=w!==undefined?w:1;}Object.assign(Quaternion,{slerp:function slerp(qa,qb,qm,t){return qm.copy(qa).slerp(qb,t);},slerpFlat:function slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){// fuzz-free, array-based Quaternion SLERP operation
var x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3],x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){var s=1-t,cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;// Skip the Slerp for tiny steps to avoid numeric problems:
if(sqrSin>Number.EPSILON){var sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s=Math.sin(s*len)/sin;t=Math.sin(t*len)/sin;}var tDir=t*dir;x0=x0*s+x1*tDir;y0=y0*s+y1*tDir;z0=z0*s+z1*tDir;w0=w0*s+w1*tDir;// Normalize in case we just did a lerp:
if(s===1-t){var f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}});Object.defineProperties(Quaternion.prototype,{x:{get:function get(){return this._x;},set:function set(value){this._x=value;this.onChangeCallback();}},y:{get:function get(){return this._y;},set:function set(value){this._y=value;this.onChangeCallback();}},z:{get:function get(){return this._z;},set:function set(value){this._z=value;this.onChangeCallback();}},w:{get:function get(){return this._w;},set:function set(value){this._w=value;this.onChangeCallback();}}});Object.assign(Quaternion.prototype,{set:function set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this.onChangeCallback();return this;},clone:function clone(){return new this.constructor(this._x,this._y,this._z,this._w);},copy:function copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this.onChangeCallback();return this;},setFromEuler:function setFromEuler(euler,update){if(!(euler&&euler.isEuler)){throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');}var x=euler._x,y=euler._y,z=euler._z,order=euler.order;// http://www.mathworks.com/matlabcentral/fileexchange/
// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
//	content/SpinCalc.m
var cos=Math.cos;var sin=Math.sin;var c1=cos(x/2);var c2=cos(y/2);var c3=cos(z/2);var s1=sin(x/2);var s2=sin(y/2);var s3=sin(z/2);if(order==='XYZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='YXZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='ZXY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='ZYX'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='YZX'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='XZY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}if(update!==false)this.onChangeCallback();return this;},setFromAxisAngle:function setFromAxisAngle(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
// assumes axis is normalized
var halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this.onChangeCallback();return this;},setFromRotationMatrix:function setFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33,s;if(trace>0){s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/s;this._x=0.25*s;this._y=(m12+m21)/s;this._z=(m13+m31)/s;}else if(m22>m33){s=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/s;this._x=(m12+m21)/s;this._y=0.25*s;this._z=(m23+m32)/s;}else{s=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/s;this._x=(m13+m31)/s;this._y=(m23+m32)/s;this._z=0.25*s;}this.onChangeCallback();return this;},setFromUnitVectors:function(){// assumes direction vectors vFrom and vTo are normalized
var v1=new Vector3();var r;var EPS=0.000001;return function setFromUnitVectors(vFrom,vTo){if(v1===undefined)v1=new Vector3();r=vFrom.dot(vTo)+1;if(r<EPS){r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){v1.set(-vFrom.y,vFrom.x,0);}else{v1.set(0,-vFrom.z,vFrom.y);}}else{v1.crossVectors(vFrom,vTo);}this._x=v1.x;this._y=v1.y;this._z=v1.z;this._w=r;return this.normalize();};}(),inverse:function inverse(){return this.conjugate().normalize();},conjugate:function conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this;},dot:function dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;},lengthSq:function lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;},length:function length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);},normalize:function normalize(){var l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else{l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this.onChangeCallback();return this;},multiply:function multiply(q,p){if(p!==undefined){console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');return this.multiplyQuaternions(q,p);}return this.multiplyQuaternions(this,q);},premultiply:function premultiply(q){return this.multiplyQuaternions(q,this);},multiplyQuaternions:function multiplyQuaternions(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
var qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;var qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this.onChangeCallback();return this;},slerp:function slerp(qb,t){if(t===0)return this;if(t===1)return this.copy(qb);var x=this._x,y=this._y,z=this._z,w=this._w;// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;if(cosHalfTheta<0){this._w=-qb._w;this._x=-qb._x;this._y=-qb._y;this._z=-qb._z;cosHalfTheta=-cosHalfTheta;}else{this.copy(qb);}if(cosHalfTheta>=1.0){this._w=w;this._x=x;this._y=y;this._z=z;return this;}var sinHalfTheta=Math.sqrt(1.0-cosHalfTheta*cosHalfTheta);if(Math.abs(sinHalfTheta)<0.001){this._w=0.5*(w+this._w);this._x=0.5*(x+this._x);this._y=0.5*(y+this._y);this._z=0.5*(z+this._z);return this;}var halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);var ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this._w=w*ratioA+this._w*ratioB;this._x=x*ratioA+this._x*ratioB;this._y=y*ratioA+this._y*ratioB;this._z=z*ratioA+this._z*ratioB;this.onChangeCallback();return this;},equals:function equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this.onChangeCallback();return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;},onChange:function onChange(callback){this.onChangeCallback=callback;return this;},onChangeCallback:function onChangeCallback(){}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */function Vector3(x,y,z){this.x=x||0;this.y=y||0;this.z=z||0;}Object.assign(Vector3.prototype,{isVector3:true,set:function set(x,y,z){this.x=x;this.y=y;this.z=z;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setZ:function setZ(z){this.z=z;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y,this.z);},copy:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;},multiply:function multiply(v,w){if(w!==undefined){console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');return this.multiplyVectors(v,w);}this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;},multiplyScalar:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this;},multiplyVectors:function multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;},applyEuler:function(){var quaternion=new Quaternion();return function applyEuler(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');}return this.applyQuaternion(quaternion.setFromEuler(euler));};}(),applyAxisAngle:function(){var quaternion=new Quaternion();return function applyAxisAngle(axis,angle){return this.applyQuaternion(quaternion.setFromAxisAngle(axis,angle));};}(),applyMatrix3:function applyMatrix3(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;},applyMatrix4:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;var w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return this;},applyQuaternion:function applyQuaternion(q){var x=this.x,y=this.y,z=this.z;var qx=q.x,qy=q.y,qz=q.z,qw=q.w;// calculate quat * vector
var ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;},project:function(){var matrix=new Matrix4();return function project(camera){matrix.multiplyMatrices(camera.projectionMatrix,matrix.getInverse(camera.matrixWorld));return this.applyMatrix4(matrix);};}(),unproject:function(){var matrix=new Matrix4();return function unproject(camera){matrix.multiplyMatrices(camera.matrixWorld,matrix.getInverse(camera.projectionMatrix));return this.applyMatrix4(matrix);};}(),transformDirection:function transformDirection(m){// input: THREE.Matrix4 affine matrix
// vector interpreted as a direction
var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();},divide:function divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;},clamp:function clamp(min,max){// assumes min < max, componentwise
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));return this;},clampScalar:function(){var min=new Vector3();var max=new Vector3();return function clampScalar(minVal,maxVal){min.set(minVal,minVal,minVal);max.set(maxVal,maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));},floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;},// TODO lengthSquared?
lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);},manhattanLength:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);},normalize:function normalize(){return this.divideScalar(this.length()||1);},setLength:function setLength(length){return this.normalize().multiplyScalar(length);},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},cross:function cross(v,w){if(w!==undefined){console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');return this.crossVectors(v,w);}var x=this.x,y=this.y,z=this.z;this.x=y*v.z-z*v.y;this.y=z*v.x-x*v.z;this.z=x*v.y-y*v.x;return this;},crossVectors:function crossVectors(a,b){var ax=a.x,ay=a.y,az=a.z;var bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;},projectOnVector:function projectOnVector(vector){var scalar=vector.dot(this)/vector.lengthSq();return this.copy(vector).multiplyScalar(scalar);},projectOnPlane:function(){var v1=new Vector3();return function projectOnPlane(planeNormal){v1.copy(this).projectOnVector(planeNormal);return this.sub(v1);};}(),reflect:function(){// reflect incident vector off plane orthogonal to normal
// normal is assumed to have unit length
var v1=new Vector3();return function reflect(normal){return this.sub(v1.copy(normal).multiplyScalar(2*this.dot(normal)));};}(),angleTo:function angleTo(v){var theta=this.dot(v)/Math.sqrt(this.lengthSq()*v.lengthSq());// clamp, to handle numerical problems
return Math.acos(_Math.clamp(theta,-1,1));},distanceTo:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;},manhattanDistanceTo:function manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);},setFromSpherical:function setFromSpherical(s){var sinPhiRadius=Math.sin(s.phi)*s.radius;this.x=sinPhiRadius*Math.sin(s.theta);this.y=Math.cos(s.phi)*s.radius;this.z=sinPhiRadius*Math.cos(s.theta);return this;},setFromCylindrical:function setFromCylindrical(c){this.x=c.radius*Math.sin(c.theta);this.y=c.y;this.z=c.radius*Math.cos(c.theta);return this;},setFromMatrixPosition:function setFromMatrixPosition(m){var e=m.elements;this.x=e[12];this.y=e[13];this.z=e[14];return this;},setFromMatrixScale:function setFromMatrixScale(m){var sx=this.setFromMatrixColumn(m,0).length();var sy=this.setFromMatrixColumn(m,1).length();var sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;},setFromMatrixColumn:function setFromMatrixColumn(m,index){return this.fromArray(m.elements,index*4);},equals:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}});/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */function Matrix3(){this.elements=[1,0,0,0,1,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');}}Object.assign(Matrix3.prototype,{isMatrix3:true,set:function set(n11,n12,n13,n21,n22,n23,n31,n32,n33){var te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;},identity:function identity(){this.set(1,0,0,0,1,0,0,0,1);return this;},clone:function clone(){return new this.constructor().fromArray(this.elements);},copy:function copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this;},setFromMatrix4:function setFromMatrix4(m){var me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;},applyToBufferAttribute:function(){var v1=new Vector3();return function applyToBufferAttribute(attribute){for(var i=0,l=attribute.count;i<l;i++){v1.x=attribute.getX(i);v1.y=attribute.getY(i);v1.z=attribute.getZ(i);v1.applyMatrix3(this);attribute.setXYZ(i,v1.x,v1.y,v1.z);}return attribute;};}(),multiply:function multiply(m){return this.multiplyMatrices(this,m);},premultiply:function premultiply(m){return this.multiplyMatrices(m,this);},multiplyMatrices:function multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[3],a13=ae[6];var a21=ae[1],a22=ae[4],a23=ae[7];var a31=ae[2],a32=ae[5],a33=ae[8];var b11=be[0],b12=be[3],b13=be[6];var b21=be[1],b22=be[4],b23=be[7];var b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return this;},multiplyScalar:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;},determinant:function determinant(){var te=this.elements;var a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;},getInverse:function getInverse(matrix,throwOnDegenerate){if(matrix&&matrix.isMatrix4){console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");}var me=matrix.elements,te=this.elements,n11=me[0],n21=me[1],n31=me[2],n12=me[3],n22=me[4],n32=me[5],n13=me[6],n23=me[7],n33=me[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0){var msg="THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";if(throwOnDegenerate===true){throw new Error(msg);}else{console.warn(msg);}return this.identity();}var detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;},transpose:function transpose(){var tmp,m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;},getNormalMatrix:function getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).getInverse(this).transpose();},transposeIntoArray:function transposeIntoArray(r){var m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;},setUvTransform:function setUvTransform(tx,ty,sx,sy,rotation,cx,cy){var c=Math.cos(rotation);var s=Math.sin(rotation);this.set(sx*c,sx*s,-sx*(c*cx+s*cy)+cx+tx,-sy*s,sy*c,-sy*(-s*cx+c*cy)+cy+ty,0,0,1);},scale:function scale(sx,sy){var te=this.elements;te[0]*=sx;te[3]*=sx;te[6]*=sx;te[1]*=sy;te[4]*=sy;te[7]*=sy;return this;},rotate:function rotate(theta){var c=Math.cos(theta);var s=Math.sin(theta);var te=this.elements;var a11=te[0],a12=te[3],a13=te[6];var a21=te[1],a22=te[4],a23=te[7];te[0]=c*a11+s*a21;te[3]=c*a12+s*a22;te[6]=c*a13+s*a23;te[1]=-s*a11+c*a21;te[4]=-s*a12+c*a22;te[7]=-s*a13+c*a23;return this;},translate:function translate(tx,ty){var te=this.elements;te[0]+=tx*te[2];te[3]+=tx*te[5];te[6]+=tx*te[8];te[1]+=ty*te[2];te[4]+=ty*te[5];te[7]+=ty*te[8];return this;},equals:function equals(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<9;i++){if(te[i]!==me[i])return false;}return true;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;for(var i=0;i<9;i++){this.elements[i]=array[i+offset];}return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */var textureId=0;function Texture(image,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){Object.defineProperty(this,'id',{value:textureId++});this.uuid=_Math.generateUUID();this.name='';this.image=image!==undefined?image:Texture.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=mapping!==undefined?mapping:Texture.DEFAULT_MAPPING;this.wrapS=wrapS!==undefined?wrapS:ClampToEdgeWrapping;this.wrapT=wrapT!==undefined?wrapT:ClampToEdgeWrapping;this.magFilter=magFilter!==undefined?magFilter:LinearFilter;this.minFilter=minFilter!==undefined?minFilter:LinearMipMapLinearFilter;this.anisotropy=anisotropy!==undefined?anisotropy:1;this.format=format!==undefined?format:RGBAFormat;this.type=type!==undefined?type:UnsignedByteType;this.offset=new Vector2(0,0);this.repeat=new Vector2(1,1);this.center=new Vector2(0,0);this.rotation=0;this.matrixAutoUpdate=true;this.matrix=new Matrix3();this.generateMipmaps=true;this.premultiplyAlpha=false;this.flipY=true;this.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
//
// Also changing the encoding after already used by a Material will not automatically make the Material
// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
this.encoding=encoding!==undefined?encoding:LinearEncoding;this.version=0;this.onUpdate=null;}Texture.DEFAULT_IMAGE=undefined;Texture.DEFAULT_MAPPING=UVMapping;Object.defineProperty(Texture.prototype,"needsUpdate",{set:function set(value){if(value===true)this.version++;}});Object.assign(Texture.prototype,EventDispatcher.prototype,{constructor:Texture,isTexture:true,clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.name=source.name;this.image=source.image;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.center.copy(source.center);this.rotation=source.rotation;this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrix.copy(source.matrix);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.encoding=source.encoding;return this;},toJSON:function toJSON(meta){var isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}function getDataURL(image){var canvas;if(image instanceof HTMLCanvasElement){canvas=image;}else{canvas=document.createElement('canvas');canvas.width=image.width;canvas.height=image.height;var context=canvas.getContext('2d');if(image instanceof ImageData){context.putImageData(image,0,0);}else{context.drawImage(image,0,0,image.width,image.height);}}if(canvas.width>2048||canvas.height>2048){return canvas.toDataURL('image/jpeg',0.6);}else{return canvas.toDataURL('image/png');}}var output={metadata:{version:4.5,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY};if(this.image!==undefined){// TODO: Move to THREE.Image
var image=this.image;if(image.uuid===undefined){image.uuid=_Math.generateUUID();// UGH
}if(!isRootObject&&meta.images[image.uuid]===undefined){meta.images[image.uuid]={uuid:image.uuid,url:getDataURL(image)};}output.image=image.uuid;}if(!isRootObject){meta.textures[this.uuid]=output;}return output;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});},transformUv:function transformUv(uv){if(this.mapping!==UVMapping)return;uv.applyMatrix3(this.matrix);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else{uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else{uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}}});/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */function Vector4(x,y,z,w){this.x=x||0;this.y=y||0;this.z=z||0;this.w=w!==undefined?w:1;}Object.assign(Vector4.prototype,{isVector4:true,set:function set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setZ:function setZ(z){this.z=z;return this;},setW:function setW(w){this.w=w;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y,this.z,this.w);},copy:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;},multiplyScalar:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this;},applyMatrix4:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z,w=this.w;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},setAxisAngleFromQuaternion:function setAxisAngleFromQuaternion(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
// q is assumed to be normalized
this.w=2*Math.acos(q.w);var s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else{this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;},setAxisAngleFromRotationMatrix:function setAxisAngleFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var angle,x,y,z,// variables for result
epsilon=0.01,// margin to allow for rounding errors
epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
// first check for identity matrix which must have +1 for all terms
// in leading diagonal and zero in other terms
if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
this.set(1,0,0,0);return this;// zero angle, arbitrary axis
}// otherwise this singularity is angle = 180
angle=Math.PI;var xx=(m11+1)/2;var yy=(m22+1)/2;var zz=(m33+1)/2;var xy=(m12+m21)/4;var xz=(m13+m31)/4;var yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else{x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else{y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else{// m33 is the largest diagonal term so base result on this
if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else{z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
}// as we have reached here there are no singularities so we can handle normally
var s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
// caught by singularity test above, but I've left it in just in case
this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;},clamp:function clamp(min,max){// assumes min < max, componentwise
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));this.w=Math.max(min.w,Math.min(max.w,this.w));return this;},clampScalar:function(){var min,max;return function clampScalar(minVal,maxVal){if(min===undefined){min=new Vector4();max=new Vector4();}min.set(minVal,minVal,minVal,minVal);max.set(maxVal,maxVal,maxVal,maxVal);return this.clamp(min,max);};}(),clampLength:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));},floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;},lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);},manhattanLength:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);},normalize:function normalize(){return this.divideScalar(this.length()||1);},setLength:function setLength(length){return this.normalize().multiplyScalar(length);},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}});/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 *//*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/function WebGLRenderTarget(width,height,options){this.uuid=_Math.generateUUID();this.width=width;this.height=height;this.scissor=new Vector4(0,0,width,height);this.scissorTest=false;this.viewport=new Vector4(0,0,width,height);options=options||{};if(options.minFilter===undefined)options.minFilter=LinearFilter;this.texture=new Texture(undefined,undefined,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;this.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:true;this.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;}Object.assign(WebGLRenderTarget.prototype,EventDispatcher.prototype,{isWebGLRenderTarget:true,setSize:function setSize(width,height){if(this.width!==width||this.height!==height){this.width=width;this.height=height;this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.width=source.width;this.height=source.height;this.viewport.copy(source.viewport);this.texture=source.texture.clone();this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.depthTexture=source.depthTexture;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});/**
	 * @author alteredq / http://alteredqualia.com
	 */function WebGLRenderTargetCube(width,height,options){WebGLRenderTarget.call(this,width,height,options);this.activeCubeFace=0;// PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
this.activeMipMapLevel=0;}WebGLRenderTargetCube.prototype=Object.create(WebGLRenderTarget.prototype);WebGLRenderTargetCube.prototype.constructor=WebGLRenderTargetCube;WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube=true;/**
	 * @author alteredq / http://alteredqualia.com/
	 */function DataTexture(data,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={data:data,width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;}DataTexture.prototype=Object.create(Texture.prototype);DataTexture.prototype.constructor=DataTexture;DataTexture.prototype.isDataTexture=true;/**
	 * @author mrdoob / http://mrdoob.com/
	 */function CubeTexture(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){images=images!==undefined?images:[];mapping=mapping!==undefined?mapping:CubeReflectionMapping;Texture.call(this,images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.flipY=false;}CubeTexture.prototype=Object.create(Texture.prototype);CubeTexture.prototype.constructor=CubeTexture;CubeTexture.prototype.isCubeTexture=true;Object.defineProperty(CubeTexture.prototype,'images',{get:function get(){return this.image;},set:function set(value){this.image=value;}});/**
	 * @author tschw
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [renderer] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload( gl, seq, values, renderer )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue( gl, name, value )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .set( gl, obj, prop )
	 *
	 * 		sets uniform from object and property with same name than uniform
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */var emptyTexture=new Texture();var emptyCubeTexture=new CubeTexture();// --- Base for inner nodes (including the root) ---
function UniformContainer(){this.seq=[];this.map={};}// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
var arrayCacheF32=[];var arrayCacheI32=[];// Float32Array caches used for uploading Matrix uniforms
var mat4array=new Float32Array(16);var mat3array=new Float32Array(9);// Flattening for arrays of vectors and matrices
function flatten(array,nBlocks,blockSize){var firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
// see http://jacksondunstan.com/articles/983
var n=nBlocks*blockSize,r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(var i=1,offset=0;i!==nBlocks;++i){offset+=blockSize;array[i].toArray(r,offset);}}return r;}// Texture unit allocation
function allocTexUnits(renderer,n){var r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(var i=0;i!==n;++i){r[i]=renderer.allocTextureUnit();}return r;}// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function setValue1f(gl,v){gl.uniform1f(this.addr,v);}function setValue1i(gl,v){gl.uniform1i(this.addr,v);}// Single float vector (from flat array or THREE.VectorN)
function setValue2fv(gl,v){if(v.x===undefined){gl.uniform2fv(this.addr,v);}else{gl.uniform2f(this.addr,v.x,v.y);}}function setValue3fv(gl,v){if(v.x!==undefined){gl.uniform3f(this.addr,v.x,v.y,v.z);}else if(v.r!==undefined){gl.uniform3f(this.addr,v.r,v.g,v.b);}else{gl.uniform3fv(this.addr,v);}}function setValue4fv(gl,v){if(v.x===undefined){gl.uniform4fv(this.addr,v);}else{gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);}}// Single matrix (from flat array or MatrixN)
function setValue2fm(gl,v){gl.uniformMatrix2fv(this.addr,false,v.elements||v);}function setValue3fm(gl,v){if(v.elements===undefined){gl.uniformMatrix3fv(this.addr,false,v);}else{mat3array.set(v.elements);gl.uniformMatrix3fv(this.addr,false,mat3array);}}function setValue4fm(gl,v){if(v.elements===undefined){gl.uniformMatrix4fv(this.addr,false,v);}else{mat4array.set(v.elements);gl.uniformMatrix4fv(this.addr,false,mat4array);}}// Single texture (2D / Cube)
function setValueT1(gl,v,renderer){var unit=renderer.allocTextureUnit();gl.uniform1i(this.addr,unit);renderer.setTexture2D(v||emptyTexture,unit);}function setValueT6(gl,v,renderer){var unit=renderer.allocTextureUnit();gl.uniform1i(this.addr,unit);renderer.setTextureCube(v||emptyCubeTexture,unit);}// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValue2iv(gl,v){gl.uniform2iv(this.addr,v);}function setValue3iv(gl,v){gl.uniform3iv(this.addr,v);}function setValue4iv(gl,v){gl.uniform4iv(this.addr,v);}// Helper to pick the right setter for the singular case
function getSingularSetter(type){switch(type){case 0x1406:return setValue1f;// FLOAT
case 0x8b50:return setValue2fv;// _VEC2
case 0x8b51:return setValue3fv;// _VEC3
case 0x8b52:return setValue4fv;// _VEC4
case 0x8b5a:return setValue2fm;// _MAT2
case 0x8b5b:return setValue3fm;// _MAT3
case 0x8b5c:return setValue4fm;// _MAT4
case 0x8b5e:case 0x8d66:return setValueT1;// SAMPLER_2D, SAMPLER_EXTERNAL_OES
case 0x8b60:return setValueT6;// SAMPLER_CUBE
case 0x1404:case 0x8b56:return setValue1i;// INT, BOOL
case 0x8b53:case 0x8b57:return setValue2iv;// _VEC2
case 0x8b54:case 0x8b58:return setValue3iv;// _VEC3
case 0x8b55:case 0x8b59:return setValue4iv;// _VEC4
}}// Array of scalars
function setValue1fv(gl,v){gl.uniform1fv(this.addr,v);}function setValue1iv(gl,v){gl.uniform1iv(this.addr,v);}// Array of vectors (flat or from THREE classes)
function setValueV2a(gl,v){gl.uniform2fv(this.addr,flatten(v,this.size,2));}function setValueV3a(gl,v){gl.uniform3fv(this.addr,flatten(v,this.size,3));}function setValueV4a(gl,v){gl.uniform4fv(this.addr,flatten(v,this.size,4));}// Array of matrices (flat or from THREE clases)
function setValueM2a(gl,v){gl.uniformMatrix2fv(this.addr,false,flatten(v,this.size,4));}function setValueM3a(gl,v){gl.uniformMatrix3fv(this.addr,false,flatten(v,this.size,9));}function setValueM4a(gl,v){gl.uniformMatrix4fv(this.addr,false,flatten(v,this.size,16));}// Array of textures (2D / Cube)
function setValueT1a(gl,v,renderer){var n=v.length,units=allocTexUnits(renderer,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){renderer.setTexture2D(v[i]||emptyTexture,units[i]);}}function setValueT6a(gl,v,renderer){var n=v.length,units=allocTexUnits(renderer,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){renderer.setTextureCube(v[i]||emptyCubeTexture,units[i]);}}// Helper to pick the right setter for a pure (bottom-level) array
function getPureArraySetter(type){switch(type){case 0x1406:return setValue1fv;// FLOAT
case 0x8b50:return setValueV2a;// _VEC2
case 0x8b51:return setValueV3a;// _VEC3
case 0x8b52:return setValueV4a;// _VEC4
case 0x8b5a:return setValueM2a;// _MAT2
case 0x8b5b:return setValueM3a;// _MAT3
case 0x8b5c:return setValueM4a;// _MAT4
case 0x8b5e:return setValueT1a;// SAMPLER_2D
case 0x8b60:return setValueT6a;// SAMPLER_CUBE
case 0x1404:case 0x8b56:return setValue1iv;// INT, BOOL
case 0x8b53:case 0x8b57:return setValue2iv;// _VEC2
case 0x8b54:case 0x8b58:return setValue3iv;// _VEC3
case 0x8b55:case 0x8b59:return setValue4iv;// _VEC4
}}// --- Uniform Classes ---
function SingleUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
}function PureArrayUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
}function StructuredUniform(id){this.id=id;UniformContainer.call(this);// mix-in
}StructuredUniform.prototype.setValue=function(gl,value){// Note: Don't need an extra 'renderer' parameter, since samplers
// are not allowed in structured uniforms.
var seq=this.seq;for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];u.setValue(gl,value[u.id]);}};// --- Top-level ---
// Parser - builds up the property tree from the path strings
var RePathPart=/([\w\d_]+)(\])?(\[|\.)?/g;// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){var path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
RePathPart.lastIndex=0;for(;;){var match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex,id=match[1],idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)id=id|0;// convert to integer
if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
addUniform(container,subscript===undefined?new SingleUniform(id,activeInfo,addr):new PureArrayUniform(id,activeInfo,addr));break;}else{// step into inner node / create it in case it doesn't exist
var map=container.map,next=map[id];if(next===undefined){next=new StructuredUniform(id);addUniform(container,next);}container=next;}}}// Root Container
function WebGLUniforms(gl,program,renderer){UniformContainer.call(this);this.renderer=renderer;var n=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(var i=0;i<n;++i){var info=gl.getActiveUniform(program,i),path=info.name,addr=gl.getUniformLocation(program,path);parseUniform(info,addr,this);}}WebGLUniforms.prototype.setValue=function(gl,name,value){var u=this.map[name];if(u!==undefined)u.setValue(gl,value,this.renderer);};WebGLUniforms.prototype.setOptional=function(gl,object,name){var v=object[name];if(v!==undefined)this.setValue(gl,name,v);};// Static interface
WebGLUniforms.upload=function(gl,seq,values,renderer){for(var i=0,n=seq.length;i!==n;++i){var u=seq[i],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
u.setValue(gl,v.value,renderer);}}};WebGLUniforms.seqWithValue=function(seq,values){var r=[];for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];if(u.id in values)r.push(u);}return r;};/**
	 * @author mrdoob / http://mrdoob.com/
	 */var ColorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'rebeccapurple':0x663399,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};function Color(r,g,b){if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
return this.set(r);}return this.setRGB(r,g,b);}Object.assign(Color.prototype,{isColor:true,r:1,g:1,b:1,set:function set(value){if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}return this;},setScalar:function setScalar(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;},setHex:function setHex(hex){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;return this;},setRGB:function setRGB(r,g,b){this.r=r;this.g=g;this.b=b;return this;},setHSL:function(){function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}return function setHSL(h,s,l){// h,s,l ranges are in 0.0 - 1.0
h=_Math.euclideanModulo(h,1);s=_Math.clamp(s,0,1);l=_Math.clamp(l,0,1);if(s===0){this.r=this.g=this.b=l;}else{var p=l<=0.5?l*(1+s):l+s-l*s;var q=2*l-p;this.r=hue2rgb(q,p,h+1/3);this.g=hue2rgb(q,p,h);this.b=hue2rgb(q,p,h-1/3);}return this;};}(),setStyle:function setStyle(style){function handleAlpha(string){if(string===undefined)return;if(parseFloat(string)<1){console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');}}var m;if(m=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)){// rgb / hsl
var color;var name=m[1];var components=m[2];switch(name){case'rgb':case'rgba':if(color=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
this.r=Math.min(255,parseInt(color[1],10))/255;this.g=Math.min(255,parseInt(color[2],10))/255;this.b=Math.min(255,parseInt(color[3],10))/255;handleAlpha(color[5]);return this;}if(color=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
this.r=Math.min(100,parseInt(color[1],10))/100;this.g=Math.min(100,parseInt(color[2],10))/100;this.b=Math.min(100,parseInt(color[3],10))/100;handleAlpha(color[5]);return this;}break;case'hsl':case'hsla':if(color=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
var h=parseFloat(color[1])/360;var s=parseInt(color[2],10)/100;var l=parseInt(color[3],10)/100;handleAlpha(color[5]);return this.setHSL(h,s,l);}break;}}else if(m=/^\#([A-Fa-f0-9]+)$/.exec(style)){// hex color
var hex=m[1];var size=hex.length;if(size===3){// #ff0
this.r=parseInt(hex.charAt(0)+hex.charAt(0),16)/255;this.g=parseInt(hex.charAt(1)+hex.charAt(1),16)/255;this.b=parseInt(hex.charAt(2)+hex.charAt(2),16)/255;return this;}else if(size===6){// #ff0000
this.r=parseInt(hex.charAt(0)+hex.charAt(1),16)/255;this.g=parseInt(hex.charAt(2)+hex.charAt(3),16)/255;this.b=parseInt(hex.charAt(4)+hex.charAt(5),16)/255;return this;}}if(style&&style.length>0){// color keywords
var hex=ColorKeywords[style];if(hex!==undefined){// red
this.setHex(hex);}else{// unknown color
console.warn('THREE.Color: Unknown color '+style);}}return this;},clone:function clone(){return new this.constructor(this.r,this.g,this.b);},copy:function copy(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;},copyGammaToLinear:function copyGammaToLinear(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;this.r=Math.pow(color.r,gammaFactor);this.g=Math.pow(color.g,gammaFactor);this.b=Math.pow(color.b,gammaFactor);return this;},copyLinearToGamma:function copyLinearToGamma(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;var safeInverse=gammaFactor>0?1.0/gammaFactor:1.0;this.r=Math.pow(color.r,safeInverse);this.g=Math.pow(color.g,safeInverse);this.b=Math.pow(color.b,safeInverse);return this;},convertGammaToLinear:function convertGammaToLinear(){var r=this.r,g=this.g,b=this.b;this.r=r*r;this.g=g*g;this.b=b*b;return this;},convertLinearToGamma:function convertLinearToGamma(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this;},getHex:function getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0;},getHexString:function getHexString(){return('000000'+this.getHex().toString(16)).slice(-6);},getHSL:function getHSL(optionalTarget){// h,s,l ranges are in 0.0 - 1.0
var hsl=optionalTarget||{h:0,s:0,l:0};var r=this.r,g=this.g,b=this.b;var max=Math.max(r,g,b);var min=Math.min(r,g,b);var hue,saturation;var lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else{var delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}hsl.h=hue;hsl.s=saturation;hsl.l=lightness;return hsl;},getStyle:function getStyle(){return'rgb('+(this.r*255|0)+','+(this.g*255|0)+','+(this.b*255|0)+')';},offsetHSL:function offsetHSL(h,s,l){var hsl=this.getHSL();hsl.h+=h;hsl.s+=s;hsl.l+=l;this.setHSL(hsl.h,hsl.s,hsl.l);return this;},add:function add(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;},addColors:function addColors(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;},addScalar:function addScalar(s){this.r+=s;this.g+=s;this.b+=s;return this;},sub:function sub(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;},multiply:function multiply(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;},multiplyScalar:function multiplyScalar(s){this.r*=s;this.g*=s;this.b*=s;return this;},lerp:function lerp(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;},equals:function equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;},toJSON:function toJSON(){return this.getHex();}});/**
	 * Uniforms library for shared webgl shaders
	 */var UniformsLib={common:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},map:{value:null},uvTransform:{value:new Matrix3()},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1.0},refractionRatio:{value:0.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:new Color(0xffffff)}},lights:{ambientLightColor:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{},shadow:{},shadowBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},uvTransform:{value:new Matrix3()}}};/**
	 * Uniform Utilities
	 */var UniformsUtils={merge:function merge(uniforms){var merged={};for(var u=0;u<uniforms.length;u++){var tmp=this.clone(uniforms[u]);for(var p in tmp){merged[p]=tmp[p];}}return merged;},clone:function clone(uniforms_src){var uniforms_dst={};for(var u in uniforms_src){uniforms_dst[u]={};for(var p in uniforms_src[u]){var parameter_src=uniforms_src[u][p];if(parameter_src&&(parameter_src.isColor||parameter_src.isMatrix3||parameter_src.isMatrix4||parameter_src.isVector2||parameter_src.isVector3||parameter_src.isVector4||parameter_src.isTexture)){uniforms_dst[u][p]=parameter_src.clone();}else if(Array.isArray(parameter_src)){uniforms_dst[u][p]=parameter_src.slice();}else{uniforms_dst[u][p]=parameter_src;}}}return uniforms_dst;}};var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";var alphatest_fragment="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var begin_vertex="\nvec3 transformed = vec3( position );\n";var beginnormal_vertex="\nvec3 objectNormal = vec3( normal );\n";var bsdfs="float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\n\tfloat b = 3.45068 + (4.18814 + y) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\n\treturn result;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";var color_fragment="#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";var color_pars_fragment="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";var color_pars_vertex="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";var color_vertex="#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";var common="#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";var defaultnormal_vertex="vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";var encodings_fragment="  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";var encodings_pars_fragment="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";var envmap_fragment="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";var envmap_pars_fragment="#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";var envmap_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";var fog_vertex="\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";var fog_pars_vertex="#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";var gradientmap_pars_fragment="#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";var lightmap_fragment="#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var lights_lambert_vertex="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";var lights_pars="uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";var lights_phong_pars_fragment="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tfloat norm = texture2D( ltcMag, uv ).a;\n\t\tvec4 t = texture2D( ltcMat, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3(   1,   0, t.y ),\n\t\t\tvec3(   0, t.z,   0 ),\n\t\t\tvec3( t.w,   0, t.x )\n\t\t);\n\t\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";var lights_template="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";var logdepthbuf_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";var logdepthbuf_pars_fragment="#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";var map_fragment="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";var map_particle_fragment="#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";var map_particle_pars_fragment="#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";var normal_fragment="#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";var project_vertex="vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";var dithering_fragment="#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";var dithering_pars_fragment="#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";var shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";var shadowmap_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var tonemapping_fragment="#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";var tonemapping_pars_fragment="#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";var uv_pars_fragment="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";var uv_pars_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";var uv_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";var uv2_pars_fragment="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";var uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";var uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";var cube_frag="uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";var cube_vert="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n";var depth_frag="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";var depth_vert="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";var distanceRGBA_frag="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";var distanceRGBA_vert="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";var equirect_frag="uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";var equirect_vert="varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";var linedashed_frag="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var linedashed_vert="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";var meshbasic_frag="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var meshbasic_vert="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshlambert_frag="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var meshlambert_vert="#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshphong_frag="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var meshphong_vert="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var meshphysical_frag="#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";var meshphysical_vert="#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var normal_frag="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";var normal_vert="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";var points_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";var points_vert="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var shadow_frag="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";var shadow_vert="#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";var ShaderChunk={alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,encodings_fragment:encodings_fragment,encodings_pars_fragment:encodings_pars_fragment,envmap_fragment:envmap_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_vertex:envmap_vertex,fog_vertex:fog_vertex,fog_pars_vertex:fog_pars_vertex,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_fragment:lightmap_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_vertex:lights_lambert_vertex,lights_pars:lights_pars,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_template:lights_template,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_fragment:normal_fragment,normalmap_pars_fragment:normalmap_pars_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,uv2_pars_fragment:uv2_pars_fragment,uv2_pars_vertex:uv2_pars_vertex,uv2_vertex:uv2_vertex,worldpos_vertex:worldpos_vertex,cube_frag:cube_frag,cube_vert:cube_vert,depth_frag:depth_frag,depth_vert:depth_vert,distanceRGBA_frag:distanceRGBA_frag,distanceRGBA_vert:distanceRGBA_vert,equirect_frag:equirect_frag,equirect_vert:equirect_vert,linedashed_frag:linedashed_frag,linedashed_vert:linedashed_vert,meshbasic_frag:meshbasic_frag,meshbasic_vert:meshbasic_vert,meshlambert_frag:meshlambert_frag,meshlambert_vert:meshlambert_vert,meshphong_frag:meshphong_frag,meshphong_vert:meshphong_vert,meshphysical_frag:meshphysical_frag,meshphysical_vert:meshphysical_vert,normal_frag:normal_frag,normal_vert:normal_vert,points_frag:points_frag,points_vert:points_vert,shadow_frag:shadow_frag,shadow_vert:shadow_vert};/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */var ShaderLib={basic:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},specular:{value:new Color(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},roughness:{value:0.5},metalness:{value:0.5},envMapIntensity:{value:1// temporary
}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},points:{uniforms:UniformsUtils.merge([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.normal_vert,fragmentShader:ShaderChunk.normal_frag},/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1.0}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:UniformsUtils.merge([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3()},nearDistance:{value:1},farDistance:{value:1000}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:UniformsUtils.merge([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color(0x00000)},opacity:{value:1.0}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:UniformsUtils.merge([ShaderLib.standard.uniforms,{clearCoat:{value:0},clearCoatRoughness:{value:0}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};/**
	 * @author bhouston / http://clara.io
	 */function Box2(min,max){this.min=min!==undefined?min:new Vector2(+Infinity,+Infinity);this.max=max!==undefined?max:new Vector2(-Infinity,-Infinity);}Object.assign(Box2.prototype,{set:function set(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromPoints:function setFromPoints(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function(){var v1=new Vector2();return function setFromCenterAndSize(center,size){var halfSize=v1.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;};}(),clone:function clone(){return new this.constructor().copy(this);},copy:function copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function makeEmpty(){this.min.x=this.min.y=+Infinity;this.max.x=this.max.y=-Infinity;return this;},isEmpty:function isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y;},getCenter:function getCenter(optionalTarget){var result=optionalTarget||new Vector2();return this.isEmpty()?result.set(0,0):result.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function getSize(optionalTarget){var result=optionalTarget||new Vector2();return this.isEmpty()?result.set(0,0):result.subVectors(this.max,this.min);},expandByPoint:function expandByPoint(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},containsPoint:function containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y?false:true;},containsBox:function containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y;},getParameter:function getParameter(point,optionalTarget){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
var result=optionalTarget||new Vector2();return result.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y));},intersectsBox:function intersectsBox(box){// using 4 splitting planes to rule out intersections
return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y?false:true;},clampPoint:function clampPoint(point,optionalTarget){var result=optionalTarget||new Vector2();return result.copy(point).clamp(this.min,this.max);},distanceToPoint:function(){var v1=new Vector2();return function distanceToPoint(point){var clampedPoint=v1.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();};}(),intersect:function intersect(box){this.min.max(box.min);this.max.min(box.max);return this;},union:function union(box){this.min.min(box.min);this.max.max(box.max);return this;},translate:function translate(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}});/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */function WebGLFlareRenderer(renderer,gl,state,textures,capabilities){var vertexBuffer,elementBuffer;var shader,program,attributes,uniforms;var tempTexture,occlusionTexture;function init(){var vertices=new Float32Array([-1,-1,0,0,1,-1,1,0,1,1,1,1,-1,1,0,1]);var faces=new Uint16Array([0,1,2,0,2,3]);// buffers
vertexBuffer=gl.createBuffer();elementBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,faces,gl.STATIC_DRAW);// textures
tempTexture=gl.createTexture();occlusionTexture=gl.createTexture();state.bindTexture(gl.TEXTURE_2D,tempTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGB,16,16,0,gl.RGB,gl.UNSIGNED_BYTE,null);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);state.bindTexture(gl.TEXTURE_2D,occlusionTexture);gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,16,16,0,gl.RGBA,gl.UNSIGNED_BYTE,null);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);shader={vertexShader:['uniform lowp int renderType;','uniform vec3 screenPosition;','uniform vec2 scale;','uniform float rotation;','uniform sampler2D occlusionMap;','attribute vec2 position;','attribute vec2 uv;','varying vec2 vUV;','varying float vVisibility;','void main() {','	vUV = uv;','	vec2 pos = position;','	if ( renderType == 2 ) {','		vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );','		visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );','		visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );','		visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );','		visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );','		visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );','		visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );','		visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );','		visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );','		vVisibility =        visibility.r / 9.0;','		vVisibility *= 1.0 - visibility.g / 9.0;','		vVisibility *=       visibility.b / 9.0;','		vVisibility *= 1.0 - visibility.a / 9.0;','		pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;','		pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;','	}','	gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );','}'].join('\n'),fragmentShader:['uniform lowp int renderType;','uniform sampler2D map;','uniform float opacity;','uniform vec3 color;','varying vec2 vUV;','varying float vVisibility;','void main() {',// pink square
'	if ( renderType == 0 ) {','		gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',// restore
'	} else if ( renderType == 1 ) {','		gl_FragColor = texture2D( map, vUV );',// flare
'	} else {','		vec4 texture = texture2D( map, vUV );','		texture.a *= opacity * vVisibility;','		gl_FragColor = texture;','		gl_FragColor.rgb *= color;','	}','}'].join('\n')};program=createProgram(shader);attributes={vertex:gl.getAttribLocation(program,'position'),uv:gl.getAttribLocation(program,'uv')};uniforms={renderType:gl.getUniformLocation(program,'renderType'),map:gl.getUniformLocation(program,'map'),occlusionMap:gl.getUniformLocation(program,'occlusionMap'),opacity:gl.getUniformLocation(program,'opacity'),color:gl.getUniformLocation(program,'color'),scale:gl.getUniformLocation(program,'scale'),rotation:gl.getUniformLocation(program,'rotation'),screenPosition:gl.getUniformLocation(program,'screenPosition')};}/*
		 * Render lens flares
		 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
		 *         reads these back and calculates occlusion.
		 */this.render=function(flares,scene,camera,viewport){if(flares.length===0)return;var tempPosition=new Vector3();var invAspect=viewport.w/viewport.z,halfViewportWidth=viewport.z*0.5,halfViewportHeight=viewport.w*0.5;var size=16/viewport.w,scale=new Vector2(size*invAspect,size);var screenPosition=new Vector3(1,1,0),screenPositionPixels=new Vector2(1,1);var validArea=new Box2();validArea.min.set(viewport.x,viewport.y);validArea.max.set(viewport.x+(viewport.z-16),viewport.y+(viewport.w-16));if(program===undefined){init();}state.useProgram(program);state.initAttributes();state.enableAttribute(attributes.vertex);state.enableAttribute(attributes.uv);state.disableUnusedAttributes();// loop through all lens flares to update their occlusion and positions
// setup gl and common used attribs/uniforms
gl.uniform1i(uniforms.occlusionMap,0);gl.uniform1i(uniforms.map,1);gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.vertexAttribPointer(attributes.vertex,2,gl.FLOAT,false,2*8,0);gl.vertexAttribPointer(attributes.uv,2,gl.FLOAT,false,2*8,8);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);state.disable(gl.CULL_FACE);state.buffers.depth.setMask(false);for(var i=0,l=flares.length;i<l;i++){size=16/viewport.w;scale.set(size*invAspect,size);// calc object screen position
var flare=flares[i];tempPosition.set(flare.matrixWorld.elements[12],flare.matrixWorld.elements[13],flare.matrixWorld.elements[14]);tempPosition.applyMatrix4(camera.matrixWorldInverse);tempPosition.applyMatrix4(camera.projectionMatrix);// setup arrays for gl programs
screenPosition.copy(tempPosition);// horizontal and vertical coordinate of the lower left corner of the pixels to copy
screenPositionPixels.x=viewport.x+screenPosition.x*halfViewportWidth+halfViewportWidth-8;screenPositionPixels.y=viewport.y+screenPosition.y*halfViewportHeight+halfViewportHeight-8;// screen cull
if(validArea.containsPoint(screenPositionPixels)===true){// save current RGB to temp texture
state.activeTexture(gl.TEXTURE0);state.bindTexture(gl.TEXTURE_2D,null);state.activeTexture(gl.TEXTURE1);state.bindTexture(gl.TEXTURE_2D,tempTexture);gl.copyTexImage2D(gl.TEXTURE_2D,0,gl.RGB,screenPositionPixels.x,screenPositionPixels.y,16,16,0);// render pink quad
gl.uniform1i(uniforms.renderType,0);gl.uniform2f(uniforms.scale,scale.x,scale.y);gl.uniform3f(uniforms.screenPosition,screenPosition.x,screenPosition.y,screenPosition.z);state.disable(gl.BLEND);state.enable(gl.DEPTH_TEST);gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);// copy result to occlusionMap
state.activeTexture(gl.TEXTURE0);state.bindTexture(gl.TEXTURE_2D,occlusionTexture);gl.copyTexImage2D(gl.TEXTURE_2D,0,gl.RGBA,screenPositionPixels.x,screenPositionPixels.y,16,16,0);// restore graphics
gl.uniform1i(uniforms.renderType,1);state.disable(gl.DEPTH_TEST);state.activeTexture(gl.TEXTURE1);state.bindTexture(gl.TEXTURE_2D,tempTexture);gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);// update object positions
flare.positionScreen.copy(screenPosition);if(flare.customUpdateCallback){flare.customUpdateCallback(flare);}else{flare.updateLensFlares();}// render flares
gl.uniform1i(uniforms.renderType,2);state.enable(gl.BLEND);for(var j=0,jl=flare.lensFlares.length;j<jl;j++){var sprite=flare.lensFlares[j];if(sprite.opacity>0.001&&sprite.scale>0.001){screenPosition.x=sprite.x;screenPosition.y=sprite.y;screenPosition.z=sprite.z;size=sprite.size*sprite.scale/viewport.w;scale.x=size*invAspect;scale.y=size;gl.uniform3f(uniforms.screenPosition,screenPosition.x,screenPosition.y,screenPosition.z);gl.uniform2f(uniforms.scale,scale.x,scale.y);gl.uniform1f(uniforms.rotation,sprite.rotation);gl.uniform1f(uniforms.opacity,sprite.opacity);gl.uniform3f(uniforms.color,sprite.color.r,sprite.color.g,sprite.color.b);state.setBlending(sprite.blending,sprite.blendEquation,sprite.blendSrc,sprite.blendDst);textures.setTexture2D(sprite.texture,1);gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);}}}}// restore gl
state.enable(gl.CULL_FACE);state.enable(gl.DEPTH_TEST);state.buffers.depth.setMask(true);state.reset();};function createProgram(shader){var program=gl.createProgram();var fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);var vertexShader=gl.createShader(gl.VERTEX_SHADER);var prefix='precision '+capabilities.precision+' float;\n';gl.shaderSource(fragmentShader,prefix+shader.fragmentShader);gl.shaderSource(vertexShader,prefix+shader.vertexShader);gl.compileShader(fragmentShader);gl.compileShader(vertexShader);gl.attachShader(program,fragmentShader);gl.attachShader(program,vertexShader);gl.linkProgram(program);return program;}}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function CanvasTexture(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){Texture.call(this,canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.needsUpdate=true;}CanvasTexture.prototype=Object.create(Texture.prototype);CanvasTexture.prototype.constructor=CanvasTexture;/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */function WebGLSpriteRenderer(renderer,gl,state,textures,capabilities){var vertexBuffer,elementBuffer;var program,attributes,uniforms;var texture;// decompose matrixWorld
var spritePosition=new Vector3();var spriteRotation=new Quaternion();var spriteScale=new Vector3();function init(){var vertices=new Float32Array([-0.5,-0.5,0,0,0.5,-0.5,1,0,0.5,0.5,1,1,-0.5,0.5,0,1]);var faces=new Uint16Array([0,1,2,0,2,3]);vertexBuffer=gl.createBuffer();elementBuffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,faces,gl.STATIC_DRAW);program=createProgram();attributes={position:gl.getAttribLocation(program,'position'),uv:gl.getAttribLocation(program,'uv')};uniforms={uvOffset:gl.getUniformLocation(program,'uvOffset'),uvScale:gl.getUniformLocation(program,'uvScale'),rotation:gl.getUniformLocation(program,'rotation'),scale:gl.getUniformLocation(program,'scale'),color:gl.getUniformLocation(program,'color'),map:gl.getUniformLocation(program,'map'),opacity:gl.getUniformLocation(program,'opacity'),modelViewMatrix:gl.getUniformLocation(program,'modelViewMatrix'),projectionMatrix:gl.getUniformLocation(program,'projectionMatrix'),fogType:gl.getUniformLocation(program,'fogType'),fogDensity:gl.getUniformLocation(program,'fogDensity'),fogNear:gl.getUniformLocation(program,'fogNear'),fogFar:gl.getUniformLocation(program,'fogFar'),fogColor:gl.getUniformLocation(program,'fogColor'),fogDepth:gl.getUniformLocation(program,'fogDepth'),alphaTest:gl.getUniformLocation(program,'alphaTest')};var canvas=document.createElement('canvas');canvas.width=8;canvas.height=8;var context=canvas.getContext('2d');context.fillStyle='white';context.fillRect(0,0,8,8);texture=new CanvasTexture(canvas);}this.render=function(sprites,scene,camera){if(sprites.length===0)return;// setup gl
if(program===undefined){init();}state.useProgram(program);state.initAttributes();state.enableAttribute(attributes.position);state.enableAttribute(attributes.uv);state.disableUnusedAttributes();state.disable(gl.CULL_FACE);state.enable(gl.BLEND);gl.bindBuffer(gl.ARRAY_BUFFER,vertexBuffer);gl.vertexAttribPointer(attributes.position,2,gl.FLOAT,false,2*8,0);gl.vertexAttribPointer(attributes.uv,2,gl.FLOAT,false,2*8,8);gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,elementBuffer);gl.uniformMatrix4fv(uniforms.projectionMatrix,false,camera.projectionMatrix.elements);state.activeTexture(gl.TEXTURE0);gl.uniform1i(uniforms.map,0);var oldFogType=0;var sceneFogType=0;var fog=scene.fog;if(fog){gl.uniform3f(uniforms.fogColor,fog.color.r,fog.color.g,fog.color.b);if(fog.isFog){gl.uniform1f(uniforms.fogNear,fog.near);gl.uniform1f(uniforms.fogFar,fog.far);gl.uniform1i(uniforms.fogType,1);oldFogType=1;sceneFogType=1;}else if(fog.isFogExp2){gl.uniform1f(uniforms.fogDensity,fog.density);gl.uniform1i(uniforms.fogType,2);oldFogType=2;sceneFogType=2;}}else{gl.uniform1i(uniforms.fogType,0);oldFogType=0;sceneFogType=0;}// update positions and sort
for(var i=0,l=sprites.length;i<l;i++){var sprite=sprites[i];sprite.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,sprite.matrixWorld);sprite.z=-sprite.modelViewMatrix.elements[14];}sprites.sort(painterSortStable);// render all sprites
var scale=[];for(var i=0,l=sprites.length;i<l;i++){var sprite=sprites[i];var material=sprite.material;if(material.visible===false)continue;sprite.onBeforeRender(renderer,scene,camera,undefined,material,undefined);gl.uniform1f(uniforms.alphaTest,material.alphaTest);gl.uniformMatrix4fv(uniforms.modelViewMatrix,false,sprite.modelViewMatrix.elements);sprite.matrixWorld.decompose(spritePosition,spriteRotation,spriteScale);scale[0]=spriteScale.x;scale[1]=spriteScale.y;var fogType=0;if(scene.fog&&material.fog){fogType=sceneFogType;}if(oldFogType!==fogType){gl.uniform1i(uniforms.fogType,fogType);oldFogType=fogType;}if(material.map!==null){gl.uniform2f(uniforms.uvOffset,material.map.offset.x,material.map.offset.y);gl.uniform2f(uniforms.uvScale,material.map.repeat.x,material.map.repeat.y);}else{gl.uniform2f(uniforms.uvOffset,0,0);gl.uniform2f(uniforms.uvScale,1,1);}gl.uniform1f(uniforms.opacity,material.opacity);gl.uniform3f(uniforms.color,material.color.r,material.color.g,material.color.b);gl.uniform1f(uniforms.rotation,material.rotation);gl.uniform2fv(uniforms.scale,scale);state.setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha);state.buffers.depth.setTest(material.depthTest);state.buffers.depth.setMask(material.depthWrite);state.buffers.color.setMask(material.colorWrite);textures.setTexture2D(material.map||texture,0);gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0);sprite.onAfterRender(renderer,scene,camera,undefined,material,undefined);}// restore gl
state.enable(gl.CULL_FACE);state.reset();};function createProgram(){var program=gl.createProgram();var vertexShader=gl.createShader(gl.VERTEX_SHADER);var fragmentShader=gl.createShader(gl.FRAGMENT_SHADER);gl.shaderSource(vertexShader,['precision '+capabilities.precision+' float;','#define SHADER_NAME '+'SpriteMaterial','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform float rotation;','uniform vec2 scale;','uniform vec2 uvOffset;','uniform vec2 uvScale;','attribute vec2 position;','attribute vec2 uv;','varying vec2 vUV;','varying float fogDepth;','void main() {','	vUV = uvOffset + uv * uvScale;','	vec2 alignedPosition = position * scale;','	vec2 rotatedPosition;','	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;','	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;','	vec4 mvPosition;','	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );','	mvPosition.xy += rotatedPosition;','	gl_Position = projectionMatrix * mvPosition;','	fogDepth = - mvPosition.z;','}'].join('\n'));gl.shaderSource(fragmentShader,['precision '+capabilities.precision+' float;','#define SHADER_NAME '+'SpriteMaterial','uniform vec3 color;','uniform sampler2D map;','uniform float opacity;','uniform int fogType;','uniform vec3 fogColor;','uniform float fogDensity;','uniform float fogNear;','uniform float fogFar;','uniform float alphaTest;','varying vec2 vUV;','varying float fogDepth;','void main() {','	vec4 texture = texture2D( map, vUV );','	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );','	if ( gl_FragColor.a < alphaTest ) discard;','	if ( fogType > 0 ) {','		float fogFactor = 0.0;','		if ( fogType == 1 ) {','			fogFactor = smoothstep( fogNear, fogFar, fogDepth );','		} else {','			const float LOG2 = 1.442695;','			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );','			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );','		}','		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );','	}','}'].join('\n'));gl.compileShader(vertexShader);gl.compileShader(fragmentShader);gl.attachShader(program,vertexShader);gl.attachShader(program,fragmentShader);gl.linkProgram(program);return program;}function painterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.z!==b.z){return b.z-a.z;}else{return b.id-a.id;}}}/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */var materialId=0;function Material(){Object.defineProperty(this,'id',{value:materialId++});this.uuid=_Math.generateUUID();this.name='';this.type='Material';this.fog=true;this.lights=true;this.blending=NormalBlending;this.side=FrontSide;this.flatShading=false;this.vertexColors=NoColors;// THREE.NoColors, THREE.VertexColors, THREE.FaceColors
this.opacity=1;this.transparent=false;this.blendSrc=SrcAlphaFactor;this.blendDst=OneMinusSrcAlphaFactor;this.blendEquation=AddEquation;this.blendSrcAlpha=null;this.blendDstAlpha=null;this.blendEquationAlpha=null;this.depthFunc=LessEqualDepth;this.depthTest=true;this.depthWrite=true;this.clippingPlanes=null;this.clipIntersection=false;this.clipShadows=false;this.colorWrite=true;this.precision=null;// override the renderer's default precision for this material
this.polygonOffset=false;this.polygonOffsetFactor=0;this.polygonOffsetUnits=0;this.dithering=false;this.alphaTest=0;this.premultipliedAlpha=false;this.overdraw=0;// Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
this.visible=true;this.userData={};this.needsUpdate=true;}Object.assign(Material.prototype,EventDispatcher.prototype,{isMaterial:true,onBeforeCompile:function onBeforeCompile(){},setValues:function setValues(values){if(values===undefined)return;for(var key in values){var newValue=values[key];if(newValue===undefined){console.warn("THREE.Material: '"+key+"' parameter is undefined.");continue;}// for backward compatability if shading is set in the constructor
if(key==='shading'){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=newValue===FlatShading?true:false;continue;}var currentValue=this[key];if(currentValue===undefined){console.warn("THREE."+this.type+": '"+key+"' is not a property of this material.");continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else if(key==='overdraw'){// ensure overdraw is backwards-compatible with legacy boolean type
this[key]=Number(newValue);}else{this[key]=newValue;}}},toJSON:function toJSON(meta){var isRoot=meta===undefined||typeof meta==='string';if(isRoot){meta={textures:{},images:{}};}var data={metadata:{version:4.5,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.emissiveIntensity!==1)data.emissiveIntensity=this.emissiveIntensity;if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearCoat!==undefined)data.clearCoat=this.clearCoat;if(this.clearCoatRoughness!==undefined)data.clearCoatRoughness=this.clearCoatRoughness;if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture)data.lightMap=this.lightMap.toJSON(meta).uuid;if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;data.reflectivity=this.reflectivity;// Scale behind envMap
}if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.size!==undefined)data.size=this.size;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.flatShading===true)data.flatShading=this.flatShading;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors!==NoColors)data.vertexColors=this.vertexColors;if(this.opacity<1)data.opacity=this.opacity;if(this.transparent===true)data.transparent=this.transparent;data.depthFunc=this.depthFunc;data.depthTest=this.depthTest;data.depthWrite=this.depthWrite;// rotation (SpriteMaterial)
if(this.rotation!==0)data.rotation=this.rotation;if(this.linewidth!==1)data.linewidth=this.linewidth;if(this.dashSize!==undefined)data.dashSize=this.dashSize;if(this.gapSize!==undefined)data.gapSize=this.gapSize;if(this.scale!==undefined)data.scale=this.scale;if(this.dithering===true)data.dithering=true;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;if(this.wireframe===true)data.wireframe=this.wireframe;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;if(this.morphTargets===true)data.morphTargets=true;if(this.skinning===true)data.skinning=true;if(this.visible===false)data.visible=false;if(JSON.stringify(this.userData)!=='{}')data.userData=this.userData;// TODO: Copied from Object3D.toJSON
function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}if(isRoot){var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.name=source.name;this.fog=source.fog;this.lights=source.lights;this.blending=source.blending;this.side=source.side;this.flatShading=source.flatShading;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.premultipliedAlpha=source.premultipliedAlpha;this.overdraw=source.overdraw;this.visible=source.visible;this.userData=JSON.parse(JSON.stringify(source.userData));this.clipShadows=source.clipShadows;this.clipIntersection=source.clipIntersection;var srcPlanes=source.clippingPlanes,dstPlanes=null;if(srcPlanes!==null){var n=srcPlanes.length;dstPlanes=new Array(n);for(var i=0;i!==n;++i){dstPlanes[i]=srcPlanes[i].clone();}}this.clippingPlanes=dstPlanes;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */function MeshDepthMaterial(parameters){Material.call(this);this.type='MeshDepthMaterial';this.depthPacking=BasicDepthPacking;this.skinning=false;this.morphTargets=false;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.lights=false;this.setValues(parameters);}MeshDepthMaterial.prototype=Object.create(Material.prototype);MeshDepthMaterial.prototype.constructor=MeshDepthMaterial;MeshDepthMaterial.prototype.isMeshDepthMaterial=true;MeshDepthMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.depthPacking=source.depthPacking;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this;};/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */function MeshDistanceMaterial(parameters){Material.call(this);this.type='MeshDistanceMaterial';this.referencePosition=new Vector3();this.nearDistance=1;this.farDistance=1000;this.skinning=false;this.morphTargets=false;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.fog=false;this.lights=false;this.setValues(parameters);}MeshDistanceMaterial.prototype=Object.create(Material.prototype);MeshDistanceMaterial.prototype.constructor=MeshDistanceMaterial;MeshDistanceMaterial.prototype.isMeshDistanceMaterial=true;MeshDistanceMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.referencePosition.copy(source.referencePosition);this.nearDistance=source.nearDistance;this.farDistance=source.farDistance;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;return this;};/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */function Box3(min,max){this.min=min!==undefined?min:new Vector3(+Infinity,+Infinity,+Infinity);this.max=max!==undefined?max:new Vector3(-Infinity,-Infinity,-Infinity);}Object.assign(Box3.prototype,{isBox3:true,set:function set(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromArray:function setFromArray(array){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=array.length;i<l;i+=3){var x=array[i];var y=array[i+1];var z=array[i+2];if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;},setFromBufferAttribute:function setFromBufferAttribute(attribute){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=attribute.count;i<l;i++){var x=attribute.getX(i);var y=attribute.getY(i);var z=attribute.getZ(i);if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;},setFromPoints:function setFromPoints(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function(){var v1=new Vector3();return function setFromCenterAndSize(center,size){var halfSize=v1.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;};}(),setFromObject:function setFromObject(object){this.makeEmpty();return this.expandByObject(object);},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function makeEmpty(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;},isEmpty:function isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;},getCenter:function getCenter(optionalTarget){var result=optionalTarget||new Vector3();return this.isEmpty()?result.set(0,0,0):result.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function getSize(optionalTarget){var result=optionalTarget||new Vector3();return this.isEmpty()?result.set(0,0,0):result.subVectors(this.max,this.min);},expandByPoint:function expandByPoint(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},expandByObject:function(){// Computes the world-axis-aligned bounding box of an object (including its children),
// accounting for both the object's, and children's, world transforms
var scope,i,l;var v1=new Vector3();function traverse(node){var geometry=node.geometry;if(geometry!==undefined){if(geometry.isGeometry){var vertices=geometry.vertices;for(i=0,l=vertices.length;i<l;i++){v1.copy(vertices[i]);v1.applyMatrix4(node.matrixWorld);scope.expandByPoint(v1);}}else if(geometry.isBufferGeometry){var attribute=geometry.attributes.position;if(attribute!==undefined){for(i=0,l=attribute.count;i<l;i++){v1.fromBufferAttribute(attribute,i).applyMatrix4(node.matrixWorld);scope.expandByPoint(v1);}}}}}return function expandByObject(object){scope=this;object.updateMatrixWorld(true);object.traverse(traverse);return this;};}(),containsPoint:function containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z?false:true;},containsBox:function containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;},getParameter:function getParameter(point,optionalTarget){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
var result=optionalTarget||new Vector3();return result.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));},intersectsBox:function intersectsBox(box){// using 6 splitting planes to rule out intersections.
return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?false:true;},intersectsSphere:function(){var closestPoint=new Vector3();return function intersectsSphere(sphere){// Find the point on the AABB closest to the sphere center.
this.clampPoint(sphere.center,closestPoint);// If that point is inside the sphere, the AABB and sphere intersect.
return closestPoint.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;};}(),intersectsPlane:function intersectsPlane(plane){// We compute the minimum and maximum dot product values. If those values
// are on the same side (back or front) of the plane, then there is no intersection.
var min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else{min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else{min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else{min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=plane.constant&&max>=plane.constant;},clampPoint:function clampPoint(point,optionalTarget){var result=optionalTarget||new Vector3();return result.copy(point).clamp(this.min,this.max);},distanceToPoint:function(){var v1=new Vector3();return function distanceToPoint(point){var clampedPoint=v1.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();};}(),getBoundingSphere:function(){var v1=new Vector3();return function getBoundingSphere(optionalTarget){var result=optionalTarget||new Sphere();this.getCenter(result.center);result.radius=this.getSize(v1).length()*0.5;return result;};}(),intersect:function intersect(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
if(this.isEmpty())this.makeEmpty();return this;},union:function union(box){this.min.min(box.min);this.max.max(box.max);return this;},applyMatrix4:function(){var points=[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];return function applyMatrix4(matrix){// transform of empty box is an empty box.
if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
this.setFromPoints(points);return this;};}(),translate:function translate(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}});/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */function Sphere(center,radius){this.center=center!==undefined?center:new Vector3();this.radius=radius!==undefined?radius:0;}Object.assign(Sphere.prototype,{set:function set(center,radius){this.center.copy(center);this.radius=radius;return this;},setFromPoints:function(){var box=new Box3();return function setFromPoints(points,optionalCenter){var center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else{box.setFromPoints(points).getCenter(center);}var maxRadiusSq=0;for(var i=0,il=points.length;i<il;i++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));}this.radius=Math.sqrt(maxRadiusSq);return this;};}(),clone:function clone(){return new this.constructor().copy(this);},copy:function copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;},empty:function empty(){return this.radius<=0;},containsPoint:function containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;},distanceToPoint:function distanceToPoint(point){return point.distanceTo(this.center)-this.radius;},intersectsSphere:function intersectsSphere(sphere){var radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;},intersectsBox:function intersectsBox(box){return box.intersectsSphere(this);},intersectsPlane:function intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius;},clampPoint:function clampPoint(point,optionalTarget){var deltaLengthSq=this.center.distanceToSquared(point);var result=optionalTarget||new Vector3();result.copy(point);if(deltaLengthSq>this.radius*this.radius){result.sub(this.center).normalize();result.multiplyScalar(this.radius).add(this.center);}return result;},getBoundingBox:function getBoundingBox(optionalTarget){var box=optionalTarget||new Box3();box.set(this.center,this.center);box.expandByScalar(this.radius);return box;},applyMatrix4:function applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;},translate:function translate(offset){this.center.add(offset);return this;},equals:function equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}});/**
	 * @author bhouston / http://clara.io
	 */function Plane(normal,constant){// normal is assumed to be normalized
this.normal=normal!==undefined?normal:new Vector3(1,0,0);this.constant=constant!==undefined?constant:0;}Object.assign(Plane.prototype,{set:function set(normal,constant){this.normal.copy(normal);this.constant=constant;return this;},setComponents:function setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;},setFromNormalAndCoplanarPoint:function setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this;},setFromCoplanarPoints:function(){var v1=new Vector3();var v2=new Vector3();return function setFromCoplanarPoints(a,b,c){var normal=v1.subVectors(c,b).cross(v2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
this.setFromNormalAndCoplanarPoint(normal,a);return this;};}(),clone:function clone(){return new this.constructor().copy(this);},copy:function copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;},normalize:function normalize(){// Note: will lead to a divide by zero if the plane is invalid.
var inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;},negate:function negate(){this.constant*=-1;this.normal.negate();return this;},distanceToPoint:function distanceToPoint(point){return this.normal.dot(point)+this.constant;},distanceToSphere:function distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;},projectPoint:function projectPoint(point,optionalTarget){var result=optionalTarget||new Vector3();return result.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);},intersectLine:function(){var v1=new Vector3();return function intersectLine(line,optionalTarget){var result=optionalTarget||new Vector3();var direction=line.delta(v1);var denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
if(this.distanceToPoint(line.start)===0){return result.copy(line.start);}// Unsure if this is the correct method to handle this case.
return undefined;}var t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return undefined;}return result.copy(direction).multiplyScalar(t).add(line.start);};}(),intersectsLine:function intersectsLine(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
var startSign=this.distanceToPoint(line.start);var endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;},intersectsBox:function intersectsBox(box){return box.intersectsPlane(this);},intersectsSphere:function intersectsSphere(sphere){return sphere.intersectsPlane(this);},coplanarPoint:function coplanarPoint(optionalTarget){var result=optionalTarget||new Vector3();return result.copy(this.normal).multiplyScalar(-this.constant);},applyMatrix4:function(){var v1=new Vector3();var m1=new Matrix3();return function applyMatrix4(matrix,optionalNormalMatrix){var normalMatrix=optionalNormalMatrix||m1.getNormalMatrix(matrix);var referencePoint=this.coplanarPoint(v1).applyMatrix4(matrix);var normal=this.normal.applyMatrix3(normalMatrix).normalize();this.constant=-referencePoint.dot(normal);return this;};}(),translate:function translate(offset){this.constant-=offset.dot(this.normal);return this;},equals:function equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */function Frustum(p0,p1,p2,p3,p4,p5){this.planes=[p0!==undefined?p0:new Plane(),p1!==undefined?p1:new Plane(),p2!==undefined?p2:new Plane(),p3!==undefined?p3:new Plane(),p4!==undefined?p4:new Plane(),p5!==undefined?p5:new Plane()];}Object.assign(Frustum.prototype,{set:function set(p0,p1,p2,p3,p4,p5){var planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(frustum){var planes=this.planes;for(var i=0;i<6;i++){planes[i].copy(frustum.planes[i]);}return this;},setFromMatrix:function setFromMatrix(m){var planes=this.planes;var me=m.elements;var me0=me[0],me1=me[1],me2=me[2],me3=me[3];var me4=me[4],me5=me[5],me6=me[6],me7=me[7];var me8=me[8],me9=me[9],me10=me[10],me11=me[11];var me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();return this;},intersectsObject:function(){var sphere=new Sphere();return function intersectsObject(object){var geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return this.intersectsSphere(sphere);};}(),intersectsSprite:function(){var sphere=new Sphere();return function intersectsSprite(sprite){sphere.center.set(0,0,0);sphere.radius=0.7071067811865476;sphere.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(sphere);};}(),intersectsSphere:function intersectsSphere(sphere){var planes=this.planes;var center=sphere.center;var negRadius=-sphere.radius;for(var i=0;i<6;i++){var distance=planes[i].distanceToPoint(center);if(distance<negRadius){return false;}}return true;},intersectsBox:function(){var p1=new Vector3(),p2=new Vector3();return function intersectsBox(box){var planes=this.planes;for(var i=0;i<6;i++){var plane=planes[i];p1.x=plane.normal.x>0?box.min.x:box.max.x;p2.x=plane.normal.x>0?box.max.x:box.min.x;p1.y=plane.normal.y>0?box.min.y:box.max.y;p2.y=plane.normal.y>0?box.max.y:box.min.y;p1.z=plane.normal.z>0?box.min.z:box.max.z;p2.z=plane.normal.z>0?box.max.z:box.min.z;var d1=plane.distanceToPoint(p1);var d2=plane.distanceToPoint(p2);// if both outside plane, no intersection
if(d1<0&&d2<0){return false;}}return true;};}(),containsPoint:function containsPoint(point){var planes=this.planes;for(var i=0;i<6;i++){if(planes[i].distanceToPoint(point)<0){return false;}}return true;}});/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLShadowMap(_renderer,_objects,maxTextureSize){var _frustum=new Frustum(),_projScreenMatrix=new Matrix4(),_shadowMapSize=new Vector2(),_maxShadowMapSize=new Vector2(maxTextureSize,maxTextureSize),_lookTarget=new Vector3(),_lightPositionWorld=new Vector3(),_MorphingFlag=1,_SkinningFlag=2,_NumberOfMaterialVariants=(_MorphingFlag|_SkinningFlag)+1,_depthMaterials=new Array(_NumberOfMaterialVariants),_distanceMaterials=new Array(_NumberOfMaterialVariants),_materialCache={};var cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];var cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)];var cube2DViewPorts=[new Vector4(),new Vector4(),new Vector4(),new Vector4(),new Vector4(),new Vector4()];// init
for(var i=0;i!==_NumberOfMaterialVariants;++i){var useMorphing=(i&_MorphingFlag)!==0;var useSkinning=(i&_SkinningFlag)!==0;var depthMaterial=new MeshDepthMaterial({depthPacking:RGBADepthPacking,morphTargets:useMorphing,skinning:useSkinning});_depthMaterials[i]=depthMaterial;//
var distanceMaterial=new MeshDistanceMaterial({morphTargets:useMorphing,skinning:useSkinning});_distanceMaterials[i]=distanceMaterial;}//
var scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;this.renderReverseSided=true;this.renderSingleSided=true;this.render=function(lights,scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(lights.length===0)return;// TODO Clean up (needed in case of contextlost)
var _gl=_renderer.context;var _state=_renderer.state;// Set GL state for depth map.
_state.disable(_gl.BLEND);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(true);_state.setScissorTest(false);// render depth map
var faceCount;for(var i=0,il=lights.length;i<il;i++){var light=lights[i];var shadow=light.shadow;var isPointLight=light&&light.isPointLight;if(shadow===undefined){console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');continue;}var shadowCamera=shadow.camera;_shadowMapSize.copy(shadow.mapSize);_shadowMapSize.min(_maxShadowMapSize);if(isPointLight){var vpWidth=_shadowMapSize.x;var vpHeight=_shadowMapSize.y;// These viewports map a cube-map onto a 2D texture with the
// following orientation:
//
//  xzXZ
//   y Y
//
// X - Positive x direction
// x - Negative x direction
// Y - Positive y direction
// y - Negative y direction
// Z - Positive z direction
// z - Negative z direction
// positive X
cube2DViewPorts[0].set(vpWidth*2,vpHeight,vpWidth,vpHeight);// negative X
cube2DViewPorts[1].set(0,vpHeight,vpWidth,vpHeight);// positive Z
cube2DViewPorts[2].set(vpWidth*3,vpHeight,vpWidth,vpHeight);// negative Z
cube2DViewPorts[3].set(vpWidth,vpHeight,vpWidth,vpHeight);// positive Y
cube2DViewPorts[4].set(vpWidth*3,0,vpWidth,vpHeight);// negative Y
cube2DViewPorts[5].set(vpWidth,0,vpWidth,vpHeight);_shadowMapSize.x*=4.0;_shadowMapSize.y*=2.0;}if(shadow.map===null){var pars={minFilter:NearestFilter,magFilter:NearestFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+".shadowMap";shadowCamera.updateProjectionMatrix();}if(shadow.isSpotLightShadow){shadow.update(light);}var shadowMap=shadow.map;var shadowMatrix=shadow.matrix;_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(_lightPositionWorld);if(isPointLight){faceCount=6;// for point lights we set the shadow matrix to be a translation-only matrix
// equal to inverse of the light's position
shadowMatrix.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z);}else{faceCount=1;_lookTarget.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget);shadowCamera.updateMatrixWorld();// compute shadow matrix
shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);shadowMatrix.multiply(shadowCamera.projectionMatrix);shadowMatrix.multiply(shadowCamera.matrixWorldInverse);}_renderer.setRenderTarget(shadowMap);_renderer.clear();// render shadow map for each cube face (if omni-directional) or
// run a single pass if not
for(var face=0;face<faceCount;face++){if(isPointLight){_lookTarget.copy(shadowCamera.position);_lookTarget.add(cubeDirections[face]);shadowCamera.up.copy(cubeUps[face]);shadowCamera.lookAt(_lookTarget);shadowCamera.updateMatrixWorld();var vpDimensions=cube2DViewPorts[face];_state.viewport(vpDimensions);}// update camera matrices and frustum
_projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);_frustum.setFromMatrix(_projScreenMatrix);// set object matrices & frustum culling
renderObject(scene,camera,shadowCamera,isPointLight);}}scope.needsUpdate=false;};function getDepthMaterial(object,material,isPointLight,lightPositionWorld,shadowCameraNear,shadowCameraFar){var geometry=object.geometry;var result=null;var materialVariants=_depthMaterials;var customMaterial=object.customDepthMaterial;if(isPointLight){materialVariants=_distanceMaterials;customMaterial=object.customDistanceMaterial;}if(!customMaterial){var useMorphing=false;if(material.morphTargets){if(geometry&&geometry.isBufferGeometry){useMorphing=geometry.morphAttributes&&geometry.morphAttributes.position&&geometry.morphAttributes.position.length>0;}else if(geometry&&geometry.isGeometry){useMorphing=geometry.morphTargets&&geometry.morphTargets.length>0;}}if(object.isSkinnedMesh&&material.skinning===false){console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',object);}var useSkinning=object.isSkinnedMesh&&material.skinning;var variantIndex=0;if(useMorphing)variantIndex|=_MorphingFlag;if(useSkinning)variantIndex|=_SkinningFlag;result=materialVariants[variantIndex];}else{result=customMaterial;}if(_renderer.localClippingEnabled&&material.clipShadows===true&&material.clippingPlanes.length!==0){// in this case we need a unique material instance reflecting the
// appropriate state
var keyA=result.uuid,keyB=material.uuid;var materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}var cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;}result=cachedMaterial;}result.visible=material.visible;result.wireframe=material.wireframe;var side=material.side;if(scope.renderSingleSided&&side==DoubleSide){side=FrontSide;}if(scope.renderReverseSided){if(side===FrontSide)side=BackSide;else if(side===BackSide)side=FrontSide;}result.side=side;result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.clipIntersection=material.clipIntersection;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(isPointLight&&result.isMeshDistanceMaterial){result.referencePosition.copy(lightPositionWorld);result.nearDistance=shadowCameraNear;result.farDistance=shadowCameraFar;}return result;}function renderObject(object,camera,shadowCamera,isPointLight){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible&&(object.isMesh||object.isLine||object.isPoints)){if(object.castShadow&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);var geometry=_objects.update(object);var material=object.material;if(Array.isArray(material)){var groups=geometry.groups;for(var k=0,kl=groups.length;k<kl;k++){var group=groups[k];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){var depthMaterial=getDepthMaterial(object,groupMaterial,isPointLight,_lightPositionWorld,shadowCamera.near,shadowCamera.far);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);}}}else if(material.visible){var depthMaterial=getDepthMaterial(object,material,isPointLight,_lightPositionWorld,shadowCamera.near,shadowCamera.far);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null);}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){renderObject(children[i],camera,shadowCamera,isPointLight);}}}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLAttributes(gl){var buffers={};function createBuffer(attribute,bufferType){var array=attribute.array;var usage=attribute.dynamic?gl.DYNAMIC_DRAW:gl.STATIC_DRAW;var buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();var type=gl.FLOAT;if(array instanceof Float32Array){type=gl.FLOAT;}else if(array instanceof Float64Array){console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');}else if(array instanceof Uint16Array){type=gl.UNSIGNED_SHORT;}else if(array instanceof Int16Array){type=gl.SHORT;}else if(array instanceof Uint32Array){type=gl.UNSIGNED_INT;}else if(array instanceof Int32Array){type=gl.INT;}else if(array instanceof Int8Array){type=gl.BYTE;}else if(array instanceof Uint8Array){type=gl.UNSIGNED_BYTE;}return{buffer:buffer,type:type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version};}function updateBuffer(buffer,attribute,bufferType){var array=attribute.array;var updateRange=attribute.updateRange;gl.bindBuffer(bufferType,buffer);if(attribute.dynamic===false){gl.bufferData(bufferType,array,gl.STATIC_DRAW);}else if(updateRange.count===-1){// Not using update ranges
gl.bufferSubData(bufferType,0,array);}else if(updateRange.count===0){console.error('THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.');}else{gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array.subarray(updateRange.offset,updateRange.offset+updateRange.count));updateRange.count=-1;// reset range
}}//
function get(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;return buffers[attribute.uuid];}function remove(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers[attribute.uuid];if(data){gl.deleteBuffer(data.buffer);delete buffers[attribute.uuid];}}function update(attribute,bufferType){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers[attribute.uuid];if(data===undefined){buffers[attribute.uuid]=createBuffer(attribute,bufferType);}else if(data.version<attribute.version){updateBuffer(data.buffer,attribute,bufferType);data.version=attribute.version;}}return{get:get,remove:remove,update:update};}/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */function Euler(x,y,z,order){this._x=x||0;this._y=y||0;this._z=z||0;this._order=order||Euler.DefaultOrder;}Euler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];Euler.DefaultOrder='XYZ';Object.defineProperties(Euler.prototype,{x:{get:function get(){return this._x;},set:function set(value){this._x=value;this.onChangeCallback();}},y:{get:function get(){return this._y;},set:function set(value){this._y=value;this.onChangeCallback();}},z:{get:function get(){return this._z;},set:function set(value){this._z=value;this.onChangeCallback();}},order:{get:function get(){return this._order;},set:function set(value){this._order=value;this.onChangeCallback();}}});Object.assign(Euler.prototype,{isEuler:true,set:function set(x,y,z,order){this._x=x;this._y=y;this._z=z;this._order=order||this._order;this.onChangeCallback();return this;},clone:function clone(){return new this.constructor(this._x,this._y,this._z,this._order);},copy:function copy(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this.onChangeCallback();return this;},setFromRotationMatrix:function setFromRotationMatrix(m,order,update){var clamp=_Math.clamp;// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var te=m.elements;var m11=te[0],m12=te[4],m13=te[8];var m21=te[1],m22=te[5],m23=te[9];var m31=te[2],m32=te[6],m33=te[10];order=order||this._order;if(order==='XYZ'){this._y=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.99999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else{this._x=Math.atan2(m32,m22);this._z=0;}}else if(order==='YXZ'){this._x=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.99999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else{this._y=Math.atan2(-m31,m11);this._z=0;}}else if(order==='ZXY'){this._x=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.99999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else{this._y=0;this._z=Math.atan2(m21,m11);}}else if(order==='ZYX'){this._y=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.99999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else{this._x=0;this._z=Math.atan2(-m12,m22);}}else if(order==='YZX'){this._z=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.99999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else{this._x=0;this._y=Math.atan2(m13,m33);}}else if(order==='XZY'){this._z=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.99999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else{this._x=Math.atan2(-m23,m33);this._y=0;}}else{console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: '+order);}this._order=order;if(update!==false)this.onChangeCallback();return this;},setFromQuaternion:function(){var matrix=new Matrix4();return function setFromQuaternion(q,order,update){matrix.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(matrix,order,update);};}(),setFromVector3:function setFromVector3(v,order){return this.set(v.x,v.y,v.z,order||this._order);},reorder:function(){// WARNING: this discards revolution information -bhouston
var q=new Quaternion();return function reorder(newOrder){q.setFromEuler(this);return this.setFromQuaternion(q,newOrder);};}(),equals:function equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;},fromArray:function fromArray(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this.onChangeCallback();return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;},toVector3:function toVector3(optionalResult){if(optionalResult){return optionalResult.set(this._x,this._y,this._z);}else{return new Vector3(this._x,this._y,this._z);}},onChange:function onChange(callback){this.onChangeCallback=callback;return this;},onChangeCallback:function onChangeCallback(){}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Layers(){this.mask=1|0;}Object.assign(Layers.prototype,{set:function set(channel){this.mask=1<<channel|0;},enable:function enable(channel){this.mask|=1<<channel|0;},toggle:function toggle(channel){this.mask^=1<<channel|0;},disable:function disable(channel){this.mask&=~(1<<channel|0);},test:function test(layers){return(this.mask&layers.mask)!==0;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */var object3DId=0;function Object3D(){Object.defineProperty(this,'id',{value:object3DId++});this.uuid=_Math.generateUUID();this.name='';this.type='Object3D';this.parent=null;this.children=[];this.up=Object3D.DefaultUp.clone();var position=new Vector3();var rotation=new Euler();var quaternion=new Quaternion();var scale=new Vector3(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation.onChange(onRotationChange);quaternion.onChange(onQuaternionChange);Object.defineProperties(this,{position:{enumerable:true,value:position},rotation:{enumerable:true,value:rotation},quaternion:{enumerable:true,value:quaternion},scale:{enumerable:true,value:scale},modelViewMatrix:{value:new Matrix4()},normalMatrix:{value:new Matrix3()}});this.matrix=new Matrix4();this.matrixWorld=new Matrix4();this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=false;this.layers=new Layers();this.visible=true;this.castShadow=false;this.receiveShadow=false;this.frustumCulled=true;this.renderOrder=0;this.userData={};}Object3D.DefaultUp=new Vector3(0,1,0);Object3D.DefaultMatrixAutoUpdate=true;Object.assign(Object3D.prototype,EventDispatcher.prototype,{isObject3D:true,onBeforeRender:function onBeforeRender(){},onAfterRender:function onAfterRender(){},applyMatrix:function applyMatrix(matrix){this.matrix.multiplyMatrices(matrix,this.matrix);this.matrix.decompose(this.position,this.quaternion,this.scale);},applyQuaternion:function applyQuaternion(q){this.quaternion.premultiply(q);return this;},setRotationFromAxisAngle:function setRotationFromAxisAngle(axis,angle){// assumes axis is normalized
this.quaternion.setFromAxisAngle(axis,angle);},setRotationFromEuler:function setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,true);},setRotationFromMatrix:function setRotationFromMatrix(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
this.quaternion.setFromRotationMatrix(m);},setRotationFromQuaternion:function setRotationFromQuaternion(q){// assumes q is normalized
this.quaternion.copy(q);},rotateOnAxis:function(){// rotate object on axis in object space
// axis is assumed to be normalized
var q1=new Quaternion();return function rotateOnAxis(axis,angle){q1.setFromAxisAngle(axis,angle);this.quaternion.multiply(q1);return this;};}(),rotateOnWorldAxis:function(){// rotate object on axis in world space
// axis is assumed to be normalized
// method assumes no rotated parent
var q1=new Quaternion();return function rotateOnWorldAxis(axis,angle){q1.setFromAxisAngle(axis,angle);this.quaternion.premultiply(q1);return this;};}(),rotateX:function(){var v1=new Vector3(1,0,0);return function rotateX(angle){return this.rotateOnAxis(v1,angle);};}(),rotateY:function(){var v1=new Vector3(0,1,0);return function rotateY(angle){return this.rotateOnAxis(v1,angle);};}(),rotateZ:function(){var v1=new Vector3(0,0,1);return function rotateZ(angle){return this.rotateOnAxis(v1,angle);};}(),translateOnAxis:function(){// translate object by distance along axis in object space
// axis is assumed to be normalized
var v1=new Vector3();return function translateOnAxis(axis,distance){v1.copy(axis).applyQuaternion(this.quaternion);this.position.add(v1.multiplyScalar(distance));return this;};}(),translateX:function(){var v1=new Vector3(1,0,0);return function translateX(distance){return this.translateOnAxis(v1,distance);};}(),translateY:function(){var v1=new Vector3(0,1,0);return function translateY(distance){return this.translateOnAxis(v1,distance);};}(),translateZ:function(){var v1=new Vector3(0,0,1);return function translateZ(distance){return this.translateOnAxis(v1,distance);};}(),localToWorld:function localToWorld(vector){return vector.applyMatrix4(this.matrixWorld);},worldToLocal:function(){var m1=new Matrix4();return function worldToLocal(vector){return vector.applyMatrix4(m1.getInverse(this.matrixWorld));};}(),lookAt:function(){// This method does not support objects with rotated and/or translated parent(s)
var m1=new Matrix4();var vector=new Vector3();return function lookAt(x,y,z){if(x.isVector3){vector.copy(x);}else{vector.set(x,y,z);}if(this.isCamera){m1.lookAt(this.position,vector,this.up);}else{m1.lookAt(vector,this.position,this.up);}this.quaternion.setFromRotationMatrix(m1);};}(),add:function add(object){//object.matrixAutoUpdate = false;
if(object&&object.parent==this){return this;}if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.add(arguments[i]);}return this;}if(object===this){console.error("THREE.Object3D.add: object can't be added as a child of itself.",object);return this;}if(object&&object.isObject3D){if(object.parent!==null){object.parent.remove(object);}object.parent=this;object.dispatchEvent({type:'added'});this.children.push(object);}else{console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",object);}return this;},remove:function remove(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.remove(arguments[i]);}return this;}var index=this.children.indexOf(object);if(index!==-1){object.parent=null;object.dispatchEvent({type:'removed'});this.children.splice(index,1);}return this;},getObjectById:function getObjectById(id){return this.getObjectByProperty('id',id);},getObjectByName:function getObjectByName(name){return this.getObjectByProperty('name',name);},getObjectByProperty:function getObjectByProperty(name,value){if(this[name]===value)return this;for(var i=0,l=this.children.length;i<l;i++){var child=this.children[i];var object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;},getWorldPosition:function getWorldPosition(optionalTarget){var result=optionalTarget||new Vector3();this.updateMatrixWorld(true);return result.setFromMatrixPosition(this.matrixWorld);},getWorldQuaternion:function(){var position=new Vector3();var scale=new Vector3();return function getWorldQuaternion(optionalTarget){var result=optionalTarget||new Quaternion();this.updateMatrixWorld(true);this.matrixWorld.decompose(position,result,scale);return result;};}(),getWorldRotation:function(){var quaternion=new Quaternion();return function getWorldRotation(optionalTarget){var result=optionalTarget||new Euler();this.getWorldQuaternion(quaternion);return result.setFromQuaternion(quaternion,this.rotation.order,false);};}(),getWorldScale:function(){var position=new Vector3();var quaternion=new Quaternion();return function getWorldScale(optionalTarget){var result=optionalTarget||new Vector3();this.updateMatrixWorld(true);this.matrixWorld.decompose(position,quaternion,result);return result;};}(),getWorldDirection:function(){var quaternion=new Quaternion();return function getWorldDirection(optionalTarget){var result=optionalTarget||new Vector3();this.getWorldQuaternion(quaternion);return result.set(0,0,1).applyQuaternion(quaternion);};}(),raycast:function raycast(){},traverse:function traverse(callback){callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverse(callback);}},traverseVisible:function traverseVisible(callback){if(this.visible===false)return;callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverseVisible(callback);}},traverseAncestors:function traverseAncestors(callback){var parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}},updateMatrix:function updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true;},updateMatrixWorld:function updateMatrixWorld(force){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||force){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else{this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldNeedsUpdate=false;force=true;}// update children
var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].updateMatrixWorld(force);}},toJSON:function toJSON(meta){// meta is a string when called from JSON.stringify
var isRootObject=meta===undefined||typeof meta==='string';var output={};// meta is a hash used to collect geometries, materials.
// not providing it implies that this is the root object
// being serialized.
if(isRootObject){// initialize meta obj
meta={geometries:{},materials:{},textures:{},images:{}};output.metadata={version:4.5,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
var object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;if(JSON.stringify(this.userData)!=='{}')object.userData=this.userData;object.matrix=this.matrix.toArray();//
function serialize(library,element){if(library[element.uuid]===undefined){library[element.uuid]=element.toJSON(meta);}return element.uuid;}if(this.geometry!==undefined){object.geometry=serialize(meta.geometries,this.geometry);}if(this.material!==undefined){if(Array.isArray(this.material)){var uuids=[];for(var i=0,l=this.material.length;i<l;i++){uuids.push(serialize(meta.materials,this.material[i]));}object.material=uuids;}else{object.material=serialize(meta.materials,this.material);}}//
if(this.children.length>0){object.children=[];for(var i=0;i<this.children.length;i++){object.children.push(this.children[i].toJSON(meta).object);}}if(isRootObject){var geometries=extractFromCache(meta.geometries);var materials=extractFromCache(meta.materials);var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;}output.object=object;return output;// extract data from the cache hash
// remove metadata on each item
// and return as array
function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}},clone:function clone(recursive){return new this.constructor().copy(this,recursive);},copy:function copy(source,recursive){if(recursive===undefined)recursive=true;this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.userData=JSON.parse(JSON.stringify(source.userData));if(recursive===true){for(var i=0;i<source.children.length;i++){var child=source.children[i];this.add(child.clone());}}return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/function Camera(){Object3D.call(this);this.type='Camera';this.matrixWorldInverse=new Matrix4();this.projectionMatrix=new Matrix4();}Camera.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Camera,isCamera:true,copy:function copy(source,recursive){Object3D.prototype.copy.call(this,source,recursive);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);return this;},getWorldDirection:function(){var quaternion=new Quaternion();return function getWorldDirection(optionalTarget){var result=optionalTarget||new Vector3();this.getWorldQuaternion(quaternion);return result.set(0,0,-1).applyQuaternion(quaternion);};}(),updateMatrixWorld:function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);this.matrixWorldInverse.getInverse(this.matrixWorld);},clone:function clone(){return new this.constructor().copy(this);}});/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */function OrthographicCamera(left,right,top,bottom,near,far){Camera.call(this);this.type='OrthographicCamera';this.zoom=1;this.view=null;this.left=left;this.right=right;this.top=top;this.bottom=bottom;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.updateProjectionMatrix();}OrthographicCamera.prototype=Object.assign(Object.create(Camera.prototype),{constructor:OrthographicCamera,isOrthographicCamera:true,copy:function copy(source,recursive){Camera.prototype.copy.call(this,source,recursive);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:Object.assign({},source.view);return this;},setViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();},clearViewOffset:function clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();},updateProjectionMatrix:function updateProjectionMatrix(){var dx=(this.right-this.left)/(2*this.zoom);var dy=(this.top-this.bottom)/(2*this.zoom);var cx=(this.right+this.left)/2;var cy=(this.top+this.bottom)/2;var left=cx-dx;var right=cx+dx;var top=cy+dy;var bottom=cy-dy;if(this.view!==null&&this.view.enabled){var zoomW=this.zoom/(this.view.width/this.view.fullWidth);var zoomH=this.zoom/(this.view.height/this.view.fullHeight);var scaleW=(this.right-this.left)/this.view.width;var scaleH=(this.top-this.bottom)/this.view.height;left+=scaleW*(this.view.offsetX/zoomW);right=left+scaleW*(this.view.width/zoomW);top-=scaleH*(this.view.offsetY/zoomH);bottom=top-scaleH*(this.view.height/zoomH);}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=Object.assign({},this.view);return data;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function Face3(a,b,c,normal,color,materialIndex){this.a=a;this.b=b;this.c=c;this.normal=normal&&normal.isVector3?normal:new Vector3();this.vertexNormals=Array.isArray(normal)?normal:[];this.color=color&&color.isColor?color:new Color();this.vertexColors=Array.isArray(color)?color:[];this.materialIndex=materialIndex!==undefined?materialIndex:0;}Object.assign(Face3.prototype,{clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.a=source.a;this.b=source.b;this.c=source.c;this.normal.copy(source.normal);this.color.copy(source.color);this.materialIndex=source.materialIndex;for(var i=0,il=source.vertexNormals.length;i<il;i++){this.vertexNormals[i]=source.vertexNormals[i].clone();}for(var i=0,il=source.vertexColors.length;i<il;i++){this.vertexColors[i]=source.vertexColors[i].clone();}return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */var geometryId=0;// Geometry uses even numbers as Id
function Geometry(){Object.defineProperty(this,'id',{value:geometryId+=2});this.uuid=_Math.generateUUID();this.name='';this.type='Geometry';this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingBox=null;this.boundingSphere=null;// update flags
this.elementsNeedUpdate=false;this.verticesNeedUpdate=false;this.uvsNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.lineDistancesNeedUpdate=false;this.groupsNeedUpdate=false;}Object.assign(Geometry.prototype,EventDispatcher.prototype,{isGeometry:true,applyMatrix:function applyMatrix(matrix){var normalMatrix=new Matrix3().getNormalMatrix(matrix);for(var i=0,il=this.vertices.length;i<il;i++){var vertex=this.vertices[i];vertex.applyMatrix4(matrix);}for(var i=0,il=this.faces.length;i<il;i++){var face=this.faces[i];face.normal.applyMatrix3(normalMatrix).normalize();for(var j=0,jl=face.vertexNormals.length;j<jl;j++){face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();}}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}this.verticesNeedUpdate=true;this.normalsNeedUpdate=true;return this;},rotateX:function(){// rotate geometry around world x-axis
var m1=new Matrix4();return function rotateX(angle){m1.makeRotationX(angle);this.applyMatrix(m1);return this;};}(),rotateY:function(){// rotate geometry around world y-axis
var m1=new Matrix4();return function rotateY(angle){m1.makeRotationY(angle);this.applyMatrix(m1);return this;};}(),rotateZ:function(){// rotate geometry around world z-axis
var m1=new Matrix4();return function rotateZ(angle){m1.makeRotationZ(angle);this.applyMatrix(m1);return this;};}(),translate:function(){// translate geometry
var m1=new Matrix4();return function translate(x,y,z){m1.makeTranslation(x,y,z);this.applyMatrix(m1);return this;};}(),scale:function(){// scale geometry
var m1=new Matrix4();return function scale(x,y,z){m1.makeScale(x,y,z);this.applyMatrix(m1);return this;};}(),lookAt:function(){var obj=new Object3D();return function lookAt(vector){obj.lookAt(vector);obj.updateMatrix();this.applyMatrix(obj.matrix);};}(),fromBufferGeometry:function fromBufferGeometry(geometry){var scope=this;var indices=geometry.index!==null?geometry.index.array:undefined;var attributes=geometry.attributes;var positions=attributes.position.array;var normals=attributes.normal!==undefined?attributes.normal.array:undefined;var colors=attributes.color!==undefined?attributes.color.array:undefined;var uvs=attributes.uv!==undefined?attributes.uv.array:undefined;var uvs2=attributes.uv2!==undefined?attributes.uv2.array:undefined;if(uvs2!==undefined)this.faceVertexUvs[1]=[];var tempNormals=[];var tempUVs=[];var tempUVs2=[];for(var i=0,j=0;i<positions.length;i+=3,j+=2){scope.vertices.push(new Vector3(positions[i],positions[i+1],positions[i+2]));if(normals!==undefined){tempNormals.push(new Vector3(normals[i],normals[i+1],normals[i+2]));}if(colors!==undefined){scope.colors.push(new Color(colors[i],colors[i+1],colors[i+2]));}if(uvs!==undefined){tempUVs.push(new Vector2(uvs[j],uvs[j+1]));}if(uvs2!==undefined){tempUVs2.push(new Vector2(uvs2[j],uvs2[j+1]));}}function addFace(a,b,c,materialIndex){var vertexNormals=normals!==undefined?[tempNormals[a].clone(),tempNormals[b].clone(),tempNormals[c].clone()]:[];var vertexColors=colors!==undefined?[scope.colors[a].clone(),scope.colors[b].clone(),scope.colors[c].clone()]:[];var face=new Face3(a,b,c,vertexNormals,vertexColors,materialIndex);scope.faces.push(face);if(uvs!==undefined){scope.faceVertexUvs[0].push([tempUVs[a].clone(),tempUVs[b].clone(),tempUVs[c].clone()]);}if(uvs2!==undefined){scope.faceVertexUvs[1].push([tempUVs2[a].clone(),tempUVs2[b].clone(),tempUVs2[c].clone()]);}}var groups=geometry.groups;if(groups.length>0){for(var i=0;i<groups.length;i++){var group=groups[i];var start=group.start;var count=group.count;for(var j=start,jl=start+count;j<jl;j+=3){if(indices!==undefined){addFace(indices[j],indices[j+1],indices[j+2],group.materialIndex);}else{addFace(j,j+1,j+2,group.materialIndex);}}}}else{if(indices!==undefined){for(var i=0;i<indices.length;i+=3){addFace(indices[i],indices[i+1],indices[i+2]);}}else{for(var i=0;i<positions.length/3;i+=3){addFace(i,i+1,i+2);}}}this.computeFaceNormals();if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}return this;},center:function center(){this.computeBoundingBox();var offset=this.boundingBox.getCenter().negate();this.translate(offset.x,offset.y,offset.z);return offset;},normalize:function normalize(){this.computeBoundingSphere();var center=this.boundingSphere.center;var radius=this.boundingSphere.radius;var s=radius===0?1:1.0/radius;var matrix=new Matrix4();matrix.set(s,0,0,-s*center.x,0,s,0,-s*center.y,0,0,s,-s*center.z,0,0,0,1);this.applyMatrix(matrix);return this;},computeFaceNormals:function computeFaceNormals(){var cb=new Vector3(),ab=new Vector3();for(var f=0,fl=this.faces.length;f<fl;f++){var face=this.faces[f];var vA=this.vertices[face.a];var vB=this.vertices[face.b];var vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);cb.normalize();face.normal.copy(cb);}},computeVertexNormals:function computeVertexNormals(areaWeighted){if(areaWeighted===undefined)areaWeighted=true;var v,vl,f,fl,face,vertices;vertices=new Array(this.vertices.length);for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v]=new Vector3();}if(areaWeighted){// vertex normals weighted by triangle areas
// http://www.iquilezles.org/www/articles/normals/normals.htm
var vA,vB,vC;var cb=new Vector3(),ab=new Vector3();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vA=this.vertices[face.a];vB=this.vertices[face.b];vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);vertices[face.a].add(cb);vertices[face.b].add(cb);vertices[face.c].add(cb);}}else{this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vertices[face.a].add(face.normal);vertices[face.b].add(face.normal);vertices[face.c].add(face.normal);}}for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v].normalize();}for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(vertices[face.a]);vertexNormals[1].copy(vertices[face.b]);vertexNormals[2].copy(vertices[face.c]);}else{vertexNormals[0]=vertices[face.a].clone();vertexNormals[1]=vertices[face.b].clone();vertexNormals[2]=vertices[face.c].clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeFlatVertexNormals:function computeFlatVertexNormals(){var f,fl,face;this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(face.normal);vertexNormals[1].copy(face.normal);vertexNormals[2].copy(face.normal);}else{vertexNormals[0]=face.normal.clone();vertexNormals[1]=face.normal.clone();vertexNormals[2]=face.normal.clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeMorphNormals:function computeMorphNormals(){var i,il,f,fl,face;// save original normals
// - create temp variables on first access
//   otherwise just copy (for faster repeated calls)
for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];if(!face.__originalFaceNormal){face.__originalFaceNormal=face.normal.clone();}else{face.__originalFaceNormal.copy(face.normal);}if(!face.__originalVertexNormals)face.__originalVertexNormals=[];for(i=0,il=face.vertexNormals.length;i<il;i++){if(!face.__originalVertexNormals[i]){face.__originalVertexNormals[i]=face.vertexNormals[i].clone();}else{face.__originalVertexNormals[i].copy(face.vertexNormals[i]);}}}// use temp geometry to compute face and vertex normals for each morph
var tmpGeo=new Geometry();tmpGeo.faces=this.faces;for(i=0,il=this.morphTargets.length;i<il;i++){// create on first access
if(!this.morphNormals[i]){this.morphNormals[i]={};this.morphNormals[i].faceNormals=[];this.morphNormals[i].vertexNormals=[];var dstNormalsFace=this.morphNormals[i].faceNormals;var dstNormalsVertex=this.morphNormals[i].vertexNormals;var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){faceNormal=new Vector3();vertexNormals={a:new Vector3(),b:new Vector3(),c:new Vector3()};dstNormalsFace.push(faceNormal);dstNormalsVertex.push(vertexNormals);}}var morphNormals=this.morphNormals[i];// set vertices to morph target
tmpGeo.vertices=this.morphTargets[i].vertices;// compute morph normals
tmpGeo.computeFaceNormals();tmpGeo.computeVertexNormals();// store morph normals
var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];faceNormal=morphNormals.faceNormals[f];vertexNormals=morphNormals.vertexNormals[f];faceNormal.copy(face.normal);vertexNormals.a.copy(face.vertexNormals[0]);vertexNormals.b.copy(face.vertexNormals[1]);vertexNormals.c.copy(face.vertexNormals[2]);}}// restore original normals
for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];face.normal=face.__originalFaceNormal;face.vertexNormals=face.__originalVertexNormals;}},computeLineDistances:function computeLineDistances(){var d=0;var vertices=this.vertices;for(var i=0,il=vertices.length;i<il;i++){if(i>0){d+=vertices[i].distanceTo(vertices[i-1]);}this.lineDistances[i]=d;}},computeBoundingBox:function computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}this.boundingBox.setFromPoints(this.vertices);},computeBoundingSphere:function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}this.boundingSphere.setFromPoints(this.vertices);},merge:function merge(geometry,matrix,materialIndexOffset){if(!(geometry&&geometry.isGeometry)){console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',geometry);return;}var normalMatrix,vertexOffset=this.vertices.length,vertices1=this.vertices,vertices2=geometry.vertices,faces1=this.faces,faces2=geometry.faces,uvs1=this.faceVertexUvs[0],uvs2=geometry.faceVertexUvs[0],colors1=this.colors,colors2=geometry.colors;if(materialIndexOffset===undefined)materialIndexOffset=0;if(matrix!==undefined){normalMatrix=new Matrix3().getNormalMatrix(matrix);}// vertices
for(var i=0,il=vertices2.length;i<il;i++){var vertex=vertices2[i];var vertexCopy=vertex.clone();if(matrix!==undefined)vertexCopy.applyMatrix4(matrix);vertices1.push(vertexCopy);}// colors
for(var i=0,il=colors2.length;i<il;i++){colors1.push(colors2[i].clone());}// faces
for(i=0,il=faces2.length;i<il;i++){var face=faces2[i],faceCopy,normal,color,faceVertexNormals=face.vertexNormals,faceVertexColors=face.vertexColors;faceCopy=new Face3(face.a+vertexOffset,face.b+vertexOffset,face.c+vertexOffset);faceCopy.normal.copy(face.normal);if(normalMatrix!==undefined){faceCopy.normal.applyMatrix3(normalMatrix).normalize();}for(var j=0,jl=faceVertexNormals.length;j<jl;j++){normal=faceVertexNormals[j].clone();if(normalMatrix!==undefined){normal.applyMatrix3(normalMatrix).normalize();}faceCopy.vertexNormals.push(normal);}faceCopy.color.copy(face.color);for(var j=0,jl=faceVertexColors.length;j<jl;j++){color=faceVertexColors[j];faceCopy.vertexColors.push(color.clone());}faceCopy.materialIndex=face.materialIndex+materialIndexOffset;faces1.push(faceCopy);}// uvs
for(i=0,il=uvs2.length;i<il;i++){var uv=uvs2[i],uvCopy=[];if(uv===undefined){continue;}for(var j=0,jl=uv.length;j<jl;j++){uvCopy.push(uv[j].clone());}uvs1.push(uvCopy);}},mergeMesh:function mergeMesh(mesh){if(!(mesh&&mesh.isMesh)){console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',mesh);return;}mesh.matrixAutoUpdate&&mesh.updateMatrix();this.merge(mesh.geometry,mesh.matrix);},/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */mergeVertices:function mergeVertices(){var verticesMap={};// Hashmap for looking up vertices by position coordinates (and making sure they are unique)
var unique=[],changes=[];var v,key;var precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001
var precision=Math.pow(10,precisionPoints);var i,il,face;var indices,j,jl;for(i=0,il=this.vertices.length;i<il;i++){v=this.vertices[i];key=Math.round(v.x*precision)+'_'+Math.round(v.y*precision)+'_'+Math.round(v.z*precision);if(verticesMap[key]===undefined){verticesMap[key]=i;unique.push(this.vertices[i]);changes[i]=unique.length-1;}else{//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
changes[i]=changes[verticesMap[key]];}}// if faces are completely degenerate after merging vertices, we
// have to remove them from the geometry.
var faceIndicesToRemove=[];for(i=0,il=this.faces.length;i<il;i++){face=this.faces[i];face.a=changes[face.a];face.b=changes[face.b];face.c=changes[face.c];indices=[face.a,face.b,face.c];// if any duplicate vertices are found in a Face3
// we have to remove the face as nothing can be saved
for(var n=0;n<3;n++){if(indices[n]===indices[(n+1)%3]){faceIndicesToRemove.push(i);break;}}}for(i=faceIndicesToRemove.length-1;i>=0;i--){var idx=faceIndicesToRemove[i];this.faces.splice(idx,1);for(j=0,jl=this.faceVertexUvs.length;j<jl;j++){this.faceVertexUvs[j].splice(idx,1);}}// Use unique set of vertices
var diff=this.vertices.length-unique.length;this.vertices=unique;return diff;},setFromPoints:function setFromPoints(points){this.vertices=[];for(var i=0,l=points.length;i<l;i++){var point=points[i];this.vertices.push(new Vector3(point.x,point.y,point.z||0));}return this;},sortFacesByMaterialIndex:function sortFacesByMaterialIndex(){var faces=this.faces;var length=faces.length;// tag faces
for(var i=0;i<length;i++){faces[i]._id=i;}// sort faces
function materialIndexSort(a,b){return a.materialIndex-b.materialIndex;}faces.sort(materialIndexSort);// sort uvs
var uvs1=this.faceVertexUvs[0];var uvs2=this.faceVertexUvs[1];var newUvs1,newUvs2;if(uvs1&&uvs1.length===length)newUvs1=[];if(uvs2&&uvs2.length===length)newUvs2=[];for(var i=0;i<length;i++){var id=faces[i]._id;if(newUvs1)newUvs1.push(uvs1[id]);if(newUvs2)newUvs2.push(uvs2[id]);}if(newUvs1)this.faceVertexUvs[0]=newUvs1;if(newUvs2)this.faceVertexUvs[1]=newUvs2;},toJSON:function toJSON(){var data={metadata:{version:4.5,type:'Geometry',generator:'Geometry.toJSON'}};// standard Geometry serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}var vertices=[];for(var i=0;i<this.vertices.length;i++){var vertex=this.vertices[i];vertices.push(vertex.x,vertex.y,vertex.z);}var faces=[];var normals=[];var normalsHash={};var colors=[];var colorsHash={};var uvs=[];var uvsHash={};for(var i=0;i<this.faces.length;i++){var face=this.faces[i];var hasMaterial=true;var hasFaceUv=false;// deprecated
var hasFaceVertexUv=this.faceVertexUvs[0][i]!==undefined;var hasFaceNormal=face.normal.length()>0;var hasFaceVertexNormal=face.vertexNormals.length>0;var hasFaceColor=face.color.r!==1||face.color.g!==1||face.color.b!==1;var hasFaceVertexColor=face.vertexColors.length>0;var faceType=0;faceType=setBit(faceType,0,0);// isQuad
faceType=setBit(faceType,1,hasMaterial);faceType=setBit(faceType,2,hasFaceUv);faceType=setBit(faceType,3,hasFaceVertexUv);faceType=setBit(faceType,4,hasFaceNormal);faceType=setBit(faceType,5,hasFaceVertexNormal);faceType=setBit(faceType,6,hasFaceColor);faceType=setBit(faceType,7,hasFaceVertexColor);faces.push(faceType);faces.push(face.a,face.b,face.c);faces.push(face.materialIndex);if(hasFaceVertexUv){var faceVertexUvs=this.faceVertexUvs[0][i];faces.push(getUvIndex(faceVertexUvs[0]),getUvIndex(faceVertexUvs[1]),getUvIndex(faceVertexUvs[2]));}if(hasFaceNormal){faces.push(getNormalIndex(face.normal));}if(hasFaceVertexNormal){var vertexNormals=face.vertexNormals;faces.push(getNormalIndex(vertexNormals[0]),getNormalIndex(vertexNormals[1]),getNormalIndex(vertexNormals[2]));}if(hasFaceColor){faces.push(getColorIndex(face.color));}if(hasFaceVertexColor){var vertexColors=face.vertexColors;faces.push(getColorIndex(vertexColors[0]),getColorIndex(vertexColors[1]),getColorIndex(vertexColors[2]));}}function setBit(value,position,enabled){return enabled?value|1<<position:value&~(1<<position);}function getNormalIndex(normal){var hash=normal.x.toString()+normal.y.toString()+normal.z.toString();if(normalsHash[hash]!==undefined){return normalsHash[hash];}normalsHash[hash]=normals.length/3;normals.push(normal.x,normal.y,normal.z);return normalsHash[hash];}function getColorIndex(color){var hash=color.r.toString()+color.g.toString()+color.b.toString();if(colorsHash[hash]!==undefined){return colorsHash[hash];}colorsHash[hash]=colors.length;colors.push(color.getHex());return colorsHash[hash];}function getUvIndex(uv){var hash=uv.x.toString()+uv.y.toString();if(uvsHash[hash]!==undefined){return uvsHash[hash];}uvsHash[hash]=uvs.length/2;uvs.push(uv.x,uv.y);return uvsHash[hash];}data.data={};data.data.vertices=vertices;data.data.normals=normals;if(colors.length>0)data.data.colors=colors;if(uvs.length>0)data.data.uvs=[uvs];// temporal backward compatibility
data.data.faces=faces;return data;},clone:function clone(){/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */return new Geometry().copy(this);},copy:function copy(source){var i,il,j,jl,k,kl;// reset
this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingBox=null;this.boundingSphere=null;// name
this.name=source.name;// vertices
var vertices=source.vertices;for(i=0,il=vertices.length;i<il;i++){this.vertices.push(vertices[i].clone());}// colors
var colors=source.colors;for(i=0,il=colors.length;i<il;i++){this.colors.push(colors[i].clone());}// faces
var faces=source.faces;for(i=0,il=faces.length;i<il;i++){this.faces.push(faces[i].clone());}// face vertex uvs
for(i=0,il=source.faceVertexUvs.length;i<il;i++){var faceVertexUvs=source.faceVertexUvs[i];if(this.faceVertexUvs[i]===undefined){this.faceVertexUvs[i]=[];}for(j=0,jl=faceVertexUvs.length;j<jl;j++){var uvs=faceVertexUvs[j],uvsCopy=[];for(k=0,kl=uvs.length;k<kl;k++){var uv=uvs[k];uvsCopy.push(uv.clone());}this.faceVertexUvs[i].push(uvsCopy);}}// morph targets
var morphTargets=source.morphTargets;for(i=0,il=morphTargets.length;i<il;i++){var morphTarget={};morphTarget.name=morphTargets[i].name;// vertices
if(morphTargets[i].vertices!==undefined){morphTarget.vertices=[];for(j=0,jl=morphTargets[i].vertices.length;j<jl;j++){morphTarget.vertices.push(morphTargets[i].vertices[j].clone());}}// normals
if(morphTargets[i].normals!==undefined){morphTarget.normals=[];for(j=0,jl=morphTargets[i].normals.length;j<jl;j++){morphTarget.normals.push(morphTargets[i].normals[j].clone());}}this.morphTargets.push(morphTarget);}// morph normals
var morphNormals=source.morphNormals;for(i=0,il=morphNormals.length;i<il;i++){var morphNormal={};// vertex normals
if(morphNormals[i].vertexNormals!==undefined){morphNormal.vertexNormals=[];for(j=0,jl=morphNormals[i].vertexNormals.length;j<jl;j++){var srcVertexNormal=morphNormals[i].vertexNormals[j];var destVertexNormal={};destVertexNormal.a=srcVertexNormal.a.clone();destVertexNormal.b=srcVertexNormal.b.clone();destVertexNormal.c=srcVertexNormal.c.clone();morphNormal.vertexNormals.push(destVertexNormal);}}// face normals
if(morphNormals[i].faceNormals!==undefined){morphNormal.faceNormals=[];for(j=0,jl=morphNormals[i].faceNormals.length;j<jl;j++){morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());}}this.morphNormals.push(morphNormal);}// skin weights
var skinWeights=source.skinWeights;for(i=0,il=skinWeights.length;i<il;i++){this.skinWeights.push(skinWeights[i].clone());}// skin indices
var skinIndices=source.skinIndices;for(i=0,il=skinIndices.length;i<il;i++){this.skinIndices.push(skinIndices[i].clone());}// line distances
var lineDistances=source.lineDistances;for(i=0,il=lineDistances.length;i<il;i++){this.lineDistances.push(lineDistances[i]);}// bounding box
var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// update flags
this.elementsNeedUpdate=source.elementsNeedUpdate;this.verticesNeedUpdate=source.verticesNeedUpdate;this.uvsNeedUpdate=source.uvsNeedUpdate;this.normalsNeedUpdate=source.normalsNeedUpdate;this.colorsNeedUpdate=source.colorsNeedUpdate;this.lineDistancesNeedUpdate=source.lineDistancesNeedUpdate;this.groupsNeedUpdate=source.groupsNeedUpdate;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function BufferAttribute(array,itemSize,normalized){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.uuid=_Math.generateUUID();this.name='';this.array=array;this.itemSize=itemSize;this.count=array!==undefined?array.length/itemSize:0;this.normalized=normalized===true;this.dynamic=false;this.updateRange={offset:0,count:-1};this.onUploadCallback=function(){};this.version=0;}Object.defineProperty(BufferAttribute.prototype,'needsUpdate',{set:function set(value){if(value===true)this.version++;}});Object.assign(BufferAttribute.prototype,{isBufferAttribute:true,setArray:function setArray(array){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.count=array!==undefined?array.length/this.itemSize:0;this.array=array;},setDynamic:function setDynamic(value){this.dynamic=value;return this;},copy:function copy(source){this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.dynamic=source.dynamic;return this;},copyAt:function copyAt(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(var i=0,l=this.itemSize;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;},copyArray:function copyArray(array){this.array.set(array);return this;},copyColorsArray:function copyColorsArray(colors){var array=this.array,offset=0;for(var i=0,l=colors.length;i<l;i++){var color=colors[i];if(color===undefined){console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',i);color=new Color();}array[offset++]=color.r;array[offset++]=color.g;array[offset++]=color.b;}return this;},copyIndicesArray:function copyIndicesArray(indices){var array=this.array,offset=0;for(var i=0,l=indices.length;i<l;i++){var index=indices[i];array[offset++]=index.a;array[offset++]=index.b;array[offset++]=index.c;}return this;},copyVector2sArray:function copyVector2sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',i);vector=new Vector2();}array[offset++]=vector.x;array[offset++]=vector.y;}return this;},copyVector3sArray:function copyVector3sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',i);vector=new Vector3();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;}return this;},copyVector4sArray:function copyVector4sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',i);vector=new Vector4();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;array[offset++]=vector.w;}return this;},set:function set(value,offset){if(offset===undefined)offset=0;this.array.set(value,offset);return this;},getX:function getX(index){return this.array[index*this.itemSize];},setX:function setX(index,x){this.array[index*this.itemSize]=x;return this;},getY:function getY(index){return this.array[index*this.itemSize+1];},setY:function setY(index,y){this.array[index*this.itemSize+1]=y;return this;},getZ:function getZ(index){return this.array[index*this.itemSize+2];},setZ:function setZ(index,z){this.array[index*this.itemSize+2]=z;return this;},getW:function getW(index){return this.array[index*this.itemSize+3];},setW:function setW(index,w){this.array[index*this.itemSize+3]=w;return this;},setXY:function setXY(index,x,y){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;return this;},setXYZ:function setXYZ(index,x,y,z){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;},setXYZW:function setXYZW(index,x,y,z,w){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;},onUpload:function onUpload(callback){this.onUploadCallback=callback;return this;},clone:function clone(){return new this.constructor(this.array,this.itemSize).copy(this);}});//
function Int8BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Int8Array(array),itemSize,normalized);}Int8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int8BufferAttribute.prototype.constructor=Int8BufferAttribute;function Uint8BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint8Array(array),itemSize,normalized);}Uint8BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint8BufferAttribute.prototype.constructor=Uint8BufferAttribute;function Uint8ClampedBufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint8ClampedArray(array),itemSize,normalized);}Uint8ClampedBufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint8ClampedBufferAttribute.prototype.constructor=Uint8ClampedBufferAttribute;function Int16BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Int16Array(array),itemSize,normalized);}Int16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int16BufferAttribute.prototype.constructor=Int16BufferAttribute;function Uint16BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint16Array(array),itemSize,normalized);}Uint16BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint16BufferAttribute.prototype.constructor=Uint16BufferAttribute;function Int32BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Int32Array(array),itemSize,normalized);}Int32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Int32BufferAttribute.prototype.constructor=Int32BufferAttribute;function Uint32BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint32Array(array),itemSize,normalized);}Uint32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Uint32BufferAttribute.prototype.constructor=Uint32BufferAttribute;function Float32BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Float32Array(array),itemSize,normalized);}Float32BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Float32BufferAttribute.prototype.constructor=Float32BufferAttribute;function Float64BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Float64Array(array),itemSize,normalized);}Float64BufferAttribute.prototype=Object.create(BufferAttribute.prototype);Float64BufferAttribute.prototype.constructor=Float64BufferAttribute;/**
	 * @author mrdoob / http://mrdoob.com/
	 */function DirectGeometry(){this.indices=[];this.vertices=[];this.normals=[];this.colors=[];this.uvs=[];this.uvs2=[];this.groups=[];this.morphTargets={};this.skinWeights=[];this.skinIndices=[];// this.lineDistances = [];
this.boundingBox=null;this.boundingSphere=null;// update flags
this.verticesNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.uvsNeedUpdate=false;this.groupsNeedUpdate=false;}Object.assign(DirectGeometry.prototype,{computeGroups:function computeGroups(geometry){var group;var groups=[];var materialIndex=undefined;var faces=geometry.faces;for(var i=0;i<faces.length;i++){var face=faces[i];// materials
if(face.materialIndex!==materialIndex){materialIndex=face.materialIndex;if(group!==undefined){group.count=i*3-group.start;groups.push(group);}group={start:i*3,materialIndex:materialIndex};}}if(group!==undefined){group.count=i*3-group.start;groups.push(group);}this.groups=groups;},fromGeometry:function fromGeometry(geometry){var faces=geometry.faces;var vertices=geometry.vertices;var faceVertexUvs=geometry.faceVertexUvs;var hasFaceVertexUv=faceVertexUvs[0]&&faceVertexUvs[0].length>0;var hasFaceVertexUv2=faceVertexUvs[1]&&faceVertexUvs[1].length>0;// morphs
var morphTargets=geometry.morphTargets;var morphTargetsLength=morphTargets.length;var morphTargetsPosition;if(morphTargetsLength>0){morphTargetsPosition=[];for(var i=0;i<morphTargetsLength;i++){morphTargetsPosition[i]=[];}this.morphTargets.position=morphTargetsPosition;}var morphNormals=geometry.morphNormals;var morphNormalsLength=morphNormals.length;var morphTargetsNormal;if(morphNormalsLength>0){morphTargetsNormal=[];for(var i=0;i<morphNormalsLength;i++){morphTargetsNormal[i]=[];}this.morphTargets.normal=morphTargetsNormal;}// skins
var skinIndices=geometry.skinIndices;var skinWeights=geometry.skinWeights;var hasSkinIndices=skinIndices.length===vertices.length;var hasSkinWeights=skinWeights.length===vertices.length;//
for(var i=0;i<faces.length;i++){var face=faces[i];this.vertices.push(vertices[face.a],vertices[face.b],vertices[face.c]);var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){this.normals.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]);}else{var normal=face.normal;this.normals.push(normal,normal,normal);}var vertexColors=face.vertexColors;if(vertexColors.length===3){this.colors.push(vertexColors[0],vertexColors[1],vertexColors[2]);}else{var color=face.color;this.colors.push(color,color,color);}if(hasFaceVertexUv===true){var vertexUvs=faceVertexUvs[0][i];if(vertexUvs!==undefined){this.uvs.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',i);this.uvs.push(new Vector2(),new Vector2(),new Vector2());}}if(hasFaceVertexUv2===true){var vertexUvs=faceVertexUvs[1][i];if(vertexUvs!==undefined){this.uvs2.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',i);this.uvs2.push(new Vector2(),new Vector2(),new Vector2());}}// morphs
for(var j=0;j<morphTargetsLength;j++){var morphTarget=morphTargets[j].vertices;morphTargetsPosition[j].push(morphTarget[face.a],morphTarget[face.b],morphTarget[face.c]);}for(var j=0;j<morphNormalsLength;j++){var morphNormal=morphNormals[j].vertexNormals[i];morphTargetsNormal[j].push(morphNormal.a,morphNormal.b,morphNormal.c);}// skins
if(hasSkinIndices){this.skinIndices.push(skinIndices[face.a],skinIndices[face.b],skinIndices[face.c]);}if(hasSkinWeights){this.skinWeights.push(skinWeights[face.a],skinWeights[face.b],skinWeights[face.c]);}}this.computeGroups(geometry);this.verticesNeedUpdate=geometry.verticesNeedUpdate;this.normalsNeedUpdate=geometry.normalsNeedUpdate;this.colorsNeedUpdate=geometry.colorsNeedUpdate;this.uvsNeedUpdate=geometry.uvsNeedUpdate;this.groupsNeedUpdate=geometry.groupsNeedUpdate;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function arrayMax(array){if(array.length===0)return-Infinity;var max=array[0];for(var i=1,l=array.length;i<l;++i){if(array[i]>max)max=array[i];}return max;}/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */var bufferGeometryId=1;// BufferGeometry uses odd numbers as Id
function BufferGeometry(){Object.defineProperty(this,'id',{value:bufferGeometryId+=2});this.uuid=_Math.generateUUID();this.name='';this.type='BufferGeometry';this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;this.drawRange={start:0,count:Infinity};}Object.assign(BufferGeometry.prototype,EventDispatcher.prototype,{isBufferGeometry:true,getIndex:function getIndex(){return this.index;},setIndex:function setIndex(index){if(Array.isArray(index)){this.index=new(arrayMax(index)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(index,1);}else{this.index=index;}},addAttribute:function addAttribute(name,attribute){if(!(attribute&&attribute.isBufferAttribute)&&!(attribute&&attribute.isInterleavedBufferAttribute)){console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');this.addAttribute(name,new BufferAttribute(arguments[1],arguments[2]));return;}if(name==='index'){console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');this.setIndex(attribute);return;}this.attributes[name]=attribute;return this;},getAttribute:function getAttribute(name){return this.attributes[name];},removeAttribute:function removeAttribute(name){delete this.attributes[name];return this;},addGroup:function addGroup(start,count,materialIndex){this.groups.push({start:start,count:count,materialIndex:materialIndex!==undefined?materialIndex:0});},clearGroups:function clearGroups(){this.groups=[];},setDrawRange:function setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count;},applyMatrix:function applyMatrix(matrix){var position=this.attributes.position;if(position!==undefined){matrix.applyToBufferAttribute(position);position.needsUpdate=true;}var normal=this.attributes.normal;if(normal!==undefined){var normalMatrix=new Matrix3().getNormalMatrix(matrix);normalMatrix.applyToBufferAttribute(normal);normal.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;},rotateX:function(){// rotate geometry around world x-axis
var m1=new Matrix4();return function rotateX(angle){m1.makeRotationX(angle);this.applyMatrix(m1);return this;};}(),rotateY:function(){// rotate geometry around world y-axis
var m1=new Matrix4();return function rotateY(angle){m1.makeRotationY(angle);this.applyMatrix(m1);return this;};}(),rotateZ:function(){// rotate geometry around world z-axis
var m1=new Matrix4();return function rotateZ(angle){m1.makeRotationZ(angle);this.applyMatrix(m1);return this;};}(),translate:function(){// translate geometry
var m1=new Matrix4();return function translate(x,y,z){m1.makeTranslation(x,y,z);this.applyMatrix(m1);return this;};}(),scale:function(){// scale geometry
var m1=new Matrix4();return function scale(x,y,z){m1.makeScale(x,y,z);this.applyMatrix(m1);return this;};}(),lookAt:function(){var obj=new Object3D();return function lookAt(vector){obj.lookAt(vector);obj.updateMatrix();this.applyMatrix(obj.matrix);};}(),center:function center(){this.computeBoundingBox();var offset=this.boundingBox.getCenter().negate();this.translate(offset.x,offset.y,offset.z);return offset;},setFromObject:function setFromObject(object){// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
var geometry=object.geometry;if(object.isPoints||object.isLine){var positions=new Float32BufferAttribute(geometry.vertices.length*3,3);var colors=new Float32BufferAttribute(geometry.colors.length*3,3);this.addAttribute('position',positions.copyVector3sArray(geometry.vertices));this.addAttribute('color',colors.copyColorsArray(geometry.colors));if(geometry.lineDistances&&geometry.lineDistances.length===geometry.vertices.length){var lineDistances=new Float32BufferAttribute(geometry.lineDistances.length,1);this.addAttribute('lineDistance',lineDistances.copyArray(geometry.lineDistances));}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}}else if(object.isMesh){if(geometry&&geometry.isGeometry){this.fromGeometry(geometry);}}return this;},setFromPoints:function setFromPoints(points){var position=[];for(var i=0,l=points.length;i<l;i++){var point=points[i];position.push(point.x,point.y,point.z||0);}this.addAttribute('position',new Float32BufferAttribute(position,3));return this;},updateFromObject:function updateFromObject(object){var geometry=object.geometry;if(object.isMesh){var direct=geometry.__directGeometry;if(geometry.elementsNeedUpdate===true){direct=undefined;geometry.elementsNeedUpdate=false;}if(direct===undefined){return this.fromGeometry(geometry);}direct.verticesNeedUpdate=geometry.verticesNeedUpdate;direct.normalsNeedUpdate=geometry.normalsNeedUpdate;direct.colorsNeedUpdate=geometry.colorsNeedUpdate;direct.uvsNeedUpdate=geometry.uvsNeedUpdate;direct.groupsNeedUpdate=geometry.groupsNeedUpdate;geometry.verticesNeedUpdate=false;geometry.normalsNeedUpdate=false;geometry.colorsNeedUpdate=false;geometry.uvsNeedUpdate=false;geometry.groupsNeedUpdate=false;geometry=direct;}var attribute;if(geometry.verticesNeedUpdate===true){attribute=this.attributes.position;if(attribute!==undefined){attribute.copyVector3sArray(geometry.vertices);attribute.needsUpdate=true;}geometry.verticesNeedUpdate=false;}if(geometry.normalsNeedUpdate===true){attribute=this.attributes.normal;if(attribute!==undefined){attribute.copyVector3sArray(geometry.normals);attribute.needsUpdate=true;}geometry.normalsNeedUpdate=false;}if(geometry.colorsNeedUpdate===true){attribute=this.attributes.color;if(attribute!==undefined){attribute.copyColorsArray(geometry.colors);attribute.needsUpdate=true;}geometry.colorsNeedUpdate=false;}if(geometry.uvsNeedUpdate){attribute=this.attributes.uv;if(attribute!==undefined){attribute.copyVector2sArray(geometry.uvs);attribute.needsUpdate=true;}geometry.uvsNeedUpdate=false;}if(geometry.lineDistancesNeedUpdate){attribute=this.attributes.lineDistance;if(attribute!==undefined){attribute.copyArray(geometry.lineDistances);attribute.needsUpdate=true;}geometry.lineDistancesNeedUpdate=false;}if(geometry.groupsNeedUpdate){geometry.computeGroups(object.geometry);this.groups=geometry.groups;geometry.groupsNeedUpdate=false;}return this;},fromGeometry:function fromGeometry(geometry){geometry.__directGeometry=new DirectGeometry().fromGeometry(geometry);return this.fromDirectGeometry(geometry.__directGeometry);},fromDirectGeometry:function fromDirectGeometry(geometry){var positions=new Float32Array(geometry.vertices.length*3);this.addAttribute('position',new BufferAttribute(positions,3).copyVector3sArray(geometry.vertices));if(geometry.normals.length>0){var normals=new Float32Array(geometry.normals.length*3);this.addAttribute('normal',new BufferAttribute(normals,3).copyVector3sArray(geometry.normals));}if(geometry.colors.length>0){var colors=new Float32Array(geometry.colors.length*3);this.addAttribute('color',new BufferAttribute(colors,3).copyColorsArray(geometry.colors));}if(geometry.uvs.length>0){var uvs=new Float32Array(geometry.uvs.length*2);this.addAttribute('uv',new BufferAttribute(uvs,2).copyVector2sArray(geometry.uvs));}if(geometry.uvs2.length>0){var uvs2=new Float32Array(geometry.uvs2.length*2);this.addAttribute('uv2',new BufferAttribute(uvs2,2).copyVector2sArray(geometry.uvs2));}if(geometry.indices.length>0){var TypeArray=arrayMax(geometry.indices)>65535?Uint32Array:Uint16Array;var indices=new TypeArray(geometry.indices.length*3);this.setIndex(new BufferAttribute(indices,1).copyIndicesArray(geometry.indices));}// groups
this.groups=geometry.groups;// morphs
for(var name in geometry.morphTargets){var array=[];var morphTargets=geometry.morphTargets[name];for(var i=0,l=morphTargets.length;i<l;i++){var morphTarget=morphTargets[i];var attribute=new Float32BufferAttribute(morphTarget.length*3,3);array.push(attribute.copyVector3sArray(morphTarget));}this.morphAttributes[name]=array;}// skinning
if(geometry.skinIndices.length>0){var skinIndices=new Float32BufferAttribute(geometry.skinIndices.length*4,4);this.addAttribute('skinIndex',skinIndices.copyVector4sArray(geometry.skinIndices));}if(geometry.skinWeights.length>0){var skinWeights=new Float32BufferAttribute(geometry.skinWeights.length*4,4);this.addAttribute('skinWeight',skinWeights.copyVector4sArray(geometry.skinWeights));}//
if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}return this;},computeBoundingBox:function computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}var position=this.attributes.position;if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);}else{this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}},computeBoundingSphere:function(){var box=new Box3();var vector=new Vector3();return function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}var position=this.attributes.position;if(position){var center=this.boundingSphere.center;box.setFromBufferAttribute(position);box.getCenter(center);// hoping to find a boundingSphere with a radius smaller than the
// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
var maxRadiusSq=0;for(var i=0,il=position.count;i<il;i++){vector.x=position.getX(i);vector.y=position.getY(i);vector.z=position.getZ(i);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(vector));}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}};}(),computeFaceNormals:function computeFaceNormals(){// backwards compatibility
},computeVertexNormals:function computeVertexNormals(){var index=this.index;var attributes=this.attributes;var groups=this.groups;if(attributes.position){var positions=attributes.position.array;if(attributes.normal===undefined){this.addAttribute('normal',new BufferAttribute(new Float32Array(positions.length),3));}else{// reset existing normals to zero
var array=attributes.normal.array;for(var i=0,il=array.length;i<il;i++){array[i]=0;}}var normals=attributes.normal.array;var vA,vB,vC;var pA=new Vector3(),pB=new Vector3(),pC=new Vector3();var cb=new Vector3(),ab=new Vector3();// indexed elements
if(index){var indices=index.array;if(groups.length===0){this.addGroup(0,indices.length);}for(var j=0,jl=groups.length;j<jl;++j){var group=groups[j];var start=group.start;var count=group.count;for(var i=start,il=start+count;i<il;i+=3){vA=indices[i+0]*3;vB=indices[i+1]*3;vC=indices[i+2]*3;pA.fromArray(positions,vA);pB.fromArray(positions,vB);pC.fromArray(positions,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[vA]+=cb.x;normals[vA+1]+=cb.y;normals[vA+2]+=cb.z;normals[vB]+=cb.x;normals[vB+1]+=cb.y;normals[vB+2]+=cb.z;normals[vC]+=cb.x;normals[vC+1]+=cb.y;normals[vC+2]+=cb.z;}}}else{// non-indexed elements (unconnected triangle soup)
for(var i=0,il=positions.length;i<il;i+=9){pA.fromArray(positions,i);pB.fromArray(positions,i+3);pC.fromArray(positions,i+6);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[i]=cb.x;normals[i+1]=cb.y;normals[i+2]=cb.z;normals[i+3]=cb.x;normals[i+4]=cb.y;normals[i+5]=cb.z;normals[i+6]=cb.x;normals[i+7]=cb.y;normals[i+8]=cb.z;}}this.normalizeNormals();attributes.normal.needsUpdate=true;}},merge:function merge(geometry,offset){if(!(geometry&&geometry.isBufferGeometry)){console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',geometry);return;}if(offset===undefined)offset=0;var attributes=this.attributes;for(var key in attributes){if(geometry.attributes[key]===undefined)continue;var attribute1=attributes[key];var attributeArray1=attribute1.array;var attribute2=geometry.attributes[key];var attributeArray2=attribute2.array;var attributeSize=attribute2.itemSize;for(var i=0,j=attributeSize*offset;i<attributeArray2.length;i++,j++){attributeArray1[j]=attributeArray2[i];}}return this;},normalizeNormals:function(){var vector=new Vector3();return function normalizeNormals(){var normals=this.attributes.normal;for(var i=0,il=normals.count;i<il;i++){vector.x=normals.getX(i);vector.y=normals.getY(i);vector.z=normals.getZ(i);vector.normalize();normals.setXYZ(i,vector.x,vector.y,vector.z);}};}(),toNonIndexed:function toNonIndexed(){if(this.index===null){console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');return this;}var geometry2=new BufferGeometry();var indices=this.index.array;var attributes=this.attributes;for(var name in attributes){var attribute=attributes[name];var array=attribute.array;var itemSize=attribute.itemSize;var array2=new array.constructor(indices.length*itemSize);var index=0,index2=0;for(var i=0,l=indices.length;i<l;i++){index=indices[i]*itemSize;for(var j=0;j<itemSize;j++){array2[index2++]=array[index++];}}geometry2.addAttribute(name,new BufferAttribute(array2,itemSize));}return geometry2;},toJSON:function toJSON(){var data={metadata:{version:4.5,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}data.data={attributes:{}};var index=this.index;if(index!==null){var array=Array.prototype.slice.call(index.array);data.data.index={type:index.array.constructor.name,array:array};}var attributes=this.attributes;for(var key in attributes){var attribute=attributes[key];var array=Array.prototype.slice.call(attribute.array);data.data.attributes[key]={itemSize:attribute.itemSize,type:attribute.array.constructor.name,array:array,normalized:attribute.normalized};}var groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse(JSON.stringify(groups));}var boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius};}return data;},clone:function clone(){/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */return new BufferGeometry().copy(this);},copy:function copy(source){var name,i,l;// reset
this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// name
this.name=source.name;// index
var index=source.index;if(index!==null){this.setIndex(index.clone());}// attributes
var attributes=source.attributes;for(name in attributes){var attribute=attributes[name];this.addAttribute(name,attribute.clone());}// morph attributes
var morphAttributes=source.morphAttributes;for(name in morphAttributes){var array=[];var morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
for(i=0,l=morphAttribute.length;i<l;i++){array.push(morphAttribute[i].clone());}this.morphAttributes[name]=array;}// groups
var groups=source.groups;for(i=0,l=groups.length;i<l;i++){var group=groups[i];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});/**
	 * @author jonobr1 / http://jonobr1.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */// ShapeGeometry
function ShapeGeometry(shapes,curveSegments){Geometry.call(this);this.type='ShapeGeometry';if((typeof curveSegments==='undefined'?'undefined':_typeof(curveSegments))==='object'){console.warn('THREE.ShapeGeometry: Options parameter has been removed.');curveSegments=curveSegments.curveSegments;}this.parameters={shapes:shapes,curveSegments:curveSegments};this.fromBufferGeometry(new ShapeBufferGeometry(shapes,curveSegments));this.mergeVertices();}ShapeGeometry.prototype=Object.create(Geometry.prototype);ShapeGeometry.prototype.constructor=ShapeGeometry;// ShapeBufferGeometry
function ShapeBufferGeometry(shapes,curveSegments){BufferGeometry.call(this);this.type='ShapeBufferGeometry';this.parameters={shapes:shapes,curveSegments:curveSegments};curveSegments=curveSegments||12;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var groupStart=0;var groupCount=0;// allow single and array values for "shapes" parameter
if(Array.isArray(shapes)===false){addShape(shapes);}else{for(var i=0;i<shapes.length;i++){addShape(shapes[i]);this.addGroup(groupStart,groupCount,i);// enables MultiMaterial support
groupStart+=groupCount;groupCount=0;}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));// helper functions
function addShape(shape){var i,l,shapeHole;var indexOffset=vertices.length/3;var points=shape.extractPoints(curveSegments);var shapeVertices=points.shape;var shapeHoles=points.holes;// check direction of vertices
if(ShapeUtils.isClockWise(shapeVertices)===false){shapeVertices=shapeVertices.reverse();// also check if holes are in the opposite direction
for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];if(ShapeUtils.isClockWise(shapeHole)===true){shapeHoles[i]=shapeHole.reverse();}}}var faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);// join vertices of inner and outer paths to a single array
for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];shapeVertices=shapeVertices.concat(shapeHole);}// vertices, normals, uvs
for(i=0,l=shapeVertices.length;i<l;i++){var vertex=shapeVertices[i];vertices.push(vertex.x,vertex.y,0);normals.push(0,0,1);uvs.push(vertex.x,vertex.y);// world uvs
}// incides
for(i=0,l=faces.length;i<l;i++){var face=faces[i];var a=face[0]+indexOffset;var b=face[1]+indexOffset;var c=face[2]+indexOffset;indices.push(a,b,c);groupCount+=3;}}}ShapeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);ShapeBufferGeometry.prototype.constructor=ShapeBufferGeometry;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */// BoxGeometry
function BoxGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){Geometry.call(this);this.type='BoxGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};this.fromBufferGeometry(new BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments));this.mergeVertices();}BoxGeometry.prototype=Object.create(Geometry.prototype);BoxGeometry.prototype.constructor=BoxGeometry;// BoxBufferGeometry
function BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){BufferGeometry.call(this);this.type='BoxBufferGeometry';this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};var scope=this;width=width||1;height=height||1;depth=depth||1;// segments
widthSegments=Math.floor(widthSegments)||1;heightSegments=Math.floor(heightSegments)||1;depthSegments=Math.floor(depthSegments)||1;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var numberOfVertices=0;var groupStart=0;// build each side of the box geometry
buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){var segmentWidth=width/gridX;var segmentHeight=height/gridY;var widthHalf=width/2;var heightHalf=height/2;var depthHalf=depth/2;var gridX1=gridX+1;var gridY1=gridY+1;var vertexCounter=0;var groupCount=0;var ix,iy;var vector=new Vector3();// generate vertices, normals and uvs
for(iy=0;iy<gridY1;iy++){var y=iy*segmentHeight-heightHalf;for(ix=0;ix<gridX1;ix++){var x=ix*segmentWidth-widthHalf;// set values to correct vector component
vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
vertices.push(vector.x,vector.y,vector.z);// set values to correct vector component
vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
normals.push(vector.x,vector.y,vector.z);// uvs
uvs.push(ix/gridX);uvs.push(1-iy/gridY);// counters
vertexCounter+=1;}}// indices
// 1. you need three indices to draw a single face
// 2. a single segment consists of two faces
// 3. so we need to generate six (2*3) indices per segment
for(iy=0;iy<gridY;iy++){for(ix=0;ix<gridX;ix++){var a=numberOfVertices+ix+gridX1*iy;var b=numberOfVertices+ix+gridX1*(iy+1);var c=numberOfVertices+(ix+1)+gridX1*(iy+1);var d=numberOfVertices+(ix+1)+gridX1*iy;// faces
indices.push(a,b,d);indices.push(b,c,d);// increase counter
groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
groupStart+=groupCount;// update total number of vertices
numberOfVertices+=vertexCounter;}}BoxBufferGeometry.prototype=Object.create(BufferGeometry.prototype);BoxBufferGeometry.prototype.constructor=BoxBufferGeometry;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */// PlaneGeometry
function PlaneGeometry(width,height,widthSegments,heightSegments){Geometry.call(this);this.type='PlaneGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};this.fromBufferGeometry(new PlaneBufferGeometry(width,height,widthSegments,heightSegments));this.mergeVertices();}PlaneGeometry.prototype=Object.create(Geometry.prototype);PlaneGeometry.prototype.constructor=PlaneGeometry;// PlaneBufferGeometry
function PlaneBufferGeometry(width,height,widthSegments,heightSegments){BufferGeometry.call(this);this.type='PlaneBufferGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};width=width||1;height=height||1;var width_half=width/2;var height_half=height/2;var gridX=Math.floor(widthSegments)||1;var gridY=Math.floor(heightSegments)||1;var gridX1=gridX+1;var gridY1=gridY+1;var segment_width=width/gridX;var segment_height=height/gridY;var ix,iy;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
for(iy=0;iy<gridY1;iy++){var y=iy*segment_height-height_half;for(ix=0;ix<gridX1;ix++){var x=ix*segment_width-width_half;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX);uvs.push(1-iy/gridY);}}// indices
for(iy=0;iy<gridY;iy++){for(ix=0;ix<gridX;ix++){var a=ix+gridX1*iy;var b=ix+gridX1*(iy+1);var c=ix+1+gridX1*(iy+1);var d=ix+1+gridX1*iy;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}PlaneBufferGeometry.prototype=Object.create(BufferGeometry.prototype);PlaneBufferGeometry.prototype.constructor=PlaneBufferGeometry;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */function MeshBasicMaterial(parameters){Material.call(this);this.type='MeshBasicMaterial';this.color=new Color(0xffffff);// emissive
this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.lights=false;this.setValues(parameters);}MeshBasicMaterial.prototype=Object.create(Material.prototype);MeshBasicMaterial.prototype.constructor=MeshBasicMaterial;MeshBasicMaterial.prototype.isMeshBasicMaterial=true;MeshBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;return this;};/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */function ShaderMaterial(parameters){Material.call(this);this.type='ShaderMaterial';this.defines={};this.uniforms={};this.vertexShader='void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';this.fragmentShader='void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';this.linewidth=1;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;// set to use scene fog
this.lights=false;// set to use scene lights
this.clipping=false;// set to use user-defined clipping planes
this.skinning=false;// set to use skinning attribute streams
this.morphTargets=false;// set to use morph targets
this.morphNormals=false;// set to use morph normals
this.extensions={derivatives:false,// set to use derivatives
fragDepth:false,// set to use fragment depth values
drawBuffers:false,// set to use draw buffers
shaderTextureLOD:false// set to use shader texture LOD
};// When rendered geometry doesn't include these attributes but the material does,
// use these default values in WebGL. This avoids errors when buffer data is missing.
this.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv2':[0,0]};this.index0AttributeName=undefined;if(parameters!==undefined){if(parameters.attributes!==undefined){console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');}this.setValues(parameters);}}ShaderMaterial.prototype=Object.create(Material.prototype);ShaderMaterial.prototype.constructor=ShaderMaterial;ShaderMaterial.prototype.isShaderMaterial=true;ShaderMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=UniformsUtils.clone(source.uniforms);this.defines=source.defines;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.lights=source.lights;this.clipping=source.clipping;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;this.extensions=source.extensions;return this;};ShaderMaterial.prototype.toJSON=function(meta){var data=Material.prototype.toJSON.call(this,meta);data.uniforms=this.uniforms;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;return data;};/**
	 * @author bhouston / http://clara.io
	 */function Ray(origin,direction){this.origin=origin!==undefined?origin:new Vector3();this.direction=direction!==undefined?direction:new Vector3();}Object.assign(Ray.prototype,{set:function set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;},at:function at(t,optionalTarget){var result=optionalTarget||new Vector3();return result.copy(this.direction).multiplyScalar(t).add(this.origin);},lookAt:function lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this;},recast:function(){var v1=new Vector3();return function recast(t){this.origin.copy(this.at(t,v1));return this;};}(),closestPointToPoint:function closestPointToPoint(point,optionalTarget){var result=optionalTarget||new Vector3();result.subVectors(point,this.origin);var directionDistance=result.dot(this.direction);if(directionDistance<0){return result.copy(this.origin);}return result.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);},distanceToPoint:function distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point));},distanceSqToPoint:function(){var v1=new Vector3();return function distanceSqToPoint(point){var directionDistance=v1.subVectors(point,this.origin).dot(this.direction);// point behind the ray
if(directionDistance<0){return this.origin.distanceToSquared(point);}v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return v1.distanceToSquared(point);};}(),distanceSqToSegment:function(){var segCenter=new Vector3();var segDir=new Vector3();var diff=new Vector3();return function distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
// It returns the min distance between the ray and the segment
// defined by v0 and v1
// It can also set two optional targets :
// - The closest point on the ray
// - The closest point on the segment
segCenter.copy(v0).add(v1).multiplyScalar(0.5);segDir.copy(v1).sub(v0).normalize();diff.copy(this.origin).sub(segCenter);var segExtent=v0.distanceTo(v1)*0.5;var a01=-this.direction.dot(segDir);var b0=diff.dot(this.direction);var b1=-diff.dot(segDir);var c=diff.lengthSq();var det=Math.abs(1-a01*a01);var s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
// Minimum at interior points of ray and segment.
var invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else{// region 1
s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{// region 5
s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{if(s1<=-extDet){// region 4
s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else{// region 2
s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else{// Ray and segment are parallel.
s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);}if(optionalPointOnSegment){optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);}return sqrDist;};}(),intersectSphere:function(){var v1=new Vector3();return function intersectSphere(sphere,optionalTarget){v1.subVectors(sphere.center,this.origin);var tca=v1.dot(this.direction);var d2=v1.dot(v1)-tca*tca;var radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;var thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
var t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
var t1=tca+thc;// test to see if both t0 and t1 are behind the ray - if so, return null
if(t0<0&&t1<0)return null;// test to see if t0 is behind the ray:
// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
// in order to always return an intersect point that is in front of the ray.
if(t0<0)return this.at(t1,optionalTarget);// else t0 is in front of the ray, so return the first collision point scaled by t0
return this.at(t0,optionalTarget);};}(),intersectsSphere:function intersectsSphere(sphere){return this.distanceToPoint(sphere.center)<=sphere.radius;},distanceToPlane:function distanceToPlane(plane){var denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
return null;}var t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
return t>=0?t:null;},intersectPlane:function intersectPlane(plane,optionalTarget){var t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,optionalTarget);},intersectsPlane:function intersectsPlane(plane){// check if the ray lies on the plane first
var distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}var denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
return false;},intersectBox:function intersectBox(box,optionalTarget){var tmin,tmax,tymin,tymax,tzmin,tzmax;var invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;var origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else{tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else{tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;// These lines also handle the case where tmin or tmax is NaN
// (result of 0 * Infinity). x !== x returns true if x is NaN
if(tymin>tmin||tmin!==tmin)tmin=tymin;if(tymax<tmax||tmax!==tmax)tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else{tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,optionalTarget);},intersectsBox:function(){var v=new Vector3();return function intersectsBox(box){return this.intersectBox(box,v)!==null;};}(),intersectTriangle:function(){// Compute the offset origin, edges, and normal.
var diff=new Vector3();var edge1=new Vector3();var edge2=new Vector3();var normal=new Vector3();return function intersectTriangle(a,b,c,backfaceCulling,optionalTarget){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
edge1.subVectors(b,a);edge2.subVectors(c,a);normal.crossVectors(edge1,edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
var DdN=this.direction.dot(normal);var sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else{return null;}diff.subVectors(this.origin,a);var DdQxE2=sign*this.direction.dot(edge2.crossVectors(diff,edge2));// b1 < 0, no intersection
if(DdQxE2<0){return null;}var DdE1xQ=sign*this.direction.dot(edge1.cross(diff));// b2 < 0, no intersection
if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
var QdN=-sign*diff.dot(normal);// t < 0, no intersection
if(QdN<0){return null;}// Ray intersects triangle.
return this.at(QdN/DdN,optionalTarget);};}(),applyMatrix4:function applyMatrix4(matrix4){this.origin.applyMatrix4(matrix4);this.direction.transformDirection(matrix4);return this;},equals:function equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}});/**
	 * @author bhouston / http://clara.io
	 */function Line3(start,end){this.start=start!==undefined?start:new Vector3();this.end=end!==undefined?end:new Vector3();}Object.assign(Line3.prototype,{set:function set(start,end){this.start.copy(start);this.end.copy(end);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(line){this.start.copy(line.start);this.end.copy(line.end);return this;},getCenter:function getCenter(optionalTarget){var result=optionalTarget||new Vector3();return result.addVectors(this.start,this.end).multiplyScalar(0.5);},delta:function delta(optionalTarget){var result=optionalTarget||new Vector3();return result.subVectors(this.end,this.start);},distanceSq:function distanceSq(){return this.start.distanceToSquared(this.end);},distance:function distance(){return this.start.distanceTo(this.end);},at:function at(t,optionalTarget){var result=optionalTarget||new Vector3();return this.delta(result).multiplyScalar(t).add(this.start);},closestPointToPointParameter:function(){var startP=new Vector3();var startEnd=new Vector3();return function closestPointToPointParameter(point,clampToLine){startP.subVectors(point,this.start);startEnd.subVectors(this.end,this.start);var startEnd2=startEnd.dot(startEnd);var startEnd_startP=startEnd.dot(startP);var t=startEnd_startP/startEnd2;if(clampToLine){t=_Math.clamp(t,0,1);}return t;};}(),closestPointToPoint:function closestPointToPoint(point,clampToLine,optionalTarget){var t=this.closestPointToPointParameter(point,clampToLine);var result=optionalTarget||new Vector3();return this.delta(result).multiplyScalar(t).add(this.start);},applyMatrix4:function applyMatrix4(matrix){this.start.applyMatrix4(matrix);this.end.applyMatrix4(matrix);return this;},equals:function equals(line){return line.start.equals(this.start)&&line.end.equals(this.end);}});/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */function Triangle(a,b,c){this.a=a!==undefined?a:new Vector3();this.b=b!==undefined?b:new Vector3();this.c=c!==undefined?c:new Vector3();}Object.assign(Triangle,{normal:function(){var v0=new Vector3();return function normal(a,b,c,optionalTarget){var result=optionalTarget||new Vector3();result.subVectors(c,b);v0.subVectors(a,b);result.cross(v0);var resultLengthSq=result.lengthSq();if(resultLengthSq>0){return result.multiplyScalar(1/Math.sqrt(resultLengthSq));}return result.set(0,0,0);};}(),// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
barycoordFromPoint:function(){var v0=new Vector3();var v1=new Vector3();var v2=new Vector3();return function barycoordFromPoint(point,a,b,c,optionalTarget){v0.subVectors(c,a);v1.subVectors(b,a);v2.subVectors(point,a);var dot00=v0.dot(v0);var dot01=v0.dot(v1);var dot02=v0.dot(v2);var dot11=v1.dot(v1);var dot12=v1.dot(v2);var denom=dot00*dot11-dot01*dot01;var result=optionalTarget||new Vector3();// collinear or singular triangle
if(denom===0){// arbitrary location outside of triangle?
// not sure if this is the best idea, maybe should be returning undefined
return result.set(-2,-1,-1);}var invDenom=1/denom;var u=(dot11*dot02-dot01*dot12)*invDenom;var v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
return result.set(1-u-v,v,u);};}(),containsPoint:function(){var v1=new Vector3();return function containsPoint(point,a,b,c){var result=Triangle.barycoordFromPoint(point,a,b,c,v1);return result.x>=0&&result.y>=0&&result.x+result.y<=1;};}()});Object.assign(Triangle.prototype,{set:function set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;},setFromPointsAndIndices:function setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;},area:function(){var v0=new Vector3();var v1=new Vector3();return function area(){v0.subVectors(this.c,this.b);v1.subVectors(this.a,this.b);return v0.cross(v1).length()*0.5;};}(),midpoint:function midpoint(optionalTarget){var result=optionalTarget||new Vector3();return result.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);},normal:function normal(optionalTarget){return Triangle.normal(this.a,this.b,this.c,optionalTarget);},plane:function plane(optionalTarget){var result=optionalTarget||new Plane();return result.setFromCoplanarPoints(this.a,this.b,this.c);},barycoordFromPoint:function barycoordFromPoint(point,optionalTarget){return Triangle.barycoordFromPoint(point,this.a,this.b,this.c,optionalTarget);},containsPoint:function containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c);},closestPointToPoint:function(){var plane=new Plane();var edgeList=[new Line3(),new Line3(),new Line3()];var projectedPoint=new Vector3();var closestPoint=new Vector3();return function closestPointToPoint(point,optionalTarget){var result=optionalTarget||new Vector3();var minDistance=Infinity;// project the point onto the plane of the triangle
plane.setFromCoplanarPoints(this.a,this.b,this.c);plane.projectPoint(point,projectedPoint);// check if the projection lies within the triangle
if(this.containsPoint(projectedPoint)===true){// if so, this is the closest point
result.copy(projectedPoint);}else{// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices
edgeList[0].set(this.a,this.b);edgeList[1].set(this.b,this.c);edgeList[2].set(this.c,this.a);for(var i=0;i<edgeList.length;i++){edgeList[i].closestPointToPoint(projectedPoint,true,closestPoint);var distance=projectedPoint.distanceToSquared(closestPoint);if(distance<minDistance){minDistance=distance;result.copy(closestPoint);}}}return result;};}(),equals:function equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */function Mesh(geometry,material){Object3D.call(this);this.type='Mesh';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new MeshBasicMaterial({color:Math.random()*0xffffff});this.drawMode=TrianglesDrawMode;this.updateMorphTargets();}Mesh.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Mesh,isMesh:true,setDrawMode:function setDrawMode(value){this.drawMode=value;},copy:function copy(source){Object3D.prototype.copy.call(this,source);this.drawMode=source.drawMode;if(source.morphTargetInfluences!==undefined){this.morphTargetInfluences=source.morphTargetInfluences.slice();}if(source.morphTargetDictionary!==undefined){this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary);}return this;},updateMorphTargets:function updateMorphTargets(){var geometry=this.geometry;var m,ml,name;if(geometry.isBufferGeometry){var morphAttributes=geometry.morphAttributes;var keys=Object.keys(morphAttributes);if(keys.length>0){var morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(m=0,ml=morphAttribute.length;m<ml;m++){name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else{var morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(m=0,ml=morphTargets.length;m<ml;m++){name=morphTargets[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}},raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();var vA=new Vector3();var vB=new Vector3();var vC=new Vector3();var tempA=new Vector3();var tempB=new Vector3();var tempC=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();var barycoord=new Vector3();var intersectionPoint=new Vector3();var intersectionPointWorld=new Vector3();function uvIntersection(point,p1,p2,p3,uv1,uv2,uv3){Triangle.barycoordFromPoint(point,p1,p2,p3,barycoord);uv1.multiplyScalar(barycoord.x);uv2.multiplyScalar(barycoord.y);uv3.multiplyScalar(barycoord.z);uv1.add(uv2).add(uv3);return uv1.clone();}function checkIntersection(object,material,raycaster,ray,pA,pB,pC,point){var intersect;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else{intersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide,point);}if(intersect===null)return null;intersectionPointWorld.copy(point);intersectionPointWorld.applyMatrix4(object.matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return{distance:distance,point:intersectionPointWorld.clone(),object:object};}function checkBufferGeometryIntersection(object,raycaster,ray,position,uv,a,b,c){vA.fromBufferAttribute(position,a);vB.fromBufferAttribute(position,b);vC.fromBufferAttribute(position,c);var intersection=checkIntersection(object,object.material,raycaster,ray,vA,vB,vC,intersectionPoint);if(intersection){if(uv){uvA.fromBufferAttribute(uv,a);uvB.fromBufferAttribute(uv,b);uvC.fromBufferAttribute(uv,c);intersection.uv=uvIntersection(intersectionPoint,vA,vB,vC,uvA,uvB,uvC);}intersection.face=new Face3(a,b,c,Triangle.normal(vA,vB,vC));intersection.faceIndex=a;}return intersection;}return function raycast(raycaster,intersects){var geometry=this.geometry;var material=this.material;var matrixWorld=this.matrixWorld;if(material===undefined)return;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(sphere)===false)return;//
inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);// Check boundingBox before continuing
if(geometry.boundingBox!==null){if(ray.intersectsBox(geometry.boundingBox)===false)return;}var intersection;if(geometry.isBufferGeometry){var a,b,c;var index=geometry.index;var position=geometry.attributes.position;var uv=geometry.attributes.uv;var i,l;if(index!==null){// indexed buffer geometry
for(i=0,l=index.count;i<l;i+=3){a=index.getX(i);b=index.getX(i+1);c=index.getX(i+2);intersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in indices buffer semantics
intersects.push(intersection);}}}else if(position!==undefined){// non-indexed buffer geometry
for(i=0,l=position.count;i<l;i+=3){a=i;b=i+1;c=i+2;intersection=checkBufferGeometryIntersection(this,raycaster,ray,position,uv,a,b,c);if(intersection){intersection.index=a;// triangle number in positions buffer semantics
intersects.push(intersection);}}}}else if(geometry.isGeometry){var fvA,fvB,fvC;var isMultiMaterial=Array.isArray(material);var vertices=geometry.vertices;var faces=geometry.faces;var uvs;var faceVertexUvs=geometry.faceVertexUvs[0];if(faceVertexUvs.length>0)uvs=faceVertexUvs;for(var f=0,fl=faces.length;f<fl;f++){var face=faces[f];var faceMaterial=isMultiMaterial?material[face.materialIndex]:material;if(faceMaterial===undefined)continue;fvA=vertices[face.a];fvB=vertices[face.b];fvC=vertices[face.c];if(faceMaterial.morphTargets===true){var morphTargets=geometry.morphTargets;var morphInfluences=this.morphTargetInfluences;vA.set(0,0,0);vB.set(0,0,0);vC.set(0,0,0);for(var t=0,tl=morphTargets.length;t<tl;t++){var influence=morphInfluences[t];if(influence===0)continue;var targets=morphTargets[t].vertices;vA.addScaledVector(tempA.subVectors(targets[face.a],fvA),influence);vB.addScaledVector(tempB.subVectors(targets[face.b],fvB),influence);vC.addScaledVector(tempC.subVectors(targets[face.c],fvC),influence);}vA.add(fvA);vB.add(fvB);vC.add(fvC);fvA=vA;fvB=vB;fvC=vC;}intersection=checkIntersection(this,faceMaterial,raycaster,ray,fvA,fvB,fvC,intersectionPoint);if(intersection){if(uvs&&uvs[f]){var uvs_f=uvs[f];uvA.copy(uvs_f[0]);uvB.copy(uvs_f[1]);uvC.copy(uvs_f[2]);intersection.uv=uvIntersection(intersectionPoint,fvA,fvB,fvC,uvA,uvB,uvC);}intersection.face=face;intersection.faceIndex=f;intersects.push(intersection);}}}};}(),clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLBackground(renderer,state,geometries,premultipliedAlpha){var clearColor=new Color(0x000000);var clearAlpha=0;var planeCamera,planeMesh;var boxMesh;function render(renderList,scene,camera,forceClear){var background=scene.background;if(background===null){setClear(clearColor,clearAlpha);}else if(background&&background.isColor){setClear(background,1);forceClear=true;}if(renderer.autoClear||forceClear){renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil);}if(background&&background.isCubeTexture){if(boxMesh===undefined){boxMesh=new Mesh(new BoxBufferGeometry(1,1,1),new ShaderMaterial({uniforms:ShaderLib.cube.uniforms,vertexShader:ShaderLib.cube.vertexShader,fragmentShader:ShaderLib.cube.fragmentShader,side:BackSide,depthTest:true,depthWrite:false,fog:false}));boxMesh.geometry.removeAttribute('normal');boxMesh.geometry.removeAttribute('uv');boxMesh.onBeforeRender=function(renderer,scene,camera){this.matrixWorld.copyPosition(camera.matrixWorld);};geometries.update(boxMesh.geometry);}boxMesh.material.uniforms.tCube.value=background;renderList.push(boxMesh,boxMesh.geometry,boxMesh.material,0,null);}else if(background&&background.isTexture){if(planeCamera===undefined){planeCamera=new OrthographicCamera(-1,1,1,-1,0,1);planeMesh=new Mesh(new PlaneBufferGeometry(2,2),new MeshBasicMaterial({depthTest:false,depthWrite:false,fog:false}));geometries.update(planeMesh.geometry);}planeMesh.material.map=background;// TODO Push this to renderList
renderer.renderBufferDirect(planeCamera,null,planeMesh.geometry,planeMesh.material,planeMesh,null);}}function setClear(color,alpha){state.buffers.color.setClear(color.r,color.g,color.b,alpha,premultipliedAlpha);}return{getClearColor:function getClearColor(){return clearColor;},setClearColor:function setClearColor(color,alpha){clearColor.set(color);clearAlpha=alpha!==undefined?alpha:1;setClear(clearColor,clearAlpha);},getClearAlpha:function getClearAlpha(){return clearAlpha;},setClearAlpha:function setClearAlpha(alpha){clearAlpha=alpha;setClear(clearColor,clearAlpha);},render:render};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function painterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.program&&b.program&&a.program!==b.program){return a.program.id-b.program.id;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else{return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}if(a.z!==b.z){return b.z-a.z;}else{return a.id-b.id;}}function WebGLRenderList(){var renderItems=[];var renderItemsIndex=0;var opaque=[];var transparent=[];function init(){renderItemsIndex=0;opaque.length=0;transparent.length=0;}function push(object,geometry,material,z,group){var renderItem=renderItems[renderItemsIndex];if(renderItem===undefined){renderItem={id:object.id,object:object,geometry:geometry,material:material,program:material.program,renderOrder:object.renderOrder,z:z,group:group};renderItems[renderItemsIndex]=renderItem;}else{renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.program=material.program;renderItem.renderOrder=object.renderOrder;renderItem.z=z;renderItem.group=group;}(material.transparent===true?transparent:opaque).push(renderItem);renderItemsIndex++;}function sort(){if(opaque.length>1)opaque.sort(painterSortStable);if(transparent.length>1)transparent.sort(reversePainterSortStable);}return{opaque:opaque,transparent:transparent,init:init,push:push,sort:sort};}function WebGLRenderLists(){var lists={};function get(scene,camera){var hash=scene.id+','+camera.id;var list=lists[hash];if(list===undefined){// console.log( 'THREE.WebGLRenderLists:', hash );
list=new WebGLRenderList();lists[hash]=list;}return list;}function dispose(){lists={};}return{get:get,dispose:dispose};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function absNumericalSort(a,b){return Math.abs(b[1])-Math.abs(a[1]);}function WebGLMorphtargets(gl){var influencesList={};var morphInfluences=new Float32Array(8);function update(object,geometry,material,program){var objectInfluences=object.morphTargetInfluences;var length=objectInfluences.length;var influences=influencesList[geometry.id];if(influences===undefined){// initialise list
influences=[];for(var i=0;i<length;i++){influences[i]=[i,0];}influencesList[geometry.id]=influences;}var morphTargets=material.morphTargets&&geometry.morphAttributes.position;var morphNormals=material.morphNormals&&geometry.morphAttributes.normal;// Remove current morphAttributes
for(var i=0;i<length;i++){var influence=influences[i];if(influence[1]!==0){if(morphTargets)geometry.removeAttribute('morphTarget'+i);if(morphNormals)geometry.removeAttribute('morphNormal'+i);}}// Collect influences
for(var i=0;i<length;i++){var influence=influences[i];influence[0]=i;influence[1]=objectInfluences[i];}influences.sort(absNumericalSort);// Add morphAttributes
for(var i=0;i<8;i++){var influence=influences[i];if(influence){var index=influence[0];var value=influence[1];if(value){if(morphTargets)geometry.addAttribute('morphTarget'+i,morphTargets[index]);if(morphNormals)geometry.addAttribute('morphNormal'+i,morphNormals[index]);morphInfluences[i]=value;continue;}}morphInfluences[i]=0;}program.getUniforms().setValue(gl,'morphTargetInfluences',morphInfluences);}return{update:update};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLIndexedBufferRenderer(gl,extensions,infoRender){var mode;function setMode(value){mode=value;}var type,bytesPerElement;function setIndex(value){type=value.type;bytesPerElement=value.bytesPerElement;}function render(start,count){gl.drawElements(mode,count,type,start*bytesPerElement);infoRender.calls++;infoRender.vertices+=count;if(mode===gl.TRIANGLES)infoRender.faces+=count/3;else if(mode===gl.POINTS)infoRender.points+=count;}function renderInstances(geometry,start,count){var extension=extensions.get('ANGLE_instanced_arrays');if(extension===null){console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}extension.drawElementsInstancedANGLE(mode,count,type,start*bytesPerElement,geometry.maxInstancedCount);infoRender.calls++;infoRender.vertices+=count*geometry.maxInstancedCount;if(mode===gl.TRIANGLES)infoRender.faces+=geometry.maxInstancedCount*count/3;else if(mode===gl.POINTS)infoRender.points+=geometry.maxInstancedCount*count;}//
this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances;}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLBufferRenderer(gl,extensions,infoRender){var mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);infoRender.calls++;infoRender.vertices+=count;if(mode===gl.TRIANGLES)infoRender.faces+=count/3;else if(mode===gl.POINTS)infoRender.points+=count;}function renderInstances(geometry,start,count){var extension=extensions.get('ANGLE_instanced_arrays');if(extension===null){console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}var position=geometry.attributes.position;if(position.isInterleavedBufferAttribute){count=position.data.count;extension.drawArraysInstancedANGLE(mode,0,count,geometry.maxInstancedCount);}else{extension.drawArraysInstancedANGLE(mode,start,count,geometry.maxInstancedCount);}infoRender.calls++;infoRender.vertices+=count*geometry.maxInstancedCount;if(mode===gl.TRIANGLES)infoRender.faces+=geometry.maxInstancedCount*count/3;else if(mode===gl.POINTS)infoRender.points+=geometry.maxInstancedCount*count;}//
this.setMode=setMode;this.render=render;this.renderInstances=renderInstances;}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLGeometries(gl,attributes,infoMemory){var geometries={};var wireframeAttributes={};function onGeometryDispose(event){var geometry=event.target;var buffergeometry=geometries[geometry.id];if(buffergeometry.index!==null){attributes.remove(buffergeometry.index);}for(var name in buffergeometry.attributes){attributes.remove(buffergeometry.attributes[name]);}geometry.removeEventListener('dispose',onGeometryDispose);delete geometries[geometry.id];// TODO Remove duplicate code
var attribute=wireframeAttributes[geometry.id];if(attribute){attributes.remove(attribute);delete wireframeAttributes[geometry.id];}attribute=wireframeAttributes[buffergeometry.id];if(attribute){attributes.remove(attribute);delete wireframeAttributes[buffergeometry.id];}//
infoMemory.geometries--;}function get(object,geometry){var buffergeometry=geometries[geometry.id];if(buffergeometry)return buffergeometry;geometry.addEventListener('dispose',onGeometryDispose);if(geometry.isBufferGeometry){buffergeometry=geometry;}else if(geometry.isGeometry){if(geometry._bufferGeometry===undefined){geometry._bufferGeometry=new BufferGeometry().setFromObject(object);}buffergeometry=geometry._bufferGeometry;}geometries[geometry.id]=buffergeometry;infoMemory.geometries++;return buffergeometry;}function update(geometry){var index=geometry.index;var geometryAttributes=geometry.attributes;if(index!==null){attributes.update(index,gl.ELEMENT_ARRAY_BUFFER);}for(var name in geometryAttributes){attributes.update(geometryAttributes[name],gl.ARRAY_BUFFER);}// morph targets
var morphAttributes=geometry.morphAttributes;for(var name in morphAttributes){var array=morphAttributes[name];for(var i=0,l=array.length;i<l;i++){attributes.update(array[i],gl.ARRAY_BUFFER);}}}function getWireframeAttribute(geometry){var attribute=wireframeAttributes[geometry.id];if(attribute)return attribute;var indices=[];var geometryIndex=geometry.index;var geometryAttributes=geometry.attributes;// console.time( 'wireframe' );
if(geometryIndex!==null){var array=geometryIndex.array;for(var i=0,l=array.length;i<l;i+=3){var a=array[i+0];var b=array[i+1];var c=array[i+2];indices.push(a,b,b,c,c,a);}}else{var array=geometryAttributes.position.array;for(var i=0,l=array.length/3-1;i<l;i+=3){var a=i+0;var b=i+1;var c=i+2;indices.push(a,b,b,c,c,a);}}// console.timeEnd( 'wireframe' );
attribute=new(arrayMax(indices)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);attributes.update(attribute,gl.ELEMENT_ARRAY_BUFFER);wireframeAttributes[geometry.id]=attribute;return attribute;}return{get:get,update:update,getWireframeAttribute:getWireframeAttribute};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function UniformsCache(){var lights={};return{get:function get(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={direction:new Vector3(),color:new Color(),shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'SpotLight':uniforms={position:new Vector3(),direction:new Vector3(),color:new Color(),distance:0,coneCos:0,penumbraCos:0,decay:0,shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'PointLight':uniforms={position:new Vector3(),color:new Color(),distance:0,decay:0,shadow:false,shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2(),shadowCameraNear:1,shadowCameraFar:1000};break;case'HemisphereLight':uniforms={direction:new Vector3(),skyColor:new Color(),groundColor:new Color()};break;case'RectAreaLight':uniforms={color:new Color(),position:new Vector3(),halfWidth:new Vector3(),halfHeight:new Vector3()// TODO (abelnation): set RectAreaLight shadow uniforms
};break;}lights[light.id]=uniforms;return uniforms;}};}function WebGLLights(){var cache=new UniformsCache();var state={hash:'',ambient:[0,0,0],directional:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};var vector3=new Vector3();var matrix4=new Matrix4();var matrix42=new Matrix4();function setup(lights,shadows,camera){var r=0,g=0,b=0;var directionalLength=0;var pointLength=0;var spotLength=0;var rectAreaLength=0;var hemiLength=0;var viewMatrix=camera.matrixWorldInverse;for(var i=0,l=lights.length;i<l;i++){var light=lights[i];var color=light.color;var intensity=light.intensity;var distance=light.distance;var shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity;g+=color.g*intensity;b+=color.b*intensity;}else if(light.isDirectionalLight){var uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);uniforms.shadow=light.castShadow;if(light.castShadow){var shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;}state.directionalShadowMap[directionalLength]=shadowMap;state.directionalShadowMatrix[directionalLength]=light.shadow.matrix;state.directional[directionalLength]=uniforms;directionalLength++;}else if(light.isSpotLight){var uniforms=cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(color).multiplyScalar(intensity);uniforms.distance=distance;uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);uniforms.coneCos=Math.cos(light.angle);uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));uniforms.decay=light.distance===0?0.0:light.decay;uniforms.shadow=light.castShadow;if(light.castShadow){var shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;}state.spotShadowMap[spotLength]=shadowMap;state.spotShadowMatrix[spotLength]=light.shadow.matrix;state.spot[spotLength]=uniforms;spotLength++;}else if(light.isRectAreaLight){var uniforms=cache.get(light);// (a) intensity controls irradiance of entire light
uniforms.color.copy(color).multiplyScalar(intensity/(light.width*light.height));// (b) intensity controls the radiance per light area
// uniforms.color.copy( color ).multiplyScalar( intensity );
uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
matrix42.identity();matrix4.copy(light.matrixWorld);matrix4.premultiply(viewMatrix);matrix42.extractRotation(matrix4);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);uniforms.halfWidth.applyMatrix4(matrix42);uniforms.halfHeight.applyMatrix4(matrix42);// TODO (abelnation): RectAreaLight distance?
// uniforms.distance = distance;
state.rectArea[rectAreaLength]=uniforms;rectAreaLength++;}else if(light.isPointLight){var uniforms=cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.distance=light.distance;uniforms.decay=light.distance===0?0.0:light.decay;uniforms.shadow=light.castShadow;if(light.castShadow){var shadow=light.shadow;uniforms.shadowBias=shadow.bias;uniforms.shadowRadius=shadow.radius;uniforms.shadowMapSize=shadow.mapSize;uniforms.shadowCameraNear=shadow.camera.near;uniforms.shadowCameraFar=shadow.camera.far;}state.pointShadowMap[pointLength]=shadowMap;state.pointShadowMatrix[pointLength]=light.shadow.matrix;state.point[pointLength]=uniforms;pointLength++;}else if(light.isHemisphereLight){var uniforms=cache.get(light);uniforms.direction.setFromMatrixPosition(light.matrixWorld);uniforms.direction.transformDirection(viewMatrix);uniforms.direction.normalize();uniforms.skyColor.copy(light.color).multiplyScalar(intensity);uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);state.hemi[hemiLength]=uniforms;hemiLength++;}}state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;state.directional.length=directionalLength;state.spot.length=spotLength;state.rectArea.length=rectAreaLength;state.point.length=pointLength;state.hemi.length=hemiLength;// TODO (sam-g-steel) why aren't we using join
state.hash=directionalLength+','+pointLength+','+spotLength+','+rectAreaLength+','+hemiLength+','+shadows.length;}return{setup:setup,state:state};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLObjects(geometries,infoRender){var updateList={};function update(object){var frame=infoRender.frame;var geometry=object.geometry;var buffergeometry=geometries.get(object,geometry);// Update once per frame
if(updateList[buffergeometry.id]!==frame){if(geometry.isGeometry){buffergeometry.updateFromObject(object);}geometries.update(buffergeometry);updateList[buffergeometry.id]=frame;}return buffergeometry;}function clear(){updateList={};}return{update:update,clear:clear};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function addLineNumbers(string){var lines=string.split('\n');for(var i=0;i<lines.length;i++){lines[i]=i+1+': '+lines[i];}return lines.join('\n');}function WebGLShader(gl,type,string){var shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);if(gl.getShaderParameter(shader,gl.COMPILE_STATUS)===false){console.error('THREE.WebGLShader: Shader couldn\'t compile.');}if(gl.getShaderInfoLog(shader)!==''){console.warn('THREE.WebGLShader: gl.getShaderInfoLog()',type===gl.VERTEX_SHADER?'vertex':'fragment',gl.getShaderInfoLog(shader),addLineNumbers(string));}// --enable-privileged-webgl-extension
// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
return shader;}/**
	 * @author mrdoob / http://mrdoob.com/
	 */var programIdCount=0;function getEncodingComponents(encoding){switch(encoding){case LinearEncoding:return['Linear','( value )'];case sRGBEncoding:return['sRGB','( value )'];case RGBEEncoding:return['RGBE','( value )'];case RGBM7Encoding:return['RGBM','( value, 7.0 )'];case RGBM16Encoding:return['RGBM','( value, 16.0 )'];case RGBDEncoding:return['RGBD','( value, 256.0 )'];case GammaEncoding:return['Gamma','( value, float( GAMMA_FACTOR ) )'];default:throw new Error('unsupported encoding: '+encoding);}}function getTexelDecodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return"vec4 "+functionName+"( vec4 value ) { return "+components[0]+"ToLinear"+components[1]+"; }";}function getTexelEncodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return"vec4 "+functionName+"( vec4 value ) { return LinearTo"+components[0]+components[1]+"; }";}function getToneMappingFunction(functionName,toneMapping){var toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName="Linear";break;case ReinhardToneMapping:toneMappingName="Reinhard";break;case Uncharted2ToneMapping:toneMappingName="Uncharted2";break;case CineonToneMapping:toneMappingName="OptimizedCineon";break;default:throw new Error('unsupported toneMapping: '+toneMapping);}return"vec3 "+functionName+"( vec3 color ) { return "+toneMappingName+"ToneMapping( color ); }";}function generateExtensions(extensions,parameters,rendererExtensions){extensions=extensions||{};var chunks=[extensions.derivatives||parameters.envMapCubeUV||parameters.bumpMap||parameters.normalMap||parameters.flatShading?'#extension GL_OES_standard_derivatives : enable':'',(extensions.fragDepth||parameters.logarithmicDepthBuffer)&&rendererExtensions.get('EXT_frag_depth')?'#extension GL_EXT_frag_depth : enable':'',extensions.drawBuffers&&rendererExtensions.get('WEBGL_draw_buffers')?'#extension GL_EXT_draw_buffers : require':'',(extensions.shaderTextureLOD||parameters.envMap)&&rendererExtensions.get('EXT_shader_texture_lod')?'#extension GL_EXT_shader_texture_lod : enable':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){var chunks=[];for(var name in defines){var value=defines[name];if(value===false)continue;chunks.push('#define '+name+' '+value);}return chunks.join('\n');}function fetchAttributeLocations(gl,program){var attributes={};var n=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(var i=0;i<n;i++){var info=gl.getActiveAttrib(program,i);var name=info.name;// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
attributes[name]=gl.getAttribLocation(program,name);}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights);}function parseIncludes(string){var pattern=/^[ \t]*#include +<([\w\d.]+)>/gm;function replace(match,include){var replace=ShaderChunk[include];if(replace===undefined){throw new Error('Can not resolve #include <'+include+'>');}return parseIncludes(replace);}return string.replace(pattern,replace);}function unrollLoops(string){var pattern=/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;function replace(match,start,end,snippet){var unroll='';for(var i=parseInt(start);i<parseInt(end);i++){unroll+=snippet.replace(/\[ i \]/g,'[ '+i+' ]');}return unroll;}return string.replace(pattern,replace);}function WebGLProgram(renderer,extensions,code,material,shader,parameters){var gl=renderer.context;var defines=material.defines;var vertexShader=shader.vertexShader;var fragmentShader=shader.fragmentShader;var shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}var envMapTypeDefine='ENVMAP_TYPE_CUBE';var envMapModeDefine='ENVMAP_MODE_REFLECTION';var envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';if(parameters.envMap){switch(material.envMap.mapping){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:case CubeUVRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;case EquirectangularReflectionMapping:case EquirectangularRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_EQUIREC';break;case SphericalReflectionMapping:envMapTypeDefine='ENVMAP_TYPE_SPHERE';break;}switch(material.envMap.mapping){case CubeRefractionMapping:case EquirectangularRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}switch(material.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}var gammaFactorDefine=renderer.gammaFactor>0?renderer.gammaFactor:1.0;// console.log( 'building new program ' );
//
var customExtensions=generateExtensions(material.extensions,parameters,extensions);var customDefines=generateDefines(defines);//
var program=gl.createProgram();var prefixVertex,prefixFragment;if(material.isRawShaderMaterial){prefixVertex=[customDefines].filter(filterEmptyLine).join('\n');if(prefixVertex.length>0){prefixVertex+='\n';}prefixFragment=[customExtensions,customDefines].filter(filterEmptyLine).join('\n');if(prefixFragment.length>0){prefixFragment+='\n';}}else{prefixVertex=['precision '+parameters.precision+' float;','precision '+parameters.precision+' int;','#define SHADER_NAME '+shader.name,customDefines,parameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'','#define GAMMA_FACTOR '+gammaFactorDefine,'#define MAX_BONES '+parameters.maxBones,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.skinning?'#define USE_SKINNING':'',parameters.useVertexTexture?'#define BONE_TEXTURE':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'','#define NUM_CLIPPING_PLANES '+parameters.numClippingPlanes,parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_COLOR','	attribute vec3 color;','#endif','#ifdef USE_MORPHTARGETS','	attribute vec3 morphTarget0;','	attribute vec3 morphTarget1;','	attribute vec3 morphTarget2;','	attribute vec3 morphTarget3;','	#ifdef USE_MORPHNORMALS','		attribute vec3 morphNormal0;','		attribute vec3 morphNormal1;','		attribute vec3 morphNormal2;','		attribute vec3 morphNormal3;','	#else','		attribute vec3 morphTarget4;','		attribute vec3 morphTarget5;','		attribute vec3 morphTarget6;','		attribute vec3 morphTarget7;','	#endif','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,'precision '+parameters.precision+' float;','precision '+parameters.precision+' int;','#define SHADER_NAME '+shader.name,customDefines,parameters.alphaTest?'#define ALPHATEST '+parameters.alphaTest:'','#define GAMMA_FACTOR '+gammaFactorDefine,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'','#define NUM_CLIPPING_PLANES '+parameters.numClippingPlanes,'#define UNION_CLIPPING_PLANES '+(parameters.numClippingPlanes-parameters.numClipIntersection),parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":'',parameters.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&extensions.get('EXT_frag_depth')?'#define USE_LOGDEPTHBUF_EXT':'',parameters.envMap&&extensions.get('EXT_shader_texture_lod')?'#define TEXTURE_LOD_EXT':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;',parameters.toneMapping!==NoToneMapping?"#define TONE_MAPPING":'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
parameters.toneMapping!==NoToneMapping?getToneMappingFunction("toneMapping",parameters.toneMapping):'',parameters.dithering?'#define DITHERING':'',parameters.outputEncoding||parameters.mapEncoding||parameters.envMapEncoding||parameters.emissiveMapEncoding?ShaderChunk['encodings_pars_fragment']:'',// this code is required here because it is used by the various encoding/decoding function defined below
parameters.mapEncoding?getTexelDecodingFunction('mapTexelToLinear',parameters.mapEncoding):'',parameters.envMapEncoding?getTexelDecodingFunction('envMapTexelToLinear',parameters.envMapEncoding):'',parameters.emissiveMapEncoding?getTexelDecodingFunction('emissiveMapTexelToLinear',parameters.emissiveMapEncoding):'',parameters.outputEncoding?getTexelEncodingFunction("linearToOutputTexel",parameters.outputEncoding):'',parameters.depthPacking?"#define DEPTH_PACKING "+material.depthPacking:'','\n'].filter(filterEmptyLine).join('\n');}vertexShader=parseIncludes(vertexShader);vertexShader=replaceLightNums(vertexShader,parameters);fragmentShader=parseIncludes(fragmentShader);fragmentShader=replaceLightNums(fragmentShader,parameters);if(!material.isShaderMaterial){vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);}var vertexGlsl=prefixVertex+vertexShader;var fragmentGlsl=prefixFragment+fragmentShader;// console.log( '*VERTEX*', vertexGlsl );
// console.log( '*FRAGMENT*', fragmentGlsl );
var glVertexShader=WebGLShader(gl,gl.VERTEX_SHADER,vertexGlsl);var glFragmentShader=WebGLShader(gl,gl.FRAGMENT_SHADER,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
if(material.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,material.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);var programLog=gl.getProgramInfoLog(program);var vertexLog=gl.getShaderInfoLog(glVertexShader);var fragmentLog=gl.getShaderInfoLog(glFragmentShader);var runnable=true;var haveDiagnostics=true;// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
if(gl.getProgramParameter(program,gl.LINK_STATUS)===false){runnable=false;console.error('THREE.WebGLProgram: shader error: ',gl.getError(),'gl.VALIDATE_STATUS',gl.getProgramParameter(program,gl.VALIDATE_STATUS),'gl.getProgramInfoLog',programLog,vertexLog,fragmentLog);}else if(programLog!==''){console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){this.diagnostics={runnable:runnable,material:material,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}// clean up
gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);// set up caching for uniform locations
var cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){cachedUniforms=new WebGLUniforms(gl,program,renderer);}return cachedUniforms;};// set up caching for attribute locations
var cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){cachedAttributes=fetchAttributeLocations(gl,program);}return cachedAttributes;};// free resource
this.destroy=function(){gl.deleteProgram(program);this.program=undefined;};// DEPRECATED
Object.defineProperties(this,{uniforms:{get:function get(){console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().');return this.getUniforms();}},attributes:{get:function get(){console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().');return this.getAttributes();}}});//
this.id=programIdCount++;this.code=code;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLPrograms(renderer,extensions,capabilities){var programs=[];var shaderIDs={MeshDepthMaterial:'depth',MeshDistanceMaterial:'distanceRGBA',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'phong',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points',ShadowMaterial:'shadow'};var parameterNames=["precision","supportsVertexTextures","map","mapEncoding","envMap","envMapMode","envMapEncoding","lightMap","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","fog","useFog","fogExp","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","shadowMapEnabled","shadowMapType","toneMapping",'physicallyCorrectLights',"alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering"];function allocateBones(object){var skeleton=object.skeleton;var bones=skeleton.bones;if(capabilities.floatVertexTextures){return 1024;}else{// default for when object is not specified
// ( for example when prebuilding shader to be used with multiple objects )
//
//  - leave some extra space for other uniforms
//  - limit here is ANGLE's 254 max uniform vectors
//    (up to 54 should be safe)
var nVertexUniforms=capabilities.maxVertexUniforms;var nVertexMatrices=Math.floor((nVertexUniforms-20)/4);var maxBones=Math.min(nVertexMatrices,bones.length);if(maxBones<bones.length){console.warn('THREE.WebGLRenderer: Skeleton has '+bones.length+' bones. This GPU supports '+maxBones+'.');return 0;}return maxBones;}}function getTextureEncodingFromMap(map,gammaOverrideLinear){var encoding;if(!map){encoding=LinearEncoding;}else if(map.isTexture){encoding=map.encoding;}else if(map.isWebGLRenderTarget){console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");encoding=map.texture.encoding;}// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
if(encoding===LinearEncoding&&gammaOverrideLinear){encoding=GammaEncoding;}return encoding;}this.getParameters=function(material,lights,shadows,fog,nClipPlanes,nClipIntersection,object){var shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
// (not to blow over maxLights budget)
var maxBones=object.isSkinnedMesh?allocateBones(object):0;var precision=capabilities.precision;if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}var currentRenderTarget=renderer.getRenderTarget();var parameters={shaderID:shaderID,precision:precision,supportsVertexTextures:capabilities.vertexTextures,outputEncoding:getTextureEncodingFromMap(!currentRenderTarget?null:currentRenderTarget.texture,renderer.gammaOutput),map:!!material.map,mapEncoding:getTextureEncodingFromMap(material.map,renderer.gammaInput),envMap:!!material.envMap,envMapMode:material.envMap&&material.envMap.mapping,envMapEncoding:getTextureEncodingFromMap(material.envMap,renderer.gammaInput),envMapCubeUV:!!material.envMap&&(material.envMap.mapping===CubeUVReflectionMapping||material.envMap.mapping===CubeUVRefractionMapping),lightMap:!!material.lightMap,aoMap:!!material.aoMap,emissiveMap:!!material.emissiveMap,emissiveMapEncoding:getTextureEncodingFromMap(material.emissiveMap,renderer.gammaInput),bumpMap:!!material.bumpMap,normalMap:!!material.normalMap,displacementMap:!!material.displacementMap,roughnessMap:!!material.roughnessMap,metalnessMap:!!material.metalnessMap,specularMap:!!material.specularMap,alphaMap:!!material.alphaMap,gradientMap:!!material.gradientMap,combine:material.combine,vertexColors:material.vertexColors,fog:!!fog,useFog:material.fog,fogExp:fog&&fog.isFogExp2,flatShading:material.flatShading,sizeAttenuation:material.sizeAttenuation,logarithmicDepthBuffer:capabilities.logarithmicDepthBuffer,skinning:material.skinning&&maxBones>0,maxBones:maxBones,useVertexTexture:capabilities.floatVertexTextures,morphTargets:material.morphTargets,morphNormals:material.morphNormals,maxMorphTargets:renderer.maxMorphTargets,maxMorphNormals:renderer.maxMorphNormals,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numClippingPlanes:nClipPlanes,numClipIntersection:nClipIntersection,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&object.receiveShadow&&shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:renderer.toneMapping,physicallyCorrectLights:renderer.physicallyCorrectLights,premultipliedAlpha:material.premultipliedAlpha,alphaTest:material.alphaTest,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,depthPacking:material.depthPacking!==undefined?material.depthPacking:false};return parameters;};this.getProgramCode=function(material,parameters){var array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else{array.push(material.fragmentShader);array.push(material.vertexShader);}if(material.defines!==undefined){for(var name in material.defines){array.push(name);array.push(material.defines[name]);}}for(var i=0;i<parameterNames.length;i++){array.push(parameters[parameterNames[i]]);}array.push(material.onBeforeCompile.toString());array.push(renderer.gammaOutput);return array.join();};this.acquireProgram=function(material,shader,parameters,code){var program;// Check if code has been already compiled
for(var p=0,pl=programs.length;p<pl;p++){var programInfo=programs[p];if(programInfo.code===code){program=programInfo;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,extensions,code,material,shader,parameters);programs.push(program);}return program;};this.releaseProgram=function(program){if(--program.usedTimes===0){// Remove from unordered set
var i=programs.indexOf(program);programs[i]=programs[programs.length-1];programs.pop();// Free WebGL resources
program.destroy();}};// Exposed for resource monitoring & error feedback via renderer.info:
this.programs=programs;}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLTextures(_gl,extensions,state,properties,capabilities,utils,infoMemory){var _isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&_gl instanceof window.WebGL2RenderingContext;//
function clampToMaxSize(image,maxSize){if(image.width>maxSize||image.height>maxSize){// Warning: Scaling through the canvas will only work with images that use
// premultiplied alpha.
var scale=maxSize/Math.max(image.width,image.height);var canvas=document.createElement('canvas');canvas.width=Math.floor(image.width*scale);canvas.height=Math.floor(image.height*scale);var context=canvas.getContext('2d');context.drawImage(image,0,0,image.width,image.height,0,0,canvas.width,canvas.height);console.warn('THREE.WebGLRenderer: image is too big ('+image.width+'x'+image.height+'). Resized to '+canvas.width+'x'+canvas.height,image);return canvas;}return image;}function isPowerOfTwo(image){return _Math.isPowerOfTwo(image.width)&&_Math.isPowerOfTwo(image.height);}function makePowerOfTwo(image){if(image instanceof HTMLImageElement||image instanceof HTMLCanvasElement){var canvas=document.createElement('canvas');canvas.width=_Math.floorPowerOfTwo(image.width);canvas.height=_Math.floorPowerOfTwo(image.height);var context=canvas.getContext('2d');context.drawImage(image,0,0,canvas.width,canvas.height);console.warn('THREE.WebGLRenderer: image is not power of two ('+image.width+'x'+image.height+'). Resized to '+canvas.width+'x'+canvas.height,image);return canvas;}return image;}function textureNeedsPowerOfTwo(texture){return texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function textureNeedsGenerateMipmaps(texture,isPowerOfTwo){return texture.generateMipmaps&&isPowerOfTwo&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}// Fallback filters for non-power-of-2 textures
function filterFallback(f){if(f===NearestFilter||f===NearestMipMapNearestFilter||f===NearestMipMapLinearFilter){return _gl.NEAREST;}return _gl.LINEAR;}//
function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);infoMemory.textures--;}function onRenderTargetDispose(event){var renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);infoMemory.textures--;}//
function deallocateTexture(texture){var textureProperties=properties.get(texture);if(texture.image&&textureProperties.__image__webglTextureCube){// cube texture
_gl.deleteTexture(textureProperties.__image__webglTextureCube);}else{// 2D texture
if(textureProperties.__webglInit===undefined)return;_gl.deleteTexture(textureProperties.__webglTexture);}// remove all webgl properties
properties.remove(texture);}function deallocateRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);if(!renderTarget)return;if(textureProperties.__webglTexture!==undefined){_gl.deleteTexture(textureProperties.__webglTexture);}if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();}if(renderTarget.isWebGLRenderTargetCube){for(var i=0;i<6;i++){_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);}}else{_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);}properties.remove(renderTarget.texture);properties.remove(renderTarget);}//
function setTexture2D(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){var image=texture.image;if(image===undefined){console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined',texture);}else if(image.complete===false){console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete',texture);}else{uploadTexture(textureProperties,texture,slot);return;}}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);}function setTextureCube(texture,slot){var textureProperties=properties.get(texture);if(texture.image.length===6){if(texture.version>0&&textureProperties.__version!==texture.version){if(!textureProperties.__image__webglTextureCube){texture.addEventListener('dispose',onTextureDispose);textureProperties.__image__webglTextureCube=_gl.createTexture();infoMemory.textures++;}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);var isCompressed=texture&&texture.isCompressedTexture;var isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;var cubeImage=[];for(var i=0;i<6;i++){if(!isCompressed&&!isDataTexture){cubeImage[i]=clampToMaxSize(texture.image[i],capabilities.maxCubemapSize);}else{cubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];}}var image=cubeImage[0],isPowerOfTwoImage=isPowerOfTwo(image),glFormat=utils.convert(texture.format),glType=utils.convert(texture.type);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture,isPowerOfTwoImage);for(var i=0;i<6;i++){if(!isCompressed){if(isDataTexture){state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,cubeImage[i].width,cubeImage[i].height,0,glFormat,glType,cubeImage[i].data);}else{state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,glFormat,glFormat,glType,cubeImage[i]);}}else{var mipmap,mipmaps=cubeImage[i].mipmaps;for(var j=0,jl=mipmaps.length;j<jl;j++){mipmap=mipmaps[j];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');}}else{state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}}if(textureNeedsGenerateMipmaps(texture,isPowerOfTwoImage)){_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}else{state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__image__webglTextureCube);}}}function setTextureCubeDynamic(texture,slot){state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_CUBE_MAP,properties.get(texture).__webglTexture);}function setTextureParameters(textureType,texture,isPowerOfTwoImage){//console.log('cnmmmmmmmmmmmbbb', textureType, texture);
var extension;if(isPowerOfTwoImage){_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,utils.convert(texture.wrapS));_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,utils.convert(texture.wrapT));_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,utils.convert(texture.magFilter));_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,utils.convert(texture.minFilter));}else{_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,_gl.CLAMP_TO_EDGE);_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,_gl.CLAMP_TO_EDGE);if(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',texture);}_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterFallback(texture.magFilter));_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterFallback(texture.minFilter));if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){texture.minFilter=LinearFilter;}if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',texture);}}extension=extensions.get('EXT_texture_filter_anisotropic');if(extension){if(texture.type===FloatType&&extensions.get('OES_texture_float_linear')===null)return;if(texture.type===HalfFloatType&&extensions.get('OES_texture_half_float_linear')===null)return;if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function uploadTexture(textureProperties,texture,slot){if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);textureProperties.__webglTexture=_gl.createTexture();infoMemory.textures++;}state.activeTexture(_gl.TEXTURE0+slot);state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment);var image=clampToMaxSize(texture.image,capabilities.maxTextureSize);if(textureNeedsPowerOfTwo(texture)&&isPowerOfTwo(image)===false){image=makePowerOfTwo(image);}var isPowerOfTwoImage=isPowerOfTwo(image),glFormat=utils.convert(texture.format),glType=utils.convert(texture.type);setTextureParameters(_gl.TEXTURE_2D,texture,isPowerOfTwoImage);var mipmap,mipmaps=texture.mipmaps;if(texture.isDepthTexture){// populate depth texture with dummy data
var internalFormat=_gl.DEPTH_COMPONENT;if(texture.type===FloatType){if(!_isWebGL2)throw new Error('Float Depth Texture only supported in WebGL2.0');internalFormat=_gl.DEPTH_COMPONENT32F;}else if(_isWebGL2){// WebGL 2.0 requires signed internalformat for glTexImage2D
internalFormat=_gl.DEPTH_COMPONENT16;}if(texture.format===DepthFormat&&internalFormat===_gl.DEPTH_COMPONENT){// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');texture.type=UnsignedShortType;glType=utils.convert(texture.type);}}// Depth stencil textures need the DEPTH_STENCIL internal format
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.format===DepthStencilFormat){internalFormat=_gl.DEPTH_STENCIL;// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedInt248Type){console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');texture.type=UnsignedInt248Type;glType=utils.convert(texture.type);}}state.texImage2D(_gl.TEXTURE_2D,0,internalFormat,image.width,image.height,0,glFormat,glType,null);}else if(texture.isDataTexture){// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(mipmaps.length>0&&isPowerOfTwoImage){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}texture.generateMipmaps=false;}else{state.texImage2D(_gl.TEXTURE_2D,0,glFormat,image.width,image.height,0,glFormat,glType,image.data);}}else if(texture.isCompressedTexture){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(state.getCompressedTextureFormats().indexOf(glFormat)>-1){state.compressedTexImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');}}else{state.texImage2D(_gl.TEXTURE_2D,i,glFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}else{// regular Texture (image, video, canvas)
// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(mipmaps.length>0&&isPowerOfTwoImage){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(_gl.TEXTURE_2D,i,glFormat,glFormat,glType,mipmap);}texture.generateMipmaps=false;}else{state.texImage2D(_gl.TEXTURE_2D,0,glFormat,glFormat,glType,image);}}if(textureNeedsGenerateMipmaps(texture,isPowerOfTwoImage))_gl.generateMipmap(_gl.TEXTURE_2D);textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}// Render targets
// Setup storage for target texture and bind it to correct framebuffer
function setupFrameBufferTexture(framebuffer,renderTarget,attachment,textureTarget){var glFormat=utils.convert(renderTarget.texture.format);var glType=utils.convert(renderTarget.texture.type);state.texImage2D(textureTarget,0,glFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,attachment,textureTarget,properties.get(renderTarget.texture).__webglTexture,0);_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
function setupRenderBufferStorage(renderbuffer,renderTarget){_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_COMPONENT16,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_STENCIL,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);}else{// FIXME: We don't support !depth !stencil
_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.RGBA4,renderTarget.width,renderTarget.height);}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
function setupDepthTexture(framebuffer,renderTarget){var isCube=renderTarget&&renderTarget.isWebGLRenderTargetCube;if(isCube)throw new Error('Depth Texture with cube render targets is not supported');_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}// upload an empty depth texture with framebuffer size
if(!properties.get(renderTarget.depthTexture).__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);var webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;if(renderTarget.depthTexture.format===DepthFormat){_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}else if(renderTarget.depthTexture.format===DepthStencilFormat){_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);}else{throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
function setupDepthRenderbuffer(renderTarget){var renderTargetProperties=properties.get(renderTarget);var isCube=renderTarget.isWebGLRenderTargetCube===true;if(renderTarget.depthTexture){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}else{if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(var i=0;i<6;i++){_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[i]);renderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget);}}else{_gl.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget);}}_gl.bindFramebuffer(_gl.FRAMEBUFFER,null);}// Set up GL resources for the render target
function setupRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);textureProperties.__webglTexture=_gl.createTexture();infoMemory.textures++;var isCube=renderTarget.isWebGLRenderTargetCube===true;var isTargetPowerOfTwo=isPowerOfTwo(renderTarget);// Setup framebuffer
if(isCube){renderTargetProperties.__webglFramebuffer=[];for(var i=0;i<6;i++){renderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();}}else{renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();}// Setup color buffer
if(isCube){state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_CUBE_MAP,renderTarget.texture,isTargetPowerOfTwo);for(var i=0;i<6;i++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i],renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i);}if(textureNeedsGenerateMipmaps(renderTarget.texture,isTargetPowerOfTwo))_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);state.bindTexture(_gl.TEXTURE_CUBE_MAP,null);}else{state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_2D,renderTarget.texture,isTargetPowerOfTwo);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D);if(textureNeedsGenerateMipmaps(renderTarget.texture,isTargetPowerOfTwo))_gl.generateMipmap(_gl.TEXTURE_2D);state.bindTexture(_gl.TEXTURE_2D,null);}// Setup depth and stencil buffers
if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){var texture=renderTarget.texture;var isTargetPowerOfTwo=isPowerOfTwo(renderTarget);if(textureNeedsGenerateMipmaps(texture,isTargetPowerOfTwo)){var target=renderTarget.isWebGLRenderTargetCube?_gl.TEXTURE_CUBE_MAP:_gl.TEXTURE_2D;var webglTexture=properties.get(texture).__webglTexture;state.bindTexture(target,webglTexture);_gl.generateMipmap(target);state.bindTexture(target,null);}}this.setTexture2D=setTexture2D;this.setTextureCube=setTextureCube;this.setTextureCubeDynamic=setTextureCubeDynamic;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;}/**
	 * @author fordacious / fordacious.github.io
	 */function WebGLProperties(){var properties={};function get(object){var uuid=object.uuid;var map=properties[uuid];if(map===undefined){map={};properties[uuid]=map;}return map;}function remove(object){delete properties[object.uuid];}function clear(){properties={};}return{get:get,remove:remove,clear:clear};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLState(gl,extensions,utils){function ColorBuffer(){var locked=false;var color=new Vector4();var currentColorMask=null;var currentColorClear=new Vector4(0,0,0,0);return{setMask:function setMask(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function reset(){locked=false;currentColorMask=null;currentColorClear.set(-1,0,0,0);// set to invalid state
}};}function DepthBuffer(){var locked=false;var currentDepthMask=null;var currentDepthFunc=null;var currentDepthClear=null;return{setTest:function setTest(depthTest){if(depthTest){enable(gl.DEPTH_TEST);}else{disable(gl.DEPTH_TEST);}},setMask:function setMask(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function setFunc(depthFunc){if(currentDepthFunc!==depthFunc){if(depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(gl.NEVER);break;case AlwaysDepth:gl.depthFunc(gl.ALWAYS);break;case LessDepth:gl.depthFunc(gl.LESS);break;case LessEqualDepth:gl.depthFunc(gl.LEQUAL);break;case EqualDepth:gl.depthFunc(gl.EQUAL);break;case GreaterEqualDepth:gl.depthFunc(gl.GEQUAL);break;case GreaterDepth:gl.depthFunc(gl.GREATER);break;case NotEqualDepth:gl.depthFunc(gl.NOTEQUAL);break;default:gl.depthFunc(gl.LEQUAL);}}else{gl.depthFunc(gl.LEQUAL);}currentDepthFunc=depthFunc;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(depth){if(currentDepthClear!==depth){gl.clearDepth(depth);currentDepthClear=depth;}},reset:function reset(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;}};}function StencilBuffer(){var locked=false;var currentStencilMask=null;var currentStencilFunc=null;var currentStencilRef=null;var currentStencilFuncMask=null;var currentStencilFail=null;var currentStencilZFail=null;var currentStencilZPass=null;var currentStencilClear=null;return{setTest:function setTest(stencilTest){if(stencilTest){enable(gl.STENCIL_TEST);}else{disable(gl.STENCIL_TEST);}},setMask:function setMask(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function setFunc(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function setOp(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function reset(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
var colorBuffer=new ColorBuffer();var depthBuffer=new DepthBuffer();var stencilBuffer=new StencilBuffer();var maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);var newAttributes=new Uint8Array(maxVertexAttributes);var enabledAttributes=new Uint8Array(maxVertexAttributes);var attributeDivisors=new Uint8Array(maxVertexAttributes);var capabilities={};var compressedTextureFormats=null;var currentProgram=null;var currentBlending=null;var currentBlendEquation=null;var currentBlendSrc=null;var currentBlendDst=null;var currentBlendEquationAlpha=null;var currentBlendSrcAlpha=null;var currentBlendDstAlpha=null;var currentPremultipledAlpha=false;var currentFlipSided=null;var currentCullFace=null;var currentLineWidth=null;var currentPolygonOffsetFactor=null;var currentPolygonOffsetUnits=null;var maxTextures=gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);//var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
//var lineWidthAvailable = parseFloat( version ) >= 1.0;
var version='1.0';var lineWidthAvailable=true;var currentTextureSlot=null;var currentBoundTextures={};var currentScissor=new Vector4();var currentViewport=new Vector4();function createTexture(type,target,count){var data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
var texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(type,gl.TEXTURE_MAG_FILTER,gl.NEAREST);for(var i=0;i<count;i++){gl.texImage2D(target+i,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,data);}return texture;}var emptyTextures={};emptyTextures[gl.TEXTURE_2D]=createTexture(gl.TEXTURE_2D,gl.TEXTURE_2D,1);emptyTextures[gl.TEXTURE_CUBE_MAP]=createTexture(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_CUBE_MAP_POSITIVE_X,6);// init
colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(gl.DEPTH_TEST);depthBuffer.setFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(gl.CULL_FACE);enable(gl.BLEND);setBlending(NormalBlending);//
function initAttributes(){for(var i=0,l=newAttributes.length;i<l;i++){newAttributes[i]=0;}}function enableAttribute(attribute){newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==0){var extension=extensions.get('ANGLE_instanced_arrays');extension.vertexAttribDivisorANGLE(attribute,0);attributeDivisors[attribute]=0;}}function enableAttributeAndDivisor(attribute,meshPerAttribute){newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){var extension=extensions.get('ANGLE_instanced_arrays');extension.vertexAttribDivisorANGLE(attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){for(var i=0,l=enabledAttributes.length;i!==l;++i){if(enabledAttributes[i]!==newAttributes[i]){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}}function enable(id){if(capabilities[id]!==true){gl.enable(id);capabilities[id]=true;}}function disable(id){if(capabilities[id]!==false){gl.disable(id);capabilities[id]=false;}}function getCompressedTextureFormats(){if(compressedTextureFormats===null){compressedTextureFormats=[];if(extensions.get('WEBGL_compressed_texture_pvrtc')||extensions.get('WEBGL_compressed_texture_s3tc')||extensions.get('WEBGL_compressed_texture_etc1')){var formats=gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);for(var i=0;i<formats.length;i++){compressedTextureFormats.push(formats[i]);}}}return compressedTextureFormats;}function useProgram(program){if(currentProgram!==program){gl.useProgram(program);currentProgram=program;return true;}return false;}function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){if(blending!==NoBlending){enable(gl.BLEND);}else{disable(gl.BLEND);}if(blending!==CustomBlending){if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){switch(blending){case AdditiveBlending:if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ONE,gl.ONE,gl.ONE,gl.ONE);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.SRC_ALPHA,gl.ONE);}break;case SubtractiveBlending:if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ZERO,gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ZERO,gl.ONE_MINUS_SRC_COLOR);}break;case MultiplyBlending:if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ZERO,gl.SRC_COLOR,gl.ZERO,gl.SRC_ALPHA);}else{gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ZERO,gl.SRC_COLOR);}break;default:if(premultipliedAlpha){gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}else{gl.blendEquationSeparate(gl.FUNC_ADD,gl.FUNC_ADD);gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);}}}currentBlendEquation=null;currentBlendSrc=null;currentBlendDst=null;currentBlendEquationAlpha=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;}else{blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(utils.convert(blendEquation),utils.convert(blendEquationAlpha));currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(utils.convert(blendSrc),utils.convert(blendDst),utils.convert(blendSrcAlpha),utils.convert(blendDstAlpha));currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}}currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}function setMaterial(material){material.side===DoubleSide?disable(gl.CULL_FACE):enable(gl.CULL_FACE);setFlipSided(material.side===BackSide);material.transparent===true?setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha):setBlending(NoBlending);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);}//
function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(gl.CW);}else{gl.frontFace(gl.CCW);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(gl.CULL_FACE);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(gl.BACK);}else if(cullFace===CullFaceFront){gl.cullFace(gl.FRONT);}else{gl.cullFace(gl.FRONT_AND_BACK);}}}else{disable(gl.CULL_FACE);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(gl.POLYGON_OFFSET_FILL);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else{disable(gl.POLYGON_OFFSET_FILL);}}function setScissorTest(scissorTest){if(scissorTest){enable(gl.SCISSOR_TEST);}else{disable(gl.SCISSOR_TEST);}}// texture
function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=gl.TEXTURE0+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture){if(currentTextureSlot===null){activeTexture();}var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[currentTextureSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}//
function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}//
function reset(){for(var i=0;i<enabledAttributes.length;i++){if(enabledAttributes[i]===1){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}capabilities={};compressedTextureFormats=null;currentTextureSlot=null;currentBoundTextures={};currentProgram=null;currentBlending=null;currentFlipSided=null;currentCullFace=null;colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return{buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},initAttributes:initAttributes,enableAttribute:enableAttribute,enableAttributeAndDivisor:enableAttributeAndDivisor,disableUnusedAttributes:disableUnusedAttributes,enable:enable,disable:disable,getCompressedTextureFormats:getCompressedTextureFormats,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,scissor:scissor,viewport:viewport,reset:reset};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLCapabilities(gl,extensions,parameters){var maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;var extension=extensions.get('EXT_texture_filter_anisotropic');if(extension!==null){maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else{maxAnisotropy=0;}return maxAnisotropy;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0){return'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0){return'mediump';}}return'lowp';}var precision=parameters.precision!==undefined?parameters.precision:'highp';var maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){console.warn('THREE.WebGLRenderer:',precision,'not supported, using',maxPrecision,'instead.');precision=maxPrecision;}var logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true;var maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);var maxVertexTextures=gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);var maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE);var maxCubemapSize=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);var maxAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS);var maxVertexUniforms=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);var maxVaryings=gl.getParameter(gl.MAX_VARYING_VECTORS);var maxFragmentUniforms=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);var vertexTextures=maxVertexTextures>0;var floatFragmentTextures=!!extensions.get('OES_texture_float');var floatVertexTextures=vertexTextures&&floatFragmentTextures;return{getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,floatFragmentTextures:floatFragmentTextures,floatVertexTextures:floatVertexTextures};}/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */function PerspectiveCamera(fov,aspect,near,far){Camera.call(this);this.type='PerspectiveCamera';this.fov=fov!==undefined?fov:50;this.zoom=1;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.focus=10;this.aspect=aspect!==undefined?aspect:1;this.view=null;this.filmGauge=35;// width of the film (default in millimeters)
this.filmOffset=0;// horizontal film offset (same unit as gauge)
this.updateProjectionMatrix();}PerspectiveCamera.prototype=Object.assign(Object.create(Camera.prototype),{constructor:PerspectiveCamera,isPerspectiveCamera:true,copy:function copy(source,recursive){Camera.prototype.copy.call(this,source,recursive);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:Object.assign({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;},/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */setFocalLength:function setFocalLength(focalLength){// see http://www.bobatkins.com/photography/technical/field_of_view.html
var vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=_Math.RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();},/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */getFocalLength:function getFocalLength(){var vExtentSlope=Math.tan(_Math.DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;},getEffectiveFOV:function getEffectiveFOV(){return _Math.RAD2DEG*2*Math.atan(Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom);},getFilmWidth:function getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
return this.filmGauge*Math.min(this.aspect,1);},getFilmHeight:function getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
return this.filmGauge/Math.max(this.aspect,1);},/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */setViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();},clearViewOffset:function clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();},updateProjectionMatrix:function updateProjectionMatrix(){var near=this.near,top=near*Math.tan(_Math.DEG2RAD*0.5*this.fov)/this.zoom,height=2*top,width=this.aspect*height,left=-0.5*width,view=this.view;if(this.view!==null&&this.view.enabled){var fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}var skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=Object.assign({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function ArrayCamera(array){PerspectiveCamera.call(this);this.cameras=array||[];}ArrayCamera.prototype=Object.assign(Object.create(PerspectiveCamera.prototype),{constructor:ArrayCamera,isArrayCamera:true});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebVRManager(renderer){var scope=this;var device=null;var frameData=null;if(typeof window!=='undefined'&&'VRFrameData'in window){frameData=new window.VRFrameData();}var matrixWorldInverse=new Matrix4();var standingMatrix=new Matrix4();var standingMatrixInverse=new Matrix4();var cameraL=new PerspectiveCamera();cameraL.bounds=new Vector4(0.0,0.0,0.5,1.0);cameraL.layers.enable(1);var cameraR=new PerspectiveCamera();cameraR.bounds=new Vector4(0.5,0.0,0.5,1.0);cameraR.layers.enable(2);var cameraVR=new ArrayCamera([cameraL,cameraR]);cameraVR.layers.enable(1);cameraVR.layers.enable(2);//
var currentSize,currentPixelRatio;function onVRDisplayPresentChange(){if(device!==null&&device.isPresenting){var eyeParameters=device.getEyeParameters('left');var renderWidth=eyeParameters.renderWidth;var renderHeight=eyeParameters.renderHeight;currentPixelRatio=renderer.getPixelRatio();currentSize=renderer.getSize();renderer.setDrawingBufferSize(renderWidth*2,renderHeight,1);}else if(scope.enabled){renderer.setDrawingBufferSize(currentSize.width,currentSize.height,currentPixelRatio);}}if(typeof window!=='undefined'){window.addEventListener('vrdisplaypresentchange',onVRDisplayPresentChange,false);}//
this.enabled=false;this.standing=false;this.getDevice=function(){return device;};this.setDevice=function(value){if(value!==undefined)device=value;};this.getCamera=function(camera){if(device===null)return camera;device.depthNear=camera.near;device.depthFar=camera.far;device.getFrameData(frameData);//
var pose=frameData.pose;if(pose.position!==null){camera.position.fromArray(pose.position);}else{camera.position.set(0,0,0);}if(pose.orientation!==null){camera.quaternion.fromArray(pose.orientation);}camera.updateMatrixWorld();var stageParameters=device.stageParameters;if(this.standing&&stageParameters){standingMatrix.fromArray(stageParameters.sittingToStandingTransform);standingMatrixInverse.getInverse(standingMatrix);camera.matrixWorld.multiply(standingMatrix);camera.matrixWorldInverse.multiply(standingMatrixInverse);}if(device.isPresenting===false)return camera;//
cameraL.near=camera.near;cameraR.near=camera.near;cameraL.far=camera.far;cameraR.far=camera.far;cameraVR.matrixWorld.copy(camera.matrixWorld);cameraVR.matrixWorldInverse.copy(camera.matrixWorldInverse);cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);if(this.standing&&stageParameters){cameraL.matrixWorldInverse.multiply(standingMatrixInverse);cameraR.matrixWorldInverse.multiply(standingMatrixInverse);}var parent=camera.parent;if(parent!==null){matrixWorldInverse.getInverse(parent.matrixWorld);cameraL.matrixWorldInverse.multiply(matrixWorldInverse);cameraR.matrixWorldInverse.multiply(matrixWorldInverse);}// envMap and Mirror needs camera.matrixWorld
cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);// HACK @mrdoob
// https://github.com/w3c/webvr/issues/203
cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);//
var layers=device.getLayers();if(layers.length){var layer=layers[0];if(layer.leftBounds!==null&&layer.leftBounds.length===4){cameraL.bounds.fromArray(layer.leftBounds);}if(layer.rightBounds!==null&&layer.rightBounds.length===4){cameraR.bounds.fromArray(layer.rightBounds);}}return cameraVR;};this.getStandingMatrix=function(){return standingMatrix;};this.submitFrame=function(){if(device&&device.isPresenting)device.submitFrame();};this.dispose=function(){window.removeEventListener('vrdisplaypresentchange',onVRDisplayPresentChange);};}/**
	 * @author mrdoob / http://mrdoob.com/
	 */function WebGLExtensions(gl){var extensions={};return{get:function get(name){if(extensions[name]!==undefined){return extensions[name];}var extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;case'WEBGL_compressed_texture_etc1':extension=gl.getExtension('WEBGL_compressed_texture_etc1');break;default:extension=gl.getExtension(name);}if(extension===null){console.warn('THREE.WebGLRenderer: '+name+' extension not supported.');}extensions[name]=extension;return extension;}};}/**
	 * @author tschw
	 */function WebGLClipping(){var scope=this,globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false,plane=new Plane(),viewNormalMatrix=new Matrix3(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping,camera){var enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
// run another frame in order to reset the state:
numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;globalState=projectPlanes(planes,camera,0);numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;resetGlobalState();};this.setState=function(planes,clipIntersection,clipShadows,camera,cache,fromCache){if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
if(renderingShadows){// there's no global clipping
projectPlanes(null);}else{resetGlobalState();}}else{var nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4,dstArray=cache.clippingState||null;uniform.value=dstArray;// ensure unique state
dstArray=projectPlanes(planes,camera,lGlobal,fromCache);for(var i=0;i!==lGlobal;++i){dstArray[i]=globalState[i];}cache.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){var nPlanes=planes!==null?planes.length:0,dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){var flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(var i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4){plane.copy(planes[i]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;return dstArray;}}/**
	 * @author thespite / http://www.twitter.com/thespite
	 */function WebGLUtils(gl,extensions){function convert(p){var extension;if(p===RepeatWrapping)return gl.REPEAT;if(p===ClampToEdgeWrapping)return gl.CLAMP_TO_EDGE;if(p===MirroredRepeatWrapping)return gl.MIRRORED_REPEAT;if(p===NearestFilter)return gl.NEAREST;if(p===NearestMipMapNearestFilter)return gl.NEAREST_MIPMAP_NEAREST;if(p===NearestMipMapLinearFilter)return gl.NEAREST_MIPMAP_LINEAR;if(p===LinearFilter)return gl.LINEAR;if(p===LinearMipMapNearestFilter)return gl.LINEAR_MIPMAP_NEAREST;if(p===LinearMipMapLinearFilter)return gl.LINEAR_MIPMAP_LINEAR;if(p===UnsignedByteType)return gl.UNSIGNED_BYTE;if(p===UnsignedShort4444Type)return gl.UNSIGNED_SHORT_4_4_4_4;if(p===UnsignedShort5551Type)return gl.UNSIGNED_SHORT_5_5_5_1;if(p===UnsignedShort565Type)return gl.UNSIGNED_SHORT_5_6_5;if(p===ByteType)return gl.BYTE;if(p===ShortType)return gl.SHORT;if(p===UnsignedShortType)return gl.UNSIGNED_SHORT;if(p===IntType)return gl.INT;if(p===UnsignedIntType)return gl.UNSIGNED_INT;if(p===FloatType)return gl.FLOAT;if(p===HalfFloatType){extension=extensions.get('OES_texture_half_float');if(extension!==null)return extension.HALF_FLOAT_OES;}if(p===AlphaFormat)return gl.ALPHA;if(p===RGBFormat)return gl.RGB;if(p===RGBAFormat)return gl.RGBA;if(p===LuminanceFormat)return gl.LUMINANCE;if(p===LuminanceAlphaFormat)return gl.LUMINANCE_ALPHA;if(p===DepthFormat)return gl.DEPTH_COMPONENT;if(p===DepthStencilFormat)return gl.DEPTH_STENCIL;if(p===AddEquation)return gl.FUNC_ADD;if(p===SubtractEquation)return gl.FUNC_SUBTRACT;if(p===ReverseSubtractEquation)return gl.FUNC_REVERSE_SUBTRACT;if(p===ZeroFactor)return gl.ZERO;if(p===OneFactor)return gl.ONE;if(p===SrcColorFactor)return gl.SRC_COLOR;if(p===OneMinusSrcColorFactor)return gl.ONE_MINUS_SRC_COLOR;if(p===SrcAlphaFactor)return gl.SRC_ALPHA;if(p===OneMinusSrcAlphaFactor)return gl.ONE_MINUS_SRC_ALPHA;if(p===DstAlphaFactor)return gl.DST_ALPHA;if(p===OneMinusDstAlphaFactor)return gl.ONE_MINUS_DST_ALPHA;if(p===DstColorFactor)return gl.DST_COLOR;if(p===OneMinusDstColorFactor)return gl.ONE_MINUS_DST_COLOR;if(p===SrcAlphaSaturateFactor)return gl.SRC_ALPHA_SATURATE;if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}}if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}}if(p===RGB_ETC1_Format){extension=extensions.get('WEBGL_compressed_texture_etc1');if(extension!==null)return extension.COMPRESSED_RGB_ETC1_WEBGL;}if(p===MinEquation||p===MaxEquation){extension=extensions.get('EXT_blend_minmax');if(extension!==null){if(p===MinEquation)return extension.MIN_EXT;if(p===MaxEquation)return extension.MAX_EXT;}}if(p===UnsignedInt248Type){extension=extensions.get('WEBGL_depth_texture');if(extension!==null)return extension.UNSIGNED_INT_24_8_WEBGL;}return 0;}return{convert:convert};}/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */function WebGLRenderer(parameters){console.log('THREE.WebGLRenderer',REVISION);parameters=parameters||{};var _canvas=parameters.canvas!==undefined?parameters.canvas:document.createElement('canvas'),_context=parameters.context!==undefined?parameters.context:null,_alpha=parameters.alpha!==undefined?parameters.alpha:false,_depth=parameters.depth!==undefined?parameters.depth:true,_stencil=parameters.stencil!==undefined?parameters.stencil:true,_antialias=parameters.antialias!==undefined?parameters.antialias:false,_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false;var lightsArray=[];var shadowsArray=[];var currentRenderList=null;var spritesArray=[];var flaresArray=[];// public properties
this.domElement=_canvas;this.context=null;// clearing
this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;// scene graph
this.sortObjects=true;// user-defined clipping
this.clippingPlanes=[];this.localClippingEnabled=false;// physically based shading
this.gammaFactor=2.0;// for backwards compatibility
this.gammaInput=false;this.gammaOutput=false;// physical lights
this.physicallyCorrectLights=false;// tone mapping
this.toneMapping=LinearToneMapping;this.toneMappingExposure=1.0;this.toneMappingWhitePoint=1.0;// morphs
this.maxMorphTargets=8;this.maxMorphNormals=4;// internal properties
var _this=this,_isContextLost=false,// internal state cache
_currentRenderTarget=null,_currentFramebuffer=null,_currentMaterialId=-1,_currentGeometryProgram='',_currentCamera=null,_currentArrayCamera=null,_currentViewport=new Vector4(),_currentScissor=new Vector4(),_currentScissorTest=null,//
_usedTextureUnits=0,//
_width=_canvas.width,_height=_canvas.height,_pixelRatio=1,_viewport=new Vector4(0,0,_width,_height),_scissor=new Vector4(0,0,_width,_height),_scissorTest=false,// frustum
_frustum=new Frustum(),// clipping
_clipping=new WebGLClipping(),_clippingEnabled=false,_localClippingEnabled=false,// camera matrices cache
_projScreenMatrix=new Matrix4(),_vector3=new Vector3(),// info
_infoMemory={geometries:0,textures:0},_infoRender={frame:0,calls:0,vertices:0,faces:0,points:0};this.info={render:_infoRender,memory:_infoMemory,programs:null};function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}// initialize
var _gl;try{var contextAttributes={alpha:_alpha,depth:_depth,stencil:_stencil,antialias:_antialias,premultipliedAlpha:_premultipliedAlpha,preserveDrawingBuffer:_preserveDrawingBuffer};_gl=_context||_canvas.getContext('webgl',contextAttributes)||_canvas.getContext('experimental-webgl',contextAttributes);if(_gl===null){if(_canvas.getContext('webgl')!==null){throw'Error creating WebGL context with your selected attributes.';}else{throw'Error creating WebGL context.';}}// Some experimental-webgl implementations do not have getShaderPrecisionFormat
if(_gl.getShaderPrecisionFormat===undefined){_gl.getShaderPrecisionFormat=function(){return{'rangeMin':1,'rangeMax':1,'precision':1};};}_canvas.addEventListener('webglcontextlost',onContextLost,false);_canvas.addEventListener('webglcontextrestored',onContextRestore,false);}catch(error){console.error('THREE.WebGLRenderer: '+error);}var extensions,capabilities,state;var properties,textures,attributes,geometries,objects,lights;var programCache,renderLists;var background,morphtargets,bufferRenderer,indexedBufferRenderer;var flareRenderer,spriteRenderer;var utils;function initGLContext(){extensions=new WebGLExtensions(_gl);extensions.get('WEBGL_depth_texture');extensions.get('OES_texture_float');extensions.get('OES_texture_float_linear');extensions.get('OES_texture_half_float');extensions.get('OES_texture_half_float_linear');extensions.get('OES_standard_derivatives');extensions.get('OES_element_index_uint');extensions.get('ANGLE_instanced_arrays');utils=new WebGLUtils(_gl,extensions);capabilities=new WebGLCapabilities(_gl,extensions,parameters);state=new WebGLState(_gl,extensions,utils);state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));properties=new WebGLProperties();textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,utils,_infoMemory);attributes=new WebGLAttributes(_gl);geometries=new WebGLGeometries(_gl,attributes,_infoMemory);objects=new WebGLObjects(geometries,_infoRender);morphtargets=new WebGLMorphtargets(_gl);programCache=new WebGLPrograms(_this,extensions,capabilities);lights=new WebGLLights();renderLists=new WebGLRenderLists();background=new WebGLBackground(_this,state,geometries,_premultipliedAlpha);bufferRenderer=new WebGLBufferRenderer(_gl,extensions,_infoRender);indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,_infoRender);flareRenderer=new WebGLFlareRenderer(_this,_gl,state,textures,capabilities);spriteRenderer=new WebGLSpriteRenderer(_this,_gl,state,textures,capabilities);_this.info.programs=programCache.programs;_this.context=_gl;_this.capabilities=capabilities;_this.extensions=extensions;_this.properties=properties;_this.renderLists=renderLists;_this.state=state;}initGLContext();// vr
var vr=new WebVRManager(_this);this.vr=vr;// shadow map
var shadowMap=new WebGLShadowMap(_this,objects,capabilities.maxTextureSize);this.shadowMap=shadowMap;// API
this.getContext=function(){return _gl;};this.getContextAttributes=function(){return _gl.getContextAttributes();};this.forceContextLoss=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.loseContext();};this.forceContextRestore=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.restoreContext();};this.getPixelRatio=function(){return _pixelRatio;};this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_width,_height,false);};this.getSize=function(){return{width:_width,height:_height};};this.setSize=function(width,height,updateStyle){var device=vr.getDevice();if(device&&device.isPresenting){console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');return;}_width=width;_height=height;_canvas.width=width*_pixelRatio;_canvas.height=height*_pixelRatio;if(updateStyle!==false){_canvas.style.width=width+'px';_canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};this.getDrawingBufferSize=function(){return{width:_width*_pixelRatio,height:_height*_pixelRatio};};this.setDrawingBufferSize=function(width,height,pixelRatio){_width=width;_height=height;_pixelRatio=pixelRatio;_canvas.width=width*pixelRatio;_canvas.height=height*pixelRatio;this.setViewport(0,0,width,height);};this.setViewport=function(x,y,width,height){_viewport.set(x,_height-y-height,width,height);state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));};this.setScissor=function(x,y,width,height){_scissor.set(x,_height-y-height,width,height);state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));};this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean);};// Clearing
this.getClearColor=function(){return background.getClearColor();};this.setClearColor=function(){background.setClearColor.apply(background,arguments);};this.getClearAlpha=function(){return background.getClearAlpha();};this.setClearAlpha=function(){background.setClearAlpha.apply(background,arguments);};this.clear=function(color,depth,stencil){var bits=0;if(color===undefined||color)bits|=_gl.COLOR_BUFFER_BIT;if(depth===undefined||depth)bits|=_gl.DEPTH_BUFFER_BIT;if(stencil===undefined||stencil)bits|=_gl.STENCIL_BUFFER_BIT;_gl.clear(bits);};this.clearColor=function(){this.clear(true,false,false);};this.clearDepth=function(){this.clear(false,true,false);};this.clearStencil=function(){this.clear(false,false,true);};this.clearTarget=function(renderTarget,color,depth,stencil){this.setRenderTarget(renderTarget);this.clear(color,depth,stencil);};//
this.dispose=function(){_canvas.removeEventListener('webglcontextlost',onContextLost,false);_canvas.removeEventListener('webglcontextrestored',onContextRestore,false);renderLists.dispose();vr.dispose();};// Events
function onContextLost(event){event.preventDefault();console.log('THREE.WebGLRenderer: Context Lost.');_isContextLost=true;}function onContextRestore()/* event */{console.log('THREE.WebGLRenderer: Context Restored.');_isContextLost=false;initGLContext();}function onMaterialDispose(event){var material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
function deallocateMaterial(material){releaseMaterialProgramReference(material);properties.remove(material);}function releaseMaterialProgramReference(material){var programInfo=properties.get(material).program;material.program=undefined;if(programInfo!==undefined){programCache.releaseProgram(programInfo);}}// Buffer rendering
function renderObjectImmediate(object,program,material){object.render(function(object){_this.renderBufferImmediate(object,program,material);});}this.renderBufferImmediate=function(object,program,material){state.initAttributes();var buffers=properties.get(object);if(object.hasPositions&&!buffers.position)buffers.position=_gl.createBuffer();if(object.hasNormals&&!buffers.normal)buffers.normal=_gl.createBuffer();if(object.hasUvs&&!buffers.uv)buffers.uv=_gl.createBuffer();if(object.hasColors&&!buffers.color)buffers.color=_gl.createBuffer();var programAttributes=program.getAttributes();if(object.hasPositions){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.position);_gl.bufferData(_gl.ARRAY_BUFFER,object.positionArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.position);_gl.vertexAttribPointer(programAttributes.position,3,_gl.FLOAT,false,0,0);}if(object.hasNormals){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.normal);if(!material.isMeshPhongMaterial&&!material.isMeshStandardMaterial&&!material.isMeshNormalMaterial&&material.flatShading===true){for(var i=0,l=object.count*3;i<l;i+=9){var array=object.normalArray;var nx=(array[i+0]+array[i+3]+array[i+6])/3;var ny=(array[i+1]+array[i+4]+array[i+7])/3;var nz=(array[i+2]+array[i+5]+array[i+8])/3;array[i+0]=nx;array[i+1]=ny;array[i+2]=nz;array[i+3]=nx;array[i+4]=ny;array[i+5]=nz;array[i+6]=nx;array[i+7]=ny;array[i+8]=nz;}}_gl.bufferData(_gl.ARRAY_BUFFER,object.normalArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.normal);_gl.vertexAttribPointer(programAttributes.normal,3,_gl.FLOAT,false,0,0);}if(object.hasUvs&&material.map){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.uv);_gl.bufferData(_gl.ARRAY_BUFFER,object.uvArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.uv);_gl.vertexAttribPointer(programAttributes.uv,2,_gl.FLOAT,false,0,0);}if(object.hasColors&&material.vertexColors!==NoColors){_gl.bindBuffer(_gl.ARRAY_BUFFER,buffers.color);_gl.bufferData(_gl.ARRAY_BUFFER,object.colorArray,_gl.DYNAMIC_DRAW);state.enableAttribute(programAttributes.color);_gl.vertexAttribPointer(programAttributes.color,3,_gl.FLOAT,false,0,0);}state.disableUnusedAttributes();_gl.drawArrays(_gl.TRIANGLES,0,object.count);object.count=0;};this.renderBufferDirect=function(camera,fog,geometry,material,object,group){state.setMaterial(material);var program=setProgram(camera,fog,material,object);var geometryProgram=geometry.id+'_'+program.id+'_'+(material.wireframe===true);var updateBuffers=false;if(geometryProgram!==_currentGeometryProgram){_currentGeometryProgram=geometryProgram;updateBuffers=true;}if(object.morphTargetInfluences){morphtargets.update(object,geometry,material,program);updateBuffers=true;}//
var index=geometry.index;var position=geometry.attributes.position;var rangeFactor=1;if(material.wireframe===true){index=geometries.getWireframeAttribute(geometry);rangeFactor=2;}var attribute;var renderer=bufferRenderer;if(index!==null){attribute=attributes.get(index);renderer=indexedBufferRenderer;renderer.setIndex(attribute);}if(updateBuffers){setupVertexAttributes(material,program,geometry);if(index!==null){_gl.bindBuffer(_gl.ELEMENT_ARRAY_BUFFER,attribute.buffer);}}//
var dataCount=0;if(index!==null){dataCount=index.count;}else if(position!==undefined){dataCount=position.count;}var rangeStart=geometry.drawRange.start*rangeFactor;var rangeCount=geometry.drawRange.count*rangeFactor;var groupStart=group!==null?group.start*rangeFactor:0;var groupCount=group!==null?group.count*rangeFactor:Infinity;var drawStart=Math.max(rangeStart,groupStart);var drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;var drawCount=Math.max(0,drawEnd-drawStart+1);if(drawCount===0)return;//
if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(_gl.LINES);}else{switch(object.drawMode){case TrianglesDrawMode:renderer.setMode(_gl.TRIANGLES);break;case TriangleStripDrawMode:renderer.setMode(_gl.TRIANGLE_STRIP);break;case TriangleFanDrawMode:renderer.setMode(_gl.TRIANGLE_FAN);break;}}}else if(object.isLine){var lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(_gl.LINES);}else if(object.isLineLoop){renderer.setMode(_gl.LINE_LOOP);}else{renderer.setMode(_gl.LINE_STRIP);}}else if(object.isPoints){renderer.setMode(_gl.POINTS);}if(geometry&&geometry.isInstancedBufferGeometry){if(geometry.maxInstancedCount>0){renderer.renderInstances(geometry,drawStart,drawCount);}}else{renderer.render(drawStart,drawCount);}};function setupVertexAttributes(material,program,geometry,startIndex){if(geometry&&geometry.isInstancedBufferGeometry){if(extensions.get('ANGLE_instanced_arrays')===null){console.error('THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}if(startIndex===undefined)startIndex=0;state.initAttributes();var geometryAttributes=geometry.attributes;var programAttributes=program.getAttributes();var materialDefaultAttributeValues=material.defaultAttributeValues;for(var name in programAttributes){var programAttribute=programAttributes[name];if(programAttribute>=0){var geometryAttribute=geometryAttributes[name];if(geometryAttribute!==undefined){var normalized=geometryAttribute.normalized;var size=geometryAttribute.itemSize;var attribute=attributes.get(geometryAttribute);// TODO Attribute may not be available on context restore
if(attribute===undefined)continue;var buffer=attribute.buffer;var type=attribute.type;var bytesPerElement=attribute.bytesPerElement;if(geometryAttribute.isInterleavedBufferAttribute){var data=geometryAttribute.data;var stride=data.stride;var offset=geometryAttribute.offset;if(data&&data.isInstancedInterleavedBuffer){state.enableAttributeAndDivisor(programAttribute,data.meshPerAttribute);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=data.meshPerAttribute*data.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,stride*bytesPerElement,(startIndex*stride+offset)*bytesPerElement);}else{if(geometryAttribute.isInstancedBufferAttribute){state.enableAttributeAndDivisor(programAttribute,geometryAttribute.meshPerAttribute);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(_gl.ARRAY_BUFFER,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,0,startIndex*size*bytesPerElement);}}else if(materialDefaultAttributeValues!==undefined){var value=materialDefaultAttributeValues[name];if(value!==undefined){switch(value.length){case 2:_gl.vertexAttrib2fv(programAttribute,value);break;case 3:_gl.vertexAttrib3fv(programAttribute,value);break;case 4:_gl.vertexAttrib4fv(programAttribute,value);break;default:_gl.vertexAttrib1fv(programAttribute,value);}}}}}state.disableUnusedAttributes();}// Compile
this.compile=function(scene,camera){lightsArray.length=0;shadowsArray.length=0;scene.traverse(function(object){if(object.isLight){lightsArray.push(object);if(object.castShadow){shadowsArray.push(object);}}});lights.setup(lightsArray,shadowsArray,camera);scene.traverse(function(object){if(object.material){if(Array.isArray(object.material)){for(var i=0;i<object.material.length;i++){initMaterial(object.material[i],scene.fog,object);}}else{initMaterial(object.material,scene.fog,object);}}});};// Animation Loop
var isAnimating=false;var onAnimationFrame=null;function start(){if(isAnimating)return;(vr.getDevice()||window).requestAnimationFrame(loop);isAnimating=true;}function loop(time){if(onAnimationFrame!==null)onAnimationFrame(time);(vr.getDevice()||window).requestAnimationFrame(loop);}this.animate=function(callback){onAnimationFrame=callback;start();};// Rendering
this.render=function(scene,camera,renderTarget,forceClear){if(!(camera&&camera.isCamera)){console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}if(_isContextLost)return;// reset caching for this frame
_currentGeometryProgram='';_currentMaterialId=-1;_currentCamera=null;// update scene graph
if(scene.autoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
if(camera.parent===null)camera.updateMatrixWorld();if(vr.enabled){camera=vr.getCamera(camera);}_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromMatrix(_projScreenMatrix);lightsArray.length=0;shadowsArray.length=0;spritesArray.length=0;flaresArray.length=0;_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=_clipping.init(this.clippingPlanes,_localClippingEnabled,camera);currentRenderList=renderLists.get(scene,camera);currentRenderList.init();projectObject(scene,camera,_this.sortObjects);if(_this.sortObjects===true){currentRenderList.sort();}//
if(_clippingEnabled)_clipping.beginShadows();shadowMap.render(shadowsArray,scene,camera);lights.setup(lightsArray,shadowsArray,camera);if(_clippingEnabled)_clipping.endShadows();//
_infoRender.frame++;_infoRender.calls=0;_infoRender.vertices=0;_infoRender.faces=0;_infoRender.points=0;if(renderTarget===undefined){renderTarget=null;}this.setRenderTarget(renderTarget);//
background.render(currentRenderList,scene,camera,forceClear);// render scene
var opaqueObjects=currentRenderList.opaque;var transparentObjects=currentRenderList.transparent;if(scene.overrideMaterial){var overrideMaterial=scene.overrideMaterial;if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera,overrideMaterial);if(transparentObjects.length)renderObjects(transparentObjects,scene,camera,overrideMaterial);}else{// opaque pass (front-to-back order)
if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera);// transparent pass (back-to-front order)
if(transparentObjects.length)renderObjects(transparentObjects,scene,camera);}// custom renderers
spriteRenderer.render(spritesArray,scene,camera);flareRenderer.render(flaresArray,scene,camera,_currentViewport);// Generate mipmap if we're using any kind of mipmap filtering
if(renderTarget){textures.updateRenderTargetMipmap(renderTarget);}// Ensure depth buffer writing is enabled so it can be cleared on next render
state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);state.setPolygonOffset(false);if(vr.enabled){vr.submitFrame();}// _gl.finish();
};/*
		// TODO Duplicated code (Frustum)

		var _sphere = new Sphere();

		function isObjectViewable( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere ).
			applyMatrix4( object.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSpriteViewable( sprite ) {

			_sphere.center.set( 0, 0, 0 );
			_sphere.radius = 0.7071067811865476;
			_sphere.applyMatrix4( sprite.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSphereViewable( sphere ) {

			if ( ! _frustum.intersectsSphere( sphere ) ) return false;

			var numPlanes = _clipping.numPlanes;

			if ( numPlanes === 0 ) return true;

			var planes = _this.clippingPlanes,

				center = sphere.center,
				negRad = - sphere.radius,
				i = 0;

			do {

				// out when deeper than radius in the negative halfspace
				if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

			} while ( ++ i !== numPlanes );

			return true;

		}
		*/function projectObject(object,camera,sortObjects){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible){if(object.isLight){lightsArray.push(object);if(object.castShadow){shadowsArray.push(object);}}else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){spritesArray.push(object);}}else if(object.isLensFlare){flaresArray.push(object);}else if(object.isImmediateRenderObject){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}currentRenderList.push(object,null,object.material,_vector3.z,null);}else if(object.isMesh||object.isLine||object.isPoints){if(object.isSkinnedMesh){object.skeleton.update();}if(!object.frustumCulled||_frustum.intersectsObject(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var geometry=objects.update(object);var material=object.material;if(Array.isArray(material)){var groups=geometry.groups;for(var i=0,l=groups.length;i<l;i++){var group=groups[i];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){currentRenderList.push(object,geometry,groupMaterial,_vector3.z,group);}}}else if(material.visible){currentRenderList.push(object,geometry,material,_vector3.z,null);}}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){projectObject(children[i],camera,sortObjects);}}function renderObjects(renderList,scene,camera,overrideMaterial){for(var i=0,l=renderList.length;i<l;i++){var renderItem=renderList[i];var object=renderItem.object;var geometry=renderItem.geometry;var material=overrideMaterial===undefined?renderItem.material:overrideMaterial;var group=renderItem.group;if(camera.isArrayCamera){_currentArrayCamera=camera;var cameras=camera.cameras;for(var j=0,jl=cameras.length;j<jl;j++){var camera2=cameras[j];if(object.layers.test(camera2.layers)){var bounds=camera2.bounds;var x=bounds.x*_width;var y=bounds.y*_height;var width=bounds.z*_width;var height=bounds.w*_height;state.viewport(_currentViewport.set(x,y,width,height).multiplyScalar(_pixelRatio));renderObject(object,scene,camera2,geometry,material,group);}}}else{_currentArrayCamera=null;renderObject(object,scene,camera,geometry,material,group);}}}function renderObject(object,scene,camera,geometry,material,group){object.onBeforeRender(_this,scene,camera,geometry,material,group);object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);if(object.isImmediateRenderObject){state.setMaterial(material);var program=setProgram(camera,scene.fog,material,object);_currentGeometryProgram='';renderObjectImmediate(object,program,material);}else{_this.renderBufferDirect(camera,scene.fog,geometry,material,object,group);}object.onAfterRender(_this,scene,camera,geometry,material,group);}function initMaterial(material,fog,object){var materialProperties=properties.get(material);var parameters=programCache.getParameters(material,lights.state,shadowsArray,fog,_clipping.numPlanes,_clipping.numIntersection,object);var code=programCache.getProgramCode(material,parameters);var program=materialProperties.program;var programChange=true;if(program===undefined){// new material
material.addEventListener('dispose',onMaterialDispose);}else if(program.code!==code){// changed glsl or parameters
releaseMaterialProgramReference(material);}else if(parameters.shaderID!==undefined){// same glsl and uniform list
return;}else{// only rebuild uniform list
programChange=false;}if(programChange){if(parameters.shaderID){var shader=ShaderLib[parameters.shaderID];materialProperties.shader={name:material.type,uniforms:UniformsUtils.clone(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader};}else{materialProperties.shader={name:material.type,uniforms:material.uniforms,vertexShader:material.vertexShader,fragmentShader:material.fragmentShader};}material.onBeforeCompile(materialProperties.shader);program=programCache.acquireProgram(material,materialProperties.shader,parameters,code);materialProperties.program=program;material.program=program;}var programAttributes=program.getAttributes();if(material.morphTargets){material.numSupportedMorphTargets=0;for(var i=0;i<_this.maxMorphTargets;i++){if(programAttributes['morphTarget'+i]>=0){material.numSupportedMorphTargets++;}}}if(material.morphNormals){material.numSupportedMorphNormals=0;for(var i=0;i<_this.maxMorphNormals;i++){if(programAttributes['morphNormal'+i]>=0){material.numSupportedMorphNormals++;}}}var uniforms=materialProperties.shader.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){materialProperties.numClippingPlanes=_clipping.numPlanes;materialProperties.numIntersection=_clipping.numIntersection;uniforms.clippingPlanes=_clipping.uniform;}materialProperties.fog=fog;// store the light setup it was created for
materialProperties.lightsHash=lights.state.hash;if(material.lights){// wire up the material to this renderer's lighting state
uniforms.ambientLightColor.value=lights.state.ambient;uniforms.directionalLights.value=lights.state.directional;uniforms.spotLights.value=lights.state.spot;uniforms.rectAreaLights.value=lights.state.rectArea;uniforms.pointLights.value=lights.state.point;uniforms.hemisphereLights.value=lights.state.hemi;uniforms.directionalShadowMap.value=lights.state.directionalShadowMap;uniforms.directionalShadowMatrix.value=lights.state.directionalShadowMatrix;uniforms.spotShadowMap.value=lights.state.spotShadowMap;uniforms.spotShadowMatrix.value=lights.state.spotShadowMatrix;uniforms.pointShadowMap.value=lights.state.pointShadowMap;uniforms.pointShadowMatrix.value=lights.state.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
}var progUniforms=materialProperties.program.getUniforms(),uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,uniforms);materialProperties.uniformsList=uniformsList;}function setProgram(camera,fog,material,object){_usedTextureUnits=0;var materialProperties=properties.get(material);if(_clippingEnabled){if(_localClippingEnabled||camera!==_currentCamera){var useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
// object instead of the material, once it becomes feasible
// (#8465, #8379)
_clipping.setState(material.clippingPlanes,material.clipIntersection,material.clipShadows,camera,materialProperties,useCache);}}if(material.needsUpdate===false){if(materialProperties.program===undefined){material.needsUpdate=true;}else if(material.fog&&materialProperties.fog!==fog){material.needsUpdate=true;}else if(material.lights&&materialProperties.lightsHash!==lights.state.hash){material.needsUpdate=true;}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==_clipping.numPlanes||materialProperties.numIntersection!==_clipping.numIntersection)){material.needsUpdate=true;}}if(material.needsUpdate){initMaterial(material,fog,object);material.needsUpdate=false;}var refreshProgram=false;var refreshMaterial=false;var refreshLights=false;var program=materialProperties.program,p_uniforms=program.getUniforms(),m_uniforms=materialProperties.shader.uniforms;if(state.useProgram(program.program)){refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||camera!==_currentCamera){p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}// Avoid unneeded uniform updates per ArrayCamera's sub-camera
if(_currentCamera!==(_currentArrayCamera||camera)){_currentCamera=_currentArrayCamera||camera;// lighting uniforms depend on the camera so enforce an update
// now, in case this material supports lights - or later, when
// the next material that does gets activated:
refreshMaterial=true;// set to true on material change
refreshLights=true;// remains set until update done
}// load material specific uniforms
// (shader material also gets them for the sake of genericity)
if(material.isShaderMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.envMap){var uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}}if(material.isMeshPhongMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial||material.skinning){p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);}}// skinning uniforms must be set even if material didn't change
// auto-setting of texture unit for bone texture must go before other textures
// not sure why, but otherwise weird things happen
if(material.skinning){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');var skeleton=object.skeleton;if(skeleton){var bones=skeleton.bones;if(capabilities.floatVertexTextures){if(skeleton.boneTexture===undefined){// layout (1 matrix = 4 pixels)
//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
var size=Math.sqrt(bones.length*4);// 4 pixels needed for 1 matrix
size=_Math.ceilPowerOfTwo(size);size=Math.max(size,4);var boneMatrices=new Float32Array(size*size*4);// 4 floats per RGBA pixel
boneMatrices.set(skeleton.boneMatrices);// copy current values
var boneTexture=new DataTexture(boneMatrices,size,size,RGBAFormat,FloatType);skeleton.boneMatrices=boneMatrices;skeleton.boneTexture=boneTexture;skeleton.boneTextureSize=size;}p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture);p_uniforms.setValue(_gl,'boneTextureSize',skeleton.boneTextureSize);}else{p_uniforms.setOptional(_gl,skeleton,'boneMatrices');}}}if(refreshMaterial){p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);p_uniforms.setValue(_gl,'toneMappingWhitePoint',_this.toneMappingWhitePoint);if(material.lights){// the current material requires lighting info
// note: all lighting uniforms are always set correctly
// they simply reference the renderer's state for their
// values
//
// use the current material's .needsUpdate flags to set
// the GL state when required
markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
if(fog&&material.fog){refreshUniformsFog(m_uniforms,fog);}if(material.isMeshBasicMaterial){refreshUniformsCommon(m_uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsLambert(m_uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsCommon(m_uniforms,material);if(material.isMeshToonMaterial){refreshUniformsToon(m_uniforms,material);}else{refreshUniformsPhong(m_uniforms,material);}}else if(material.isMeshStandardMaterial){refreshUniformsCommon(m_uniforms,material);if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(m_uniforms,material);}else{refreshUniformsStandard(m_uniforms,material);}}else if(material.isMeshDepthMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsDepth(m_uniforms,material);}else if(material.isMeshDistanceMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsDistance(m_uniforms,material);}else if(material.isMeshNormalMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsNormal(m_uniforms,material);}else if(material.isLineBasicMaterial){refreshUniformsLine(m_uniforms,material);if(material.isLineDashedMaterial){refreshUniformsDash(m_uniforms,material);}}else if(material.isPointsMaterial){refreshUniformsPoints(m_uniforms,material);}else if(material.isShadowMaterial){m_uniforms.color.value=material.color;m_uniforms.opacity.value=material.opacity;}// RectAreaLight Texture
// TODO (mrdoob): Find a nicer implementation
if(m_uniforms.ltcMat!==undefined)m_uniforms.ltcMat.value=UniformsLib.LTC_MAT_TEXTURE;if(m_uniforms.ltcMag!==undefined)m_uniforms.ltcMag.value=UniformsLib.LTC_MAG_TEXTURE;WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,_this);}// common matrices
p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);return program;}// Uniforms (refresh uniforms objects)
function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;if(material.color){uniforms.diffuse.value=material.color;}if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.specularMap){uniforms.specularMap.value=material.specularMap;}if(material.envMap){uniforms.envMap.value=material.envMap;// don't flip CubeTexture envMaps, flip everything else:
//  WebGLRenderTargetCube will be flipped for backwards compatibility
//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
uniforms.flipEnvMap.value=!(material.envMap&&material.envMap.isCubeTexture)?1:-1;uniforms.reflectivity.value=material.reflectivity;uniforms.refractionRatio.value=material.refractionRatio;}if(material.lightMap){uniforms.lightMap.value=material.lightMap;uniforms.lightMapIntensity.value=material.lightMapIntensity;}if(material.aoMap){uniforms.aoMap.value=material.aoMap;uniforms.aoMapIntensity.value=material.aoMapIntensity;}// uv repeat and offset setting priorities
// 1. color map
// 2. specular map
// 3. normal map
// 4. bump map
// 5. alpha map
// 6. emissive map
var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.specularMap){uvScaleMap=material.specularMap;}else if(material.displacementMap){uvScaleMap=material.displacementMap;}else if(material.normalMap){uvScaleMap=material.normalMap;}else if(material.bumpMap){uvScaleMap=material.bumpMap;}else if(material.roughnessMap){uvScaleMap=material.roughnessMap;}else if(material.metalnessMap){uvScaleMap=material.metalnessMap;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}else if(material.emissiveMap){uvScaleMap=material.emissiveMap;}if(uvScaleMap!==undefined){// backwards compatibility
if(uvScaleMap.isWebGLRenderTarget){uvScaleMap=uvScaleMap.texture;}if(uvScaleMap.matrixAutoUpdate===true){var offset=uvScaleMap.offset;var repeat=uvScaleMap.repeat;var rotation=uvScaleMap.rotation;var center=uvScaleMap.center;uvScaleMap.matrix.setUvTransform(offset.x,offset.y,repeat.x,repeat.y,rotation,center.x,center.y);}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value=material.color;uniforms.opacity.value=material.opacity;}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material){uniforms.diffuse.value=material.color;uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*_pixelRatio;uniforms.scale.value=_height*0.5;uniforms.map.value=material.map;if(material.map!==null){if(material.map.matrixAutoUpdate===true){var offset=material.map.offset;var repeat=material.map.repeat;var rotation=material.map.rotation;var center=material.map.center;material.map.matrix.setUvTransform(offset.x,offset.y,repeat.x,repeat.y,rotation,center.x,center.y);}uniforms.uvTransform.value.copy(material.map.matrix);}}function refreshUniformsFog(uniforms,fog){uniforms.fogColor.value=fog.color;if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshUniformsLambert(uniforms,material){if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value=material.specular;uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsToon(uniforms,material){refreshUniformsPhong(uniforms,material);if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}}function refreshUniformsStandard(uniforms,material){uniforms.roughness.value=material.roughness;uniforms.metalness.value=material.metalness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;}if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}if(material.envMap){//uniforms.envMap.value = material.envMap; // part of uniforms common
uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material){uniforms.clearCoat.value=material.clearCoat;uniforms.clearCoatRoughness.value=material.clearCoatRoughness;refreshUniformsStandard(uniforms,material);}function refreshUniformsDepth(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsDistance(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}uniforms.referencePosition.value.copy(material.referencePosition);uniforms.nearDistance.value=material.nearDistance;uniforms.farDistance.value=material.farDistance;}function refreshUniformsNormal(uniforms,material){if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}// GL state setting
this.setFaceCulling=function(cullFace,frontFaceDirection){state.setCullFace(cullFace);state.setFlipSided(frontFaceDirection===FrontFaceDirectionCW);};// Textures
function allocTextureUnit(){var textureUnit=_usedTextureUnits;if(textureUnit>=capabilities.maxTextures){console.warn('THREE.WebGLRenderer: Trying to use '+textureUnit+' texture units while this GPU supports only '+capabilities.maxTextures);}_usedTextureUnits+=1;return textureUnit;}this.allocTextureUnit=allocTextureUnit;// this.setTexture2D = setTexture2D;
this.setTexture2D=function(){var warned=false;// backwards compatibility: peel texture.texture
return function setTexture2D(texture,slot){if(texture&&texture.isWebGLRenderTarget){if(!warned){console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.");warned=true;}texture=texture.texture;}textures.setTexture2D(texture,slot);};}();this.setTexture=function(){var warned=false;return function setTexture(texture,slot){if(!warned){console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.");warned=true;}textures.setTexture2D(texture,slot);};}();this.setTextureCube=function(){var warned=false;return function setTextureCube(texture,slot){// backwards compatibility: peel texture.texture
if(texture&&texture.isWebGLRenderTargetCube){if(!warned){console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.");warned=true;}texture=texture.texture;}// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
// TODO: unify these code paths
if(texture&&texture.isCubeTexture||Array.isArray(texture.image)&&texture.image.length===6){// CompressedTexture can have Array in image :/
// this function alone should take care of cube textures
textures.setTextureCube(texture,slot);}else{// assumed: texture property of THREE.WebGLRenderTargetCube
textures.setTextureCubeDynamic(texture,slot);}};}();this.getRenderTarget=function(){return _currentRenderTarget;};this.setRenderTarget=function(renderTarget){_currentRenderTarget=renderTarget;if(renderTarget&&properties.get(renderTarget).__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}var framebuffer=null;var isCube=false;if(renderTarget){var __webglFramebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLRenderTargetCube){framebuffer=__webglFramebuffer[renderTarget.activeCubeFace];isCube=true;}else{framebuffer=__webglFramebuffer;}_currentViewport.copy(renderTarget.viewport);_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;}else{_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);_currentScissorTest=_scissorTest;}if(_currentFramebuffer!==framebuffer){_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);_currentFramebuffer=framebuffer;}state.viewport(_currentViewport);state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);if(isCube){var textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+renderTarget.activeCubeFace,textureProperties.__webglTexture,renderTarget.activeMipMapLevel);}};this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}var framebuffer=properties.get(renderTarget).__webglFramebuffer;if(framebuffer){var restore=false;if(framebuffer!==_currentFramebuffer){_gl.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);restore=true;}try{var texture=renderTarget.texture;var textureFormat=texture.format;var textureType=texture.type;if(textureFormat!==RGBAFormat&&utils.convert(textureFormat)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}if(textureType!==UnsignedByteType&&utils.convert(textureType)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE)&&// IE11, Edge and Chrome Mac < 52 (#9513)
!(textureType===FloatType&&(extensions.get('OES_texture_float')||extensions.get('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox
!(textureType===HalfFloatType&&extensions.get('EXT_color_buffer_half_float'))){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}if(_gl.checkFramebufferStatus(_gl.FRAMEBUFFER)===_gl.FRAMEBUFFER_COMPLETE){// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer);}}else{console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');}}finally{if(restore){_gl.bindFramebuffer(_gl.FRAMEBUFFER,_currentFramebuffer);}}}};}/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function FogExp2(color,density){this.name='';this.color=new Color(color);this.density=density!==undefined?density:0.00025;}FogExp2.prototype.isFogExp2=true;FogExp2.prototype.clone=function(){return new FogExp2(this.color.getHex(),this.density);};FogExp2.prototype.toJSON=function()/* meta */{return{type:'FogExp2',color:this.color.getHex(),density:this.density};};/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function Fog(color,near,far){this.name='';this.color=new Color(color);this.near=near!==undefined?near:1;this.far=far!==undefined?far:1000;}Fog.prototype.isFog=true;Fog.prototype.clone=function(){return new Fog(this.color.getHex(),this.near,this.far);};Fog.prototype.toJSON=function()/* meta */{return{type:'Fog',color:this.color.getHex(),near:this.near,far:this.far};};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Scene(){Object3D.call(this);this.type='Scene';this.background=null;this.fog=null;this.overrideMaterial=null;this.autoUpdate=true;// checked by the renderer
}Scene.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Scene,copy:function copy(source,recursive){Object3D.prototype.copy.call(this,source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.fog!==null)this.fog=source.fog.clone();if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.autoUpdate=source.autoUpdate;this.matrixAutoUpdate=source.matrixAutoUpdate;return this;},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);if(this.background!==null)data.object.background=this.background.toJSON(meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();return data;}});/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */function LensFlare(texture,size,distance,blending,color){Object3D.call(this);this.lensFlares=[];this.positionScreen=new Vector3();this.customUpdateCallback=undefined;if(texture!==undefined){this.add(texture,size,distance,blending,color);}}LensFlare.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:LensFlare,isLensFlare:true,copy:function copy(source){Object3D.prototype.copy.call(this,source);this.positionScreen.copy(source.positionScreen);this.customUpdateCallback=source.customUpdateCallback;for(var i=0,l=source.lensFlares.length;i<l;i++){this.lensFlares.push(source.lensFlares[i]);}return this;},add:function add(texture,size,distance,blending,color,opacity){if(size===undefined)size=-1;if(distance===undefined)distance=0;if(opacity===undefined)opacity=1;if(color===undefined)color=new Color(0xffffff);if(blending===undefined)blending=NormalBlending;distance=Math.min(distance,Math.max(0,distance));this.lensFlares.push({texture:texture,// THREE.Texture
size:size,// size in pixels (-1 = use texture.width)
distance:distance,// distance (0-1) from light source (0=at light source)
x:0,y:0,z:0,// screen position (-1 => 1) z = 0 is in front z = 1 is back
scale:1,// scale
rotation:0,// rotation
opacity:opacity,// opacity
color:color,// color
blending:blending// blending
});},/*
		 * Update lens flares update positions on all flares based on the screen position
		 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
		 */updateLensFlares:function updateLensFlares(){var f,fl=this.lensFlares.length;var flare;var vecX=-this.positionScreen.x*2;var vecY=-this.positionScreen.y*2;for(f=0;f<fl;f++){flare=this.lensFlares[f];flare.x=this.positionScreen.x+vecX*flare.distance;flare.y=this.positionScreen.y+vecY*flare.distance;flare.wantedRotation=flare.x*Math.PI*0.25;flare.rotation+=(flare.wantedRotation-flare.rotation)*0.25;}}});/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2()
	 * }
	 */function SpriteMaterial(parameters){Material.call(this);this.type='SpriteMaterial';this.color=new Color(0xffffff);this.map=null;this.rotation=0;this.fog=false;this.lights=false;this.setValues(parameters);}SpriteMaterial.prototype=Object.create(Material.prototype);SpriteMaterial.prototype.constructor=SpriteMaterial;SpriteMaterial.prototype.isSpriteMaterial=true;SpriteMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.rotation=source.rotation;return this;};/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */function Sprite(material){Object3D.call(this);this.type='Sprite';this.material=material!==undefined?material:new SpriteMaterial();}Sprite.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Sprite,isSprite:true,raycast:function(){var intersectPoint=new Vector3();var worldPosition=new Vector3();var worldScale=new Vector3();return function raycast(raycaster,intersects){worldPosition.setFromMatrixPosition(this.matrixWorld);raycaster.ray.closestPointToPoint(worldPosition,intersectPoint);worldScale.setFromMatrixScale(this.matrixWorld);var guessSizeSq=worldScale.x*worldScale.y/4;if(worldPosition.distanceToSquared(intersectPoint)>guessSizeSq)return;var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,point:intersectPoint.clone(),face:null,object:this});};}(),clone:function clone(){return new this.constructor(this.material).copy(this);}});/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */function LOD(){Object3D.call(this);this.type='LOD';Object.defineProperties(this,{levels:{enumerable:true,value:[]}});}LOD.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:LOD,copy:function copy(source){Object3D.prototype.copy.call(this,source,false);var levels=source.levels;for(var i=0,l=levels.length;i<l;i++){var level=levels[i];this.addLevel(level.object.clone(),level.distance);}return this;},addLevel:function addLevel(object,distance){if(distance===undefined)distance=0;distance=Math.abs(distance);var levels=this.levels;for(var l=0;l<levels.length;l++){if(distance<levels[l].distance){break;}}levels.splice(l,0,{distance:distance,object:object});this.add(object);},getObjectForDistance:function getObjectForDistance(distance){var levels=this.levels;for(var i=1,l=levels.length;i<l;i++){if(distance<levels[i].distance){break;}}return levels[i-1].object;},raycast:function(){var matrixPosition=new Vector3();return function raycast(raycaster,intersects){matrixPosition.setFromMatrixPosition(this.matrixWorld);var distance=raycaster.ray.origin.distanceTo(matrixPosition);this.getObjectForDistance(distance).raycast(raycaster,intersects);};}(),update:function(){var v1=new Vector3();var v2=new Vector3();return function update(camera){var levels=this.levels;if(levels.length>1){v1.setFromMatrixPosition(camera.matrixWorld);v2.setFromMatrixPosition(this.matrixWorld);var distance=v1.distanceTo(v2);levels[0].object.visible=true;for(var i=1,l=levels.length;i<l;i++){if(distance>=levels[i].distance){levels[i-1].object.visible=false;levels[i].object.visible=true;}else{break;}}for(;i<l;i++){levels[i].object.visible=false;}}};}(),toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.levels=[];var levels=this.levels;for(var i=0,l=levels.length;i<l;i++){var level=levels[i];data.object.levels.push({object:level.object.uuid,distance:level.distance});}return data;}});/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */function Skeleton(bones,boneInverses){// copy the bone array
bones=bones||[];this.bones=bones.slice(0);this.boneMatrices=new Float32Array(this.bones.length*16);// use the supplied bone inverses or calculate the inverses
if(boneInverses===undefined){this.calculateInverses();}else{if(this.bones.length===boneInverses.length){this.boneInverses=boneInverses.slice(0);}else{console.warn('THREE.Skeleton boneInverses is the wrong length.');this.boneInverses=[];for(var i=0,il=this.bones.length;i<il;i++){this.boneInverses.push(new Matrix4());}}}}Object.assign(Skeleton.prototype,{calculateInverses:function calculateInverses(){this.boneInverses=[];for(var i=0,il=this.bones.length;i<il;i++){var inverse=new Matrix4();if(this.bones[i]){inverse.getInverse(this.bones[i].matrixWorld);}this.boneInverses.push(inverse);}},pose:function pose(){var bone,i,il;// recover the bind-time world matrices
for(i=0,il=this.bones.length;i<il;i++){bone=this.bones[i];if(bone){bone.matrixWorld.getInverse(this.boneInverses[i]);}}// compute the local matrices, positions, rotations and scales
for(i=0,il=this.bones.length;i<il;i++){bone=this.bones[i];if(bone){if(bone.parent&&bone.parent.isBone){bone.matrix.getInverse(bone.parent.matrixWorld);bone.matrix.multiply(bone.matrixWorld);}else{bone.matrix.copy(bone.matrixWorld);}bone.matrix.decompose(bone.position,bone.quaternion,bone.scale);}}},update:function(){var offsetMatrix=new Matrix4();var identityMatrix=new Matrix4();return function update(){var bones=this.bones;var boneInverses=this.boneInverses;var boneMatrices=this.boneMatrices;var boneTexture=this.boneTexture;// flatten bone matrices to array
for(var i=0,il=bones.length;i<il;i++){// compute the offset between the current and the original transform
var matrix=bones[i]?bones[i].matrixWorld:identityMatrix;offsetMatrix.multiplyMatrices(matrix,boneInverses[i]);offsetMatrix.toArray(boneMatrices,i*16);}if(boneTexture!==undefined){boneTexture.needsUpdate=true;}};}(),clone:function clone(){return new Skeleton(this.bones,this.boneInverses);}});/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */function Bone(){Object3D.call(this);this.type='Bone';}Bone.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Bone,isBone:true});/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */function SkinnedMesh(geometry,material){Mesh.call(this,geometry,material);this.type='SkinnedMesh';this.bindMode='attached';this.bindMatrix=new Matrix4();this.bindMatrixInverse=new Matrix4();var bones=this.initBones();var skeleton=new Skeleton(bones);this.bind(skeleton,this.matrixWorld);this.normalizeSkinWeights();}SkinnedMesh.prototype=Object.assign(Object.create(Mesh.prototype),{constructor:SkinnedMesh,isSkinnedMesh:true,initBones:function initBones(){var bones=[],bone,gbone;var i,il;if(this.geometry&&this.geometry.bones!==undefined){// first, create array of 'Bone' objects from geometry data
for(i=0,il=this.geometry.bones.length;i<il;i++){gbone=this.geometry.bones[i];// create new 'Bone' object
bone=new Bone();bones.push(bone);// apply values
bone.name=gbone.name;bone.position.fromArray(gbone.pos);bone.quaternion.fromArray(gbone.rotq);if(gbone.scl!==undefined)bone.scale.fromArray(gbone.scl);}// second, create bone hierarchy
for(i=0,il=this.geometry.bones.length;i<il;i++){gbone=this.geometry.bones[i];if(gbone.parent!==-1&&gbone.parent!==null&&bones[gbone.parent]!==undefined){// subsequent bones in the hierarchy
bones[gbone.parent].add(bones[i]);}else{// topmost bone, immediate child of the skinned mesh
this.add(bones[i]);}}}// now the bones are part of the scene graph and children of the skinned mesh.
// let's update the corresponding matrices
this.updateMatrixWorld(true);return bones;},bind:function bind(skeleton,bindMatrix){this.skeleton=skeleton;if(bindMatrix===undefined){this.updateMatrixWorld(true);this.skeleton.calculateInverses();bindMatrix=this.matrixWorld;}this.bindMatrix.copy(bindMatrix);this.bindMatrixInverse.getInverse(bindMatrix);},pose:function pose(){this.skeleton.pose();},normalizeSkinWeights:function normalizeSkinWeights(){var scale,i;if(this.geometry&&this.geometry.isGeometry){for(i=0;i<this.geometry.skinWeights.length;i++){var sw=this.geometry.skinWeights[i];scale=1.0/sw.manhattanLength();if(scale!==Infinity){sw.multiplyScalar(scale);}else{sw.set(1,0,0,0);// do something reasonable
}}}else if(this.geometry&&this.geometry.isBufferGeometry){var vec=new Vector4();var skinWeight=this.geometry.attributes.skinWeight;for(i=0;i<skinWeight.count;i++){vec.x=skinWeight.getX(i);vec.y=skinWeight.getY(i);vec.z=skinWeight.getZ(i);vec.w=skinWeight.getW(i);scale=1.0/vec.manhattanLength();if(scale!==Infinity){vec.multiplyScalar(scale);}else{vec.set(1,0,0,0);// do something reasonable
}skinWeight.setXYZW(i,vec.x,vec.y,vec.z,vec.w);}}},updateMatrixWorld:function updateMatrixWorld(force){Mesh.prototype.updateMatrixWorld.call(this,force);if(this.bindMode==='attached'){this.bindMatrixInverse.getInverse(this.matrixWorld);}else if(this.bindMode==='detached'){this.bindMatrixInverse.getInverse(this.bindMatrix);}else{console.warn('THREE.SkinnedMesh: Unrecognized bindMode: '+this.bindMode);}},clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */function LineBasicMaterial(parameters){Material.call(this);this.type='LineBasicMaterial';this.color=new Color(0xffffff);this.linewidth=1;this.linecap='round';this.linejoin='round';this.lights=false;this.setValues(parameters);}LineBasicMaterial.prototype=Object.create(Material.prototype);LineBasicMaterial.prototype.constructor=LineBasicMaterial;LineBasicMaterial.prototype.isLineBasicMaterial=true;LineBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.linewidth=source.linewidth;this.linecap=source.linecap;this.linejoin=source.linejoin;return this;};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Line(geometry,material,mode){if(mode===1){console.warn('THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.');return new LineSegments(geometry,material);}Object3D.call(this);this.type='Line';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new LineBasicMaterial({color:Math.random()*0xffffff});}Line.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Line,isLine:true,raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();return function raycast(raycaster,intersects){var precision=raycaster.linePrecision;var precisionSq=precision*precision;var geometry=this.geometry;var matrixWorld=this.matrixWorld;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(sphere)===false)return;//
inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);var vStart=new Vector3();var vEnd=new Vector3();var interSegment=new Vector3();var interRay=new Vector3();var step=this&&this.isLineSegments?2:1;if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,l=indices.length-1;i<l;i+=step){var a=indices[i];var b=indices[i+1];vStart.fromArray(positions,a*3);vEnd.fromArray(positions,b*3);var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}else{for(var i=0,l=positions.length/3-1;i<l;i+=step){vStart.fromArray(positions,3*i);vEnd.fromArray(positions,3*i+3);var distSq=ray.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}}else if(geometry.isGeometry){var vertices=geometry.vertices;var nbVertices=vertices.length;for(var i=0;i<nbVertices-1;i+=step){var distSq=ray.distanceSqToSegment(vertices[i],vertices[i+1],interRay,interSegment);if(distSq>precisionSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}};}(),clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function LineSegments(geometry,material){Line.call(this,geometry,material);this.type='LineSegments';}LineSegments.prototype=Object.assign(Object.create(Line.prototype),{constructor:LineSegments,isLineSegments:true});/**
	 * @author mgreter / http://github.com/mgreter
	 */function LineLoop(geometry,material){Line.call(this,geometry,material);this.type='LineLoop';}LineLoop.prototype=Object.assign(Object.create(Line.prototype),{constructor:LineLoop,isLineLoop:true});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */function PointsMaterial(parameters){Material.call(this);this.type='PointsMaterial';this.color=new Color(0xffffff);this.map=null;this.size=1;this.sizeAttenuation=true;this.lights=false;this.setValues(parameters);}PointsMaterial.prototype=Object.create(Material.prototype);PointsMaterial.prototype.constructor=PointsMaterial;PointsMaterial.prototype.isPointsMaterial=true;PointsMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.size=source.size;this.sizeAttenuation=source.sizeAttenuation;return this;};/**
	 * @author alteredq / http://alteredqualia.com/
	 */function Points(geometry,material){Object3D.call(this);this.type='Points';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new PointsMaterial({color:Math.random()*0xffffff});}Points.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Points,isPoints:true,raycast:function(){var inverseMatrix=new Matrix4();var ray=new Ray();var sphere=new Sphere();return function raycast(raycaster,intersects){var object=this;var geometry=this.geometry;var matrixWorld=this.matrixWorld;var threshold=raycaster.params.Points.threshold;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();sphere.copy(geometry.boundingSphere);sphere.applyMatrix4(matrixWorld);sphere.radius+=threshold;if(raycaster.ray.intersectsSphere(sphere)===false)return;//
inverseMatrix.getInverse(matrixWorld);ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);var localThresholdSq=localThreshold*localThreshold;var position=new Vector3();function testPoint(point,index){var rayPointDistanceSq=ray.distanceSqToPoint(point);if(rayPointDistanceSq<localThresholdSq){var intersectPoint=ray.closestPointToPoint(point);intersectPoint.applyMatrix4(matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,distanceToRay:Math.sqrt(rayPointDistanceSq),point:intersectPoint.clone(),index:index,face:null,object:object});}}if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,il=indices.length;i<il;i++){var a=indices[i];position.fromArray(positions,a*3);testPoint(position,a);}}else{for(var i=0,l=positions.length/3;i<l;i++){position.fromArray(positions,i*3);testPoint(position,i);}}}else{var vertices=geometry.vertices;for(var i=0,l=vertices.length;i<l;i++){testPoint(vertices[i],i);}}};}(),clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Group(){Object3D.call(this);this.type='Group';}Group.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Group});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function VideoTexture(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){Texture.call(this,video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.generateMipmaps=false;var scope=this;function update(){if(video.readyState>=video.HAVE_CURRENT_DATA){scope.needsUpdate=true;}requestAnimationFrame(update);}requestAnimationFrame(update);}VideoTexture.prototype=Object.create(Texture.prototype);VideoTexture.prototype.constructor=VideoTexture;/**
	 * @author alteredq / http://alteredqualia.com/
	 */function CompressedTexture(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={width:width,height:height};this.mipmaps=mipmaps;// no flipping for cube textures
// (also flipping doesn't work for compressed textures )
this.flipY=false;// can't generate mipmaps for compressed textures
// mips must be embedded in DDS files
this.generateMipmaps=false;}CompressedTexture.prototype=Object.create(Texture.prototype);CompressedTexture.prototype.constructor=CompressedTexture;CompressedTexture.prototype.isCompressedTexture=true;/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */function DepthTexture(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){format=format!==undefined?format:DepthFormat;if(format!==DepthFormat&&format!==DepthStencilFormat){throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');}if(type===undefined&&format===DepthFormat)type=UnsignedShortType;if(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.image={width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.flipY=false;this.generateMipmaps=false;}DepthTexture.prototype=Object.create(Texture.prototype);DepthTexture.prototype.constructor=DepthTexture;DepthTexture.prototype.isDepthTexture=true;/**
	 * @author zz85 / https://github.com/zz85
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */// ParametricGeometry
function ParametricGeometry(func,slices,stacks){Geometry.call(this);this.type='ParametricGeometry';this.parameters={func:func,slices:slices,stacks:stacks};this.fromBufferGeometry(new ParametricBufferGeometry(func,slices,stacks));this.mergeVertices();}ParametricGeometry.prototype=Object.create(Geometry.prototype);ParametricGeometry.prototype.constructor=ParametricGeometry;// ParametricBufferGeometry
function ParametricBufferGeometry(func,slices,stacks){BufferGeometry.call(this);this.type='ParametricBufferGeometry';this.parameters={func:func,slices:slices,stacks:stacks};// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];var EPS=0.00001;var normal=new Vector3();var p0=new Vector3(),p1=new Vector3();var pu=new Vector3(),pv=new Vector3();var i,j;// generate vertices, normals and uvs
var sliceCount=slices+1;for(i=0;i<=stacks;i++){var v=i/stacks;for(j=0;j<=slices;j++){var u=j/slices;// vertex
p0=func(u,v,p0);vertices.push(p0.x,p0.y,p0.z);// normal
// approximate tangent vectors via finite differences
if(u-EPS>=0){p1=func(u-EPS,v,p1);pu.subVectors(p0,p1);}else{p1=func(u+EPS,v,p1);pu.subVectors(p1,p0);}if(v-EPS>=0){p1=func(u,v-EPS,p1);pv.subVectors(p0,p1);}else{p1=func(u,v+EPS,p1);pv.subVectors(p1,p0);}// cross product of tangent vectors returns surface normal
normal.crossVectors(pu,pv).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u,v);}}// generate indices
for(i=0;i<stacks;i++){for(j=0;j<slices;j++){var a=i*sliceCount+j;var b=i*sliceCount+j+1;var c=(i+1)*sliceCount+j+1;var d=(i+1)*sliceCount+j;// faces one and two
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}ParametricBufferGeometry.prototype=Object.create(BufferGeometry.prototype);ParametricBufferGeometry.prototype.constructor=ParametricBufferGeometry;/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */// PolyhedronGeometry
function PolyhedronGeometry(vertices,indices,radius,detail){Geometry.call(this);this.type='PolyhedronGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices,indices,radius,detail));this.mergeVertices();}PolyhedronGeometry.prototype=Object.create(Geometry.prototype);PolyhedronGeometry.prototype.constructor=PolyhedronGeometry;// PolyhedronBufferGeometry
function PolyhedronBufferGeometry(vertices,indices,radius,detail){BufferGeometry.call(this);this.type='PolyhedronBufferGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};radius=radius||1;detail=detail||0;// default buffer data
var vertexBuffer=[];var uvBuffer=[];// the subdivision creates the vertex buffer data
subdivide(detail);// all vertices should lie on a conceptual sphere with a given radius
appplyRadius(radius);// finally, create the uv data
generateUVs();// build non-indexed geometry
this.addAttribute('position',new Float32BufferAttribute(vertexBuffer,3));this.addAttribute('normal',new Float32BufferAttribute(vertexBuffer.slice(),3));this.addAttribute('uv',new Float32BufferAttribute(uvBuffer,2));if(detail===0){this.computeVertexNormals();// flat normals
}else{this.normalizeNormals();// smooth normals
}// helper functions
function subdivide(detail){var a=new Vector3();var b=new Vector3();var c=new Vector3();// iterate over all faces and apply a subdivison with the given detail value
for(var i=0;i<indices.length;i+=3){// get the vertices of the face
getVertexByIndex(indices[i+0],a);getVertexByIndex(indices[i+1],b);getVertexByIndex(indices[i+2],c);// perform subdivision
subdivideFace(a,b,c,detail);}}function subdivideFace(a,b,c,detail){var cols=Math.pow(2,detail);// we use this multidimensional array as a data structure for creating the subdivision
var v=[];var i,j;// construct all of the vertices for this subdivision
for(i=0;i<=cols;i++){v[i]=[];var aj=a.clone().lerp(c,i/cols);var bj=b.clone().lerp(c,i/cols);var rows=cols-i;for(j=0;j<=rows;j++){if(j===0&&i===cols){v[i][j]=aj;}else{v[i][j]=aj.clone().lerp(bj,j/rows);}}}// construct all of the faces
for(i=0;i<cols;i++){for(j=0;j<2*(cols-i)-1;j++){var k=Math.floor(j/2);if(j%2===0){pushVertex(v[i][k+1]);pushVertex(v[i+1][k]);pushVertex(v[i][k]);}else{pushVertex(v[i][k+1]);pushVertex(v[i+1][k+1]);pushVertex(v[i+1][k]);}}}}function appplyRadius(radius){var vertex=new Vector3();// iterate over the entire buffer and apply the radius to each vertex
for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];vertex.normalize().multiplyScalar(radius);vertexBuffer[i+0]=vertex.x;vertexBuffer[i+1]=vertex.y;vertexBuffer[i+2]=vertex.z;}}function generateUVs(){var vertex=new Vector3();for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];var u=azimuth(vertex)/2/Math.PI+0.5;var v=inclination(vertex)/Math.PI+0.5;uvBuffer.push(u,1-v);}correctUVs();correctSeam();}function correctSeam(){// handle case when face straddles the seam, see #3269
for(var i=0;i<uvBuffer.length;i+=6){// uv data of a single face
var x0=uvBuffer[i+0];var x1=uvBuffer[i+2];var x2=uvBuffer[i+4];var max=Math.max(x0,x1,x2);var min=Math.min(x0,x1,x2);// 0.9 is somewhat arbitrary
if(max>0.9&&min<0.1){if(x0<0.2)uvBuffer[i+0]+=1;if(x1<0.2)uvBuffer[i+2]+=1;if(x2<0.2)uvBuffer[i+4]+=1;}}}function pushVertex(vertex){vertexBuffer.push(vertex.x,vertex.y,vertex.z);}function getVertexByIndex(index,vertex){var stride=index*3;vertex.x=vertices[stride+0];vertex.y=vertices[stride+1];vertex.z=vertices[stride+2];}function correctUVs(){var a=new Vector3();var b=new Vector3();var c=new Vector3();var centroid=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();for(var i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){a.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]);b.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]);c.set(vertexBuffer[i+6],vertexBuffer[i+7],vertexBuffer[i+8]);uvA.set(uvBuffer[j+0],uvBuffer[j+1]);uvB.set(uvBuffer[j+2],uvBuffer[j+3]);uvC.set(uvBuffer[j+4],uvBuffer[j+5]);centroid.copy(a).add(b).add(c).divideScalar(3);var azi=azimuth(centroid);correctUV(uvA,j+0,a,azi);correctUV(uvB,j+2,b,azi);correctUV(uvC,j+4,c,azi);}}function correctUV(uv,stride,vector,azimuth){if(azimuth<0&&uv.x===1){uvBuffer[stride]=uv.x-1;}if(vector.x===0&&vector.z===0){uvBuffer[stride]=azimuth/2/Math.PI+0.5;}}// Angle around the Y axis, counter-clockwise when looking from above.
function azimuth(vector){return Math.atan2(vector.z,-vector.x);}// Angle above the XZ plane.
function inclination(vector){return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z));}}PolyhedronBufferGeometry.prototype=Object.create(BufferGeometry.prototype);PolyhedronBufferGeometry.prototype.constructor=PolyhedronBufferGeometry;/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */// TetrahedronGeometry
function TetrahedronGeometry(radius,detail){Geometry.call(this);this.type='TetrahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new TetrahedronBufferGeometry(radius,detail));this.mergeVertices();}TetrahedronGeometry.prototype=Object.create(Geometry.prototype);TetrahedronGeometry.prototype.constructor=TetrahedronGeometry;// TetrahedronBufferGeometry
function TetrahedronBufferGeometry(radius,detail){var vertices=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1];var indices=[2,1,0,0,3,2,1,3,0,2,3,1];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='TetrahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}TetrahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);TetrahedronBufferGeometry.prototype.constructor=TetrahedronBufferGeometry;/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */// OctahedronGeometry
function OctahedronGeometry(radius,detail){Geometry.call(this);this.type='OctahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new OctahedronBufferGeometry(radius,detail));this.mergeVertices();}OctahedronGeometry.prototype=Object.create(Geometry.prototype);OctahedronGeometry.prototype.constructor=OctahedronGeometry;// OctahedronBufferGeometry
function OctahedronBufferGeometry(radius,detail){var vertices=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1];var indices=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='OctahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}OctahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);OctahedronBufferGeometry.prototype.constructor=OctahedronBufferGeometry;/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */// IcosahedronGeometry
function IcosahedronGeometry(radius,detail){Geometry.call(this);this.type='IcosahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new IcosahedronBufferGeometry(radius,detail));this.mergeVertices();}IcosahedronGeometry.prototype=Object.create(Geometry.prototype);IcosahedronGeometry.prototype.constructor=IcosahedronGeometry;// IcosahedronBufferGeometry
function IcosahedronBufferGeometry(radius,detail){var t=(1+Math.sqrt(5))/2;var vertices=[-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1];var indices=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='IcosahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}IcosahedronBufferGeometry.prototype=Object.create(PolyhedronBufferGeometry.prototype);IcosahedronBufferGeometry.prototype.constructor=IcosahedronBufferGeometry;/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */var ShapeUtils={// calculate area of the contour polygon
area:function area(contour){var n=contour.length;var a=0.0;for(var p=n-1,q=0;q<n;p=q++){a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;}return a*0.5;},triangulate:function(){/**
			 * This code is a quick port of code written in C++ which was submitted to
			 * flipcode.com by John W. Ratcliff  // July 22, 2000
			 * See original code and more information here:
			 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
			 *
			 * ported to actionscript by Zevan Rosser
			 * www.actionsnippet.com
			 *
			 * ported to javascript by Joshua Koo
			 * http://www.lab4games.net/zz85/blog
			 *
			 */function snip(contour,u,v,w,n,verts){var p;var ax,ay,bx,by;var cx,cy,px,py;ax=contour[verts[u]].x;ay=contour[verts[u]].y;bx=contour[verts[v]].x;by=contour[verts[v]].y;cx=contour[verts[w]].x;cy=contour[verts[w]].y;if((bx-ax)*(cy-ay)-(by-ay)*(cx-ax)<=0)return false;var aX,aY,bX,bY,cX,cY;var apx,apy,bpx,bpy,cpx,cpy;var cCROSSap,bCROSScp,aCROSSbp;aX=cx-bx;aY=cy-by;bX=ax-cx;bY=ay-cy;cX=bx-ax;cY=by-ay;for(p=0;p<n;p++){px=contour[verts[p]].x;py=contour[verts[p]].y;if(px===ax&&py===ay||px===bx&&py===by||px===cx&&py===cy)continue;apx=px-ax;apy=py-ay;bpx=px-bx;bpy=py-by;cpx=px-cx;cpy=py-cy;// see if p is inside triangle abc
aCROSSbp=aX*bpy-aY*bpx;cCROSSap=cX*apy-cY*apx;bCROSScp=bX*cpy-bY*cpx;if(aCROSSbp>=-Number.EPSILON&&bCROSScp>=-Number.EPSILON&&cCROSSap>=-Number.EPSILON)return false;}return true;}// takes in an contour array and returns
return function triangulate(contour,indices){var n=contour.length;if(n<3)return null;var result=[],verts=[],vertIndices=[];/* we want a counter-clockwise polygon in verts */var u,v,w;if(ShapeUtils.area(contour)>0.0){for(v=0;v<n;v++){verts[v]=v;}}else{for(v=0;v<n;v++){verts[v]=n-1-v;}}var nv=n;/*  remove nv - 2 vertices, creating 1 triangle every time */var count=2*nv;/* error detection */for(v=nv-1;nv>2;){/* if we loop, it is probably a non-simple polygon */if(count--<=0){//** Triangulate: ERROR - probable bad polygon!
//throw ( "Warning, unable to triangulate polygon!" );
//return null;
// Sometimes warning is fine, especially polygons are triangulated in reverse.
console.warn('THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()');if(indices)return vertIndices;return result;}/* three consecutive vertices in current polygon, <u,v,w> */u=v;if(nv<=u)u=0;/* previous */v=u+1;if(nv<=v)v=0;/* new v    */w=v+1;if(nv<=w)w=0;/* next     */if(snip(contour,u,v,w,nv,verts)){var a,b,c,s,t;/* true names of the vertices */a=verts[u];b=verts[v];c=verts[w];/* output Triangle */result.push([contour[a],contour[b],contour[c]]);vertIndices.push([verts[u],verts[v],verts[w]]);/* remove v from the remaining polygon */for(s=v,t=v+1;t<nv;s++,t++){verts[s]=verts[t];}nv--;/* reset error detection counter */count=2*nv;}}if(indices)return vertIndices;return result;};}(),triangulateShape:function triangulateShape(contour,holes){function removeDupEndPts(points){var l=points.length;if(l>2&&points[l-1].equals(points[0])){points.pop();}}removeDupEndPts(contour);holes.forEach(removeDupEndPts);function point_in_segment_2D_colin(inSegPt1,inSegPt2,inOtherPt){// inOtherPt needs to be collinear to the inSegment
if(inSegPt1.x!==inSegPt2.x){if(inSegPt1.x<inSegPt2.x){return inSegPt1.x<=inOtherPt.x&&inOtherPt.x<=inSegPt2.x;}else{return inSegPt2.x<=inOtherPt.x&&inOtherPt.x<=inSegPt1.x;}}else{if(inSegPt1.y<inSegPt2.y){return inSegPt1.y<=inOtherPt.y&&inOtherPt.y<=inSegPt2.y;}else{return inSegPt2.y<=inOtherPt.y&&inOtherPt.y<=inSegPt1.y;}}}function intersect_segments_2D(inSeg1Pt1,inSeg1Pt2,inSeg2Pt1,inSeg2Pt2,inExcludeAdjacentSegs){var seg1dx=inSeg1Pt2.x-inSeg1Pt1.x,seg1dy=inSeg1Pt2.y-inSeg1Pt1.y;var seg2dx=inSeg2Pt2.x-inSeg2Pt1.x,seg2dy=inSeg2Pt2.y-inSeg2Pt1.y;var seg1seg2dx=inSeg1Pt1.x-inSeg2Pt1.x;var seg1seg2dy=inSeg1Pt1.y-inSeg2Pt1.y;var limit=seg1dy*seg2dx-seg1dx*seg2dy;var perpSeg1=seg1dy*seg1seg2dx-seg1dx*seg1seg2dy;if(Math.abs(limit)>Number.EPSILON){// not parallel
var perpSeg2;if(limit>0){if(perpSeg1<0||perpSeg1>limit)return[];perpSeg2=seg2dy*seg1seg2dx-seg2dx*seg1seg2dy;if(perpSeg2<0||perpSeg2>limit)return[];}else{if(perpSeg1>0||perpSeg1<limit)return[];perpSeg2=seg2dy*seg1seg2dx-seg2dx*seg1seg2dy;if(perpSeg2>0||perpSeg2<limit)return[];}// i.e. to reduce rounding errors
// intersection at endpoint of segment#1?
if(perpSeg2===0){if(inExcludeAdjacentSegs&&(perpSeg1===0||perpSeg1===limit))return[];return[inSeg1Pt1];}if(perpSeg2===limit){if(inExcludeAdjacentSegs&&(perpSeg1===0||perpSeg1===limit))return[];return[inSeg1Pt2];}// intersection at endpoint of segment#2?
if(perpSeg1===0)return[inSeg2Pt1];if(perpSeg1===limit)return[inSeg2Pt2];// return real intersection point
var factorSeg1=perpSeg2/limit;return[{x:inSeg1Pt1.x+factorSeg1*seg1dx,y:inSeg1Pt1.y+factorSeg1*seg1dy}];}else{// parallel or collinear
if(perpSeg1!==0||seg2dy*seg1seg2dx!==seg2dx*seg1seg2dy)return[];// they are collinear or degenerate
var seg1Pt=seg1dx===0&&seg1dy===0;// segment1 is just a point?
var seg2Pt=seg2dx===0&&seg2dy===0;// segment2 is just a point?
// both segments are points
if(seg1Pt&&seg2Pt){if(inSeg1Pt1.x!==inSeg2Pt1.x||inSeg1Pt1.y!==inSeg2Pt1.y)return[];// they are distinct  points
return[inSeg1Pt1];// they are the same point
}// segment#1  is a single point
if(seg1Pt){if(!point_in_segment_2D_colin(inSeg2Pt1,inSeg2Pt2,inSeg1Pt1))return[];// but not in segment#2
return[inSeg1Pt1];}// segment#2  is a single point
if(seg2Pt){if(!point_in_segment_2D_colin(inSeg1Pt1,inSeg1Pt2,inSeg2Pt1))return[];// but not in segment#1
return[inSeg2Pt1];}// they are collinear segments, which might overlap
var seg1min,seg1max,seg1minVal,seg1maxVal;var seg2min,seg2max,seg2minVal,seg2maxVal;if(seg1dx!==0){// the segments are NOT on a vertical line
if(inSeg1Pt1.x<inSeg1Pt2.x){seg1min=inSeg1Pt1;seg1minVal=inSeg1Pt1.x;seg1max=inSeg1Pt2;seg1maxVal=inSeg1Pt2.x;}else{seg1min=inSeg1Pt2;seg1minVal=inSeg1Pt2.x;seg1max=inSeg1Pt1;seg1maxVal=inSeg1Pt1.x;}if(inSeg2Pt1.x<inSeg2Pt2.x){seg2min=inSeg2Pt1;seg2minVal=inSeg2Pt1.x;seg2max=inSeg2Pt2;seg2maxVal=inSeg2Pt2.x;}else{seg2min=inSeg2Pt2;seg2minVal=inSeg2Pt2.x;seg2max=inSeg2Pt1;seg2maxVal=inSeg2Pt1.x;}}else{// the segments are on a vertical line
if(inSeg1Pt1.y<inSeg1Pt2.y){seg1min=inSeg1Pt1;seg1minVal=inSeg1Pt1.y;seg1max=inSeg1Pt2;seg1maxVal=inSeg1Pt2.y;}else{seg1min=inSeg1Pt2;seg1minVal=inSeg1Pt2.y;seg1max=inSeg1Pt1;seg1maxVal=inSeg1Pt1.y;}if(inSeg2Pt1.y<inSeg2Pt2.y){seg2min=inSeg2Pt1;seg2minVal=inSeg2Pt1.y;seg2max=inSeg2Pt2;seg2maxVal=inSeg2Pt2.y;}else{seg2min=inSeg2Pt2;seg2minVal=inSeg2Pt2.y;seg2max=inSeg2Pt1;seg2maxVal=inSeg2Pt1.y;}}if(seg1minVal<=seg2minVal){if(seg1maxVal<seg2minVal)return[];if(seg1maxVal===seg2minVal){if(inExcludeAdjacentSegs)return[];return[seg2min];}if(seg1maxVal<=seg2maxVal)return[seg2min,seg1max];return[seg2min,seg2max];}else{if(seg1minVal>seg2maxVal)return[];if(seg1minVal===seg2maxVal){if(inExcludeAdjacentSegs)return[];return[seg1min];}if(seg1maxVal<=seg2maxVal)return[seg1min,seg1max];return[seg1min,seg2max];}}}function isPointInsideAngle(inVertex,inLegFromPt,inLegToPt,inOtherPt){// The order of legs is important
// translation of all points, so that Vertex is at (0,0)
var legFromPtX=inLegFromPt.x-inVertex.x,legFromPtY=inLegFromPt.y-inVertex.y;var legToPtX=inLegToPt.x-inVertex.x,legToPtY=inLegToPt.y-inVertex.y;var otherPtX=inOtherPt.x-inVertex.x,otherPtY=inOtherPt.y-inVertex.y;// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
var from2toAngle=legFromPtX*legToPtY-legFromPtY*legToPtX;var from2otherAngle=legFromPtX*otherPtY-legFromPtY*otherPtX;if(Math.abs(from2toAngle)>Number.EPSILON){// angle != 180 deg.
var other2toAngle=otherPtX*legToPtY-otherPtY*legToPtX;// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
if(from2toAngle>0){// main angle < 180 deg.
return from2otherAngle>=0&&other2toAngle>=0;}else{// main angle > 180 deg.
return from2otherAngle>=0||other2toAngle>=0;}}else{// angle == 180 deg.
// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
return from2otherAngle>0;}}function removeHoles(contour,holes){var shape=contour.concat();// work on this shape
var hole;function isCutLineInsideAngles(inShapeIdx,inHoleIdx){// Check if hole point lies within angle around shape point
var lastShapeIdx=shape.length-1;var prevShapeIdx=inShapeIdx-1;if(prevShapeIdx<0)prevShapeIdx=lastShapeIdx;var nextShapeIdx=inShapeIdx+1;if(nextShapeIdx>lastShapeIdx)nextShapeIdx=0;var insideAngle=isPointInsideAngle(shape[inShapeIdx],shape[prevShapeIdx],shape[nextShapeIdx],hole[inHoleIdx]);if(!insideAngle){// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
return false;}// Check if shape point lies within angle around hole point
var lastHoleIdx=hole.length-1;var prevHoleIdx=inHoleIdx-1;if(prevHoleIdx<0)prevHoleIdx=lastHoleIdx;var nextHoleIdx=inHoleIdx+1;if(nextHoleIdx>lastHoleIdx)nextHoleIdx=0;insideAngle=isPointInsideAngle(hole[inHoleIdx],hole[prevHoleIdx],hole[nextHoleIdx],shape[inShapeIdx]);if(!insideAngle){// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
return false;}return true;}function intersectsShapeEdge(inShapePt,inHolePt){// checks for intersections with shape edges
var sIdx,nextIdx,intersection;for(sIdx=0;sIdx<shape.length;sIdx++){nextIdx=sIdx+1;nextIdx%=shape.length;intersection=intersect_segments_2D(inShapePt,inHolePt,shape[sIdx],shape[nextIdx],true);if(intersection.length>0)return true;}return false;}var indepHoles=[];function intersectsHoleEdge(inShapePt,inHolePt){// checks for intersections with hole edges
var ihIdx,chkHole,hIdx,nextIdx,intersection;for(ihIdx=0;ihIdx<indepHoles.length;ihIdx++){chkHole=holes[indepHoles[ihIdx]];for(hIdx=0;hIdx<chkHole.length;hIdx++){nextIdx=hIdx+1;nextIdx%=chkHole.length;intersection=intersect_segments_2D(inShapePt,inHolePt,chkHole[hIdx],chkHole[nextIdx],true);if(intersection.length>0)return true;}}return false;}var holeIndex,shapeIndex,shapePt,holePt,holeIdx,cutKey,failedCuts=[],tmpShape1,tmpShape2,tmpHole1,tmpHole2;for(var h=0,hl=holes.length;h<hl;h++){indepHoles.push(h);}var minShapeIndex=0;var counter=indepHoles.length*2;while(indepHoles.length>0){counter--;if(counter<0){console.log('THREE.ShapeUtils: Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!');break;}// search for shape-vertex and hole-vertex,
// which can be connected without intersections
for(shapeIndex=minShapeIndex;shapeIndex<shape.length;shapeIndex++){shapePt=shape[shapeIndex];holeIndex=-1;// search for hole which can be reached without intersections
for(var h=0;h<indepHoles.length;h++){holeIdx=indepHoles[h];// prevent multiple checks
cutKey=shapePt.x+':'+shapePt.y+':'+holeIdx;if(failedCuts[cutKey]!==undefined)continue;hole=holes[holeIdx];for(var h2=0;h2<hole.length;h2++){holePt=hole[h2];if(!isCutLineInsideAngles(shapeIndex,h2))continue;if(intersectsShapeEdge(shapePt,holePt))continue;if(intersectsHoleEdge(shapePt,holePt))continue;holeIndex=h2;indepHoles.splice(h,1);tmpShape1=shape.slice(0,shapeIndex+1);tmpShape2=shape.slice(shapeIndex);tmpHole1=hole.slice(holeIndex);tmpHole2=hole.slice(0,holeIndex+1);shape=tmpShape1.concat(tmpHole1).concat(tmpHole2).concat(tmpShape2);minShapeIndex=shapeIndex;// Debug only, to show the selected cuts
// glob_CutLines.push( [ shapePt, holePt ] );
break;}if(holeIndex>=0)break;// hole-vertex found
failedCuts[cutKey]=true;// remember failure
}if(holeIndex>=0)break;// hole-vertex found
}}return shape;/* shape with no holes */}var i,il,f,face,key,index,allPointsMap={};// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
var allpoints=contour.concat();for(var h=0,hl=holes.length;h<hl;h++){Array.prototype.push.apply(allpoints,holes[h]);}//console.log( "allpoints",allpoints, allpoints.length );
// prepare all points map
for(i=0,il=allpoints.length;i<il;i++){key=allpoints[i].x+':'+allpoints[i].y;if(allPointsMap[key]!==undefined){console.warn('THREE.ShapeUtils: Duplicate point',key,i);}allPointsMap[key]=i;}// remove holes by cutting paths to holes and adding them to the shape
var shapeWithoutHoles=removeHoles(contour,holes);var triangles=ShapeUtils.triangulate(shapeWithoutHoles,false);// True returns indices for points of spooled shape
//console.log( "triangles",triangles, triangles.length );
// check all face vertices against all points map
for(i=0,il=triangles.length;i<il;i++){face=triangles[i];for(f=0;f<3;f++){key=face[f].x+':'+face[f].y;index=allPointsMap[key];if(index!==undefined){face[f]=index;}}}return triangles.concat();},isClockWise:function isClockWise(pts){return ShapeUtils.area(pts)<0;}};/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  amount: <int>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *  frames: <Object> // containing arrays of tangents, normals, binormals
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */// ExtrudeGeometry
function ExtrudeGeometry(shapes,options){Geometry.call(this);this.type='ExtrudeGeometry';this.parameters={shapes:shapes,options:options};this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes,options));this.mergeVertices();}ExtrudeGeometry.prototype=Object.create(Geometry.prototype);ExtrudeGeometry.prototype.constructor=ExtrudeGeometry;// ExtrudeBufferGeometry
function ExtrudeBufferGeometry(shapes,options){if(typeof shapes==="undefined"){return;}BufferGeometry.call(this);this.type='ExtrudeBufferGeometry';shapes=Array.isArray(shapes)?shapes:[shapes];this.addShapeList(shapes,options);this.computeVertexNormals();// can't really use automatic vertex normals
// as then front and back sides get smoothed too
// should do separate smoothing just for sides
//this.computeVertexNormals();
//console.log( "took", ( Date.now() - startTime ) );
}ExtrudeBufferGeometry.prototype=Object.create(BufferGeometry.prototype);ExtrudeBufferGeometry.prototype.constructor=ExtrudeBufferGeometry;ExtrudeBufferGeometry.prototype.getArrays=function(){var positionAttribute=this.getAttribute("position");var verticesArray=positionAttribute?Array.prototype.slice.call(positionAttribute.array):[];var uvAttribute=this.getAttribute("uv");var uvArray=uvAttribute?Array.prototype.slice.call(uvAttribute.array):[];var IndexAttribute=this.index;var indicesArray=IndexAttribute?Array.prototype.slice.call(IndexAttribute.array):[];return{position:verticesArray,uv:uvArray,index:indicesArray};};ExtrudeBufferGeometry.prototype.addShapeList=function(shapes,options){var sl=shapes.length;options.arrays=this.getArrays();for(var s=0;s<sl;s++){var shape=shapes[s];this.addShape(shape,options);}this.setIndex(options.arrays.index);this.addAttribute('position',new Float32BufferAttribute(options.arrays.position,3));this.addAttribute('uv',new Float32BufferAttribute(options.arrays.uv,2));};ExtrudeBufferGeometry.prototype.addShape=function(shape,options){var arrays=options.arrays?options.arrays:this.getArrays();var verticesArray=arrays.position;var indicesArray=arrays.index;var uvArray=arrays.uv;var placeholder=[];var amount=options.amount!==undefined?options.amount:100;var bevelThickness=options.bevelThickness!==undefined?options.bevelThickness:6;// 10
var bevelSize=options.bevelSize!==undefined?options.bevelSize:bevelThickness-2;// 8
var bevelSegments=options.bevelSegments!==undefined?options.bevelSegments:3;var bevelEnabled=options.bevelEnabled!==undefined?options.bevelEnabled:true;// false
var curveSegments=options.curveSegments!==undefined?options.curveSegments:12;var steps=options.steps!==undefined?options.steps:1;var extrudePath=options.extrudePath;var extrudePts,extrudeByPath=false;// Use default WorldUVGenerator if no UV generators are specified.
var uvgen=options.UVGenerator!==undefined?options.UVGenerator:ExtrudeGeometry.WorldUVGenerator;var splineTube,binormal,normal,position2;if(extrudePath){extrudePts=extrudePath.getSpacedPoints(steps);extrudeByPath=true;bevelEnabled=false;// bevels not supported for path extrusion
// SETUP TNB variables
// TODO1 - have a .isClosed in spline?
splineTube=options.frames!==undefined?options.frames:extrudePath.computeFrenetFrames(steps,false);// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
binormal=new Vector3();normal=new Vector3();position2=new Vector3();}// Safeguards if bevels are not enabled
if(!bevelEnabled){bevelSegments=0;bevelThickness=0;bevelSize=0;}// Variables initialization
var ahole,h,hl;// looping of holes
var scope=this;var shapePoints=shape.extractPoints(curveSegments);var vertices=shapePoints.shape;var holes=shapePoints.holes;var reverse=!ShapeUtils.isClockWise(vertices);if(reverse){vertices=vertices.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];if(ShapeUtils.isClockWise(ahole)){holes[h]=ahole.reverse();}}}var faces=ShapeUtils.triangulateShape(vertices,holes);/* Vertices */var contour=vertices;// vertices has all points but contour has only points of circumference
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];vertices=vertices.concat(ahole);}function scalePt2(pt,vec,size){if(!vec)console.error("THREE.ExtrudeGeometry: vec does not exist");return vec.clone().multiplyScalar(size).add(pt);}var b,bs,t,z,vert,vlen=vertices.length,face,flen=faces.length;// Find directions for point movement
function getBevelVec(inPt,inPrev,inNext){// computes for inPt the corresponding point inPt' on a new contour
//   shifted by 1 unit (length of normalized vector) to the left
// if we walk along contour clockwise, this new contour is outside the old one
//
// inPt' is the intersection of the two lines parallel to the two
//  adjacent edges of inPt at a distance of 1 unit on the left side.
var v_trans_x,v_trans_y,shrink_by;// resulting translation vector for inPt
// good reading for geometry algorithms (here: line-line intersection)
// http://geomalgorithms.com/a05-_intersect-1.html
var v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y;var v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y;var v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y;// check for collinear edges
var collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;if(Math.abs(collinear0)>Number.EPSILON){// not collinear
// length of vectors for normalizing
var v_prev_len=Math.sqrt(v_prev_lensq);var v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y);// shift adjacent points by unit vectors to the left
var ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len;var ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len;var ptNextShift_x=inNext.x-v_next_y/v_next_len;var ptNextShift_y=inNext.y+v_next_x/v_next_len;// scaling factor for v_prev to intersection point
var sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-(ptNextShift_y-ptPrevShift_y)*v_next_x)/(v_prev_x*v_next_y-v_prev_y*v_next_x);// vector from inPt to intersection point
v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x;v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;// Don't normalize!, otherwise sharp corners become ugly
//  but prevent crazy spikes
var v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(v_trans_lensq<=2){return new Vector2(v_trans_x,v_trans_y);}else{shrink_by=Math.sqrt(v_trans_lensq/2);}}else{// handle special case of collinear edges
var direction_eq=false;// assumes: opposite
if(v_prev_x>Number.EPSILON){if(v_next_x>Number.EPSILON){direction_eq=true;}}else{if(v_prev_x<-Number.EPSILON){if(v_next_x<-Number.EPSILON){direction_eq=true;}}else{if(Math.sign(v_prev_y)===Math.sign(v_next_y)){direction_eq=true;}}}if(direction_eq){// console.log("Warning: lines are a straight sequence");
v_trans_x=-v_prev_y;v_trans_y=v_prev_x;shrink_by=Math.sqrt(v_prev_lensq);}else{// console.log("Warning: lines are a straight spike");
v_trans_x=v_prev_x;v_trans_y=v_prev_y;shrink_by=Math.sqrt(v_prev_lensq/2);}}return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by);}var contourMovements=[];for(var i=0,il=contour.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
// console.log('i,j,k', i, j , k)
contourMovements[i]=getBevelVec(contour[i],contour[j],contour[k]);}var holesMovements=[],oneHoleMovements,verticesMovements=contourMovements.concat();for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=[];for(i=0,il=ahole.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
oneHoleMovements[i]=getBevelVec(ahole[i],ahole[j],ahole[k]);}holesMovements.push(oneHoleMovements);verticesMovements=verticesMovements.concat(oneHoleMovements);}// Loop bevelSegments, 1 for the front, 1 for the back
for(b=0;b<bevelSegments;b++){//for ( b = bevelSegments; b > 0; b -- ) {
t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2);// contract shape
for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,-z);}// expand holes
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);v(vert.x,vert.y,-z);}}}bs=bevelSize;// Back facing vertices
for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,0);}else{// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);position2.copy(extrudePts[0]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}// Add stepped vertices...
// Including front facing vertices
var s;for(s=1;s<=steps;s++){for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,amount/steps*s);}else{// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);position2.copy(extrudePts[s]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}}// Add bevel segments planes
//for ( b = 1; b <= bevelSegments; b ++ ) {
for(b=bevelSegments-1;b>=0;b--){t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2);// contract shape
for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,amount+z);}// expand holes
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);if(!extrudeByPath){v(vert.x,vert.y,amount+z);}else{v(vert.x,vert.y+extrudePts[steps-1].y,extrudePts[steps-1].x+z);}}}}/* Faces */// Top and bottom faces
buildLidFaces();// Sides faces
buildSideFaces();/////  Internal functions
function buildLidFaces(){var start=verticesArray.length/3;if(bevelEnabled){var layer=0;// steps + 1
var offset=vlen*layer;// Bottom faces
for(i=0;i<flen;i++){face=faces[i];f3(face[2]+offset,face[1]+offset,face[0]+offset);}layer=steps+bevelSegments*2;offset=vlen*layer;// Top faces
for(i=0;i<flen;i++){face=faces[i];f3(face[0]+offset,face[1]+offset,face[2]+offset);}}else{// Bottom faces
for(i=0;i<flen;i++){face=faces[i];f3(face[2],face[1],face[0]);}// Top faces
for(i=0;i<flen;i++){face=faces[i];f3(face[0]+vlen*steps,face[1]+vlen*steps,face[2]+vlen*steps);}}scope.addGroup(start,verticesArray.length/3-start,options.material!==undefined?options.material:0);}// Create faces for the z-sides of the shape
function buildSideFaces(){var start=verticesArray.length/3;var layeroffset=0;sidewalls(contour,layeroffset);layeroffset+=contour.length;for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];sidewalls(ahole,layeroffset);//, true
layeroffset+=ahole.length;}scope.addGroup(start,verticesArray.length/3-start,options.extrudeMaterial!==undefined?options.extrudeMaterial:1);}function sidewalls(contour,layeroffset){var j,k;i=contour.length;while(--i>=0){j=i;k=i-1;if(k<0)k=contour.length-1;//console.log('b', i,j, i-1, k,vertices.length);
var s=0,sl=steps+bevelSegments*2;for(s=0;s<sl;s++){var slen1=vlen*s;var slen2=vlen*(s+1);var a=layeroffset+j+slen1,b=layeroffset+k+slen1,c=layeroffset+k+slen2,d=layeroffset+j+slen2;f4(a,b,c,d);}}}function v(x,y,z){placeholder.push(x);placeholder.push(y);placeholder.push(z);}function f3(a,b,c){addVertex(a);addVertex(b);addVertex(c);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateTopUV(scope,verticesArray,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[2]);}function f4(a,b,c,d){addVertex(a);addVertex(b);addVertex(d);addVertex(b);addVertex(c);addVertex(d);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateSideWallUV(scope,verticesArray,nextIndex-6,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[3]);addUV(uvs[1]);addUV(uvs[2]);addUV(uvs[3]);}function addVertex(index){indicesArray.push(verticesArray.length/3);verticesArray.push(placeholder[index*3+0]);verticesArray.push(placeholder[index*3+1]);verticesArray.push(placeholder[index*3+2]);}function addUV(vector2){uvArray.push(vector2.x);uvArray.push(vector2.y);}if(!options.arrays){this.setIndex(indicesArray);this.addAttribute('position',new Float32BufferAttribute(verticesArray,3));this.addAttribute('uv',new Float32BufferAttribute(options.arrays.uv,2));}};ExtrudeGeometry.WorldUVGenerator={generateTopUV:function generateTopUV(geometry,vertices,indexA,indexB,indexC){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];return[new Vector2(a_x,a_y),new Vector2(b_x,b_y),new Vector2(c_x,c_y)];},generateSideWallUV:function generateSideWallUV(geometry,vertices,indexA,indexB,indexC,indexD){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var a_z=vertices[indexA*3+2];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var b_z=vertices[indexB*3+2];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];var c_z=vertices[indexC*3+2];var d_x=vertices[indexD*3];var d_y=vertices[indexD*3+1];var d_z=vertices[indexD*3+2];if(Math.abs(a_y-b_y)<0.01){return[new Vector2(a_x,1-a_z),new Vector2(b_x,1-b_z),new Vector2(c_x,1-c_z),new Vector2(d_x,1-d_z)];}else{return[new Vector2(a_y,1-a_z),new Vector2(b_y,1-b_z),new Vector2(c_y,1-c_z),new Vector2(d_y,1-d_z)];}}};/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */// TextGeometry
function TextGeometry(text,parameters){Geometry.call(this);this.type='TextGeometry';this.parameters={text:text,parameters:parameters};this.fromBufferGeometry(new TextBufferGeometry(text,parameters));this.mergeVertices();}TextGeometry.prototype=Object.create(Geometry.prototype);TextGeometry.prototype.constructor=TextGeometry;// TextBufferGeometry
function TextBufferGeometry(text,parameters){parameters=parameters||{};var font=parameters.font;if(!(font&&font.isFont)){console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');return new Geometry();}var shapes=font.generateShapes(text,parameters.size,parameters.curveSegments);// translate parameters to ExtrudeGeometry API
parameters.amount=parameters.height!==undefined?parameters.height:50;// defaults
if(parameters.bevelThickness===undefined)parameters.bevelThickness=10;if(parameters.bevelSize===undefined)parameters.bevelSize=8;if(parameters.bevelEnabled===undefined)parameters.bevelEnabled=false;ExtrudeBufferGeometry.call(this,shapes,parameters);this.type='TextBufferGeometry';}TextBufferGeometry.prototype=Object.create(ExtrudeBufferGeometry.prototype);TextBufferGeometry.prototype.constructor=TextBufferGeometry;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 */// SphereGeometry
function SphereGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){Geometry.call(this);this.type='SphereGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength));this.mergeVertices();}SphereGeometry.prototype=Object.create(Geometry.prototype);SphereGeometry.prototype.constructor=SphereGeometry;// SphereBufferGeometry
function SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){BufferGeometry.call(this);this.type='SphereBufferGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};radius=radius||1;widthSegments=Math.max(3,Math.floor(widthSegments)||8);heightSegments=Math.max(2,Math.floor(heightSegments)||6);phiStart=phiStart!==undefined?phiStart:0;phiLength=phiLength!==undefined?phiLength:Math.PI*2;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI;var thetaEnd=thetaStart+thetaLength;var ix,iy;var index=0;var grid=[];var vertex=new Vector3();var normal=new Vector3();// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
for(iy=0;iy<=heightSegments;iy++){var verticesRow=[];var v=iy/heightSegments;for(ix=0;ix<=widthSegments;ix++){var u=ix/widthSegments;// vertex
vertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertex.y=radius*Math.cos(thetaStart+v*thetaLength);vertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normal.set(vertex.x,vertex.y,vertex.z).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u,1-v);verticesRow.push(index++);}grid.push(verticesRow);}// indices
for(iy=0;iy<heightSegments;iy++){for(ix=0;ix<widthSegments;ix++){var a=grid[iy][ix+1];var b=grid[iy][ix];var c=grid[iy+1][ix];var d=grid[iy+1][ix+1];if(iy!==0||thetaStart>0)indices.push(a,b,d);if(iy!==heightSegments-1||thetaEnd<Math.PI)indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}SphereBufferGeometry.prototype=Object.create(BufferGeometry.prototype);SphereBufferGeometry.prototype.constructor=SphereBufferGeometry;/**
	 * @author Kaleb Murphy
	 * @author Mugen87 / https://github.com/Mugen87
	 */// RingGeometry
function RingGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){Geometry.call(this);this.type='RingGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength));this.mergeVertices();}RingGeometry.prototype=Object.create(Geometry.prototype);RingGeometry.prototype.constructor=RingGeometry;// RingBufferGeometry
function RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){BufferGeometry.call(this);this.type='RingBufferGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};innerRadius=innerRadius||0.5;outerRadius=outerRadius||1;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;thetaSegments=thetaSegments!==undefined?Math.max(3,thetaSegments):8;phiSegments=phiSegments!==undefined?Math.max(1,phiSegments):1;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// some helper variables
var segment;var radius=innerRadius;var radiusStep=(outerRadius-innerRadius)/phiSegments;var vertex=new Vector3();var uv=new Vector2();var j,i;// generate vertices, normals and uvs
for(j=0;j<=phiSegments;j++){for(i=0;i<=thetaSegments;i++){// values are generate from the inside of the ring to the outside
segment=thetaStart+i/thetaSegments*thetaLength;// vertex
vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,0,1);// uv
uv.x=(vertex.x/outerRadius+1)/2;uv.y=(vertex.y/outerRadius+1)/2;uvs.push(uv.x,uv.y);}// increase the radius for next row of vertices
radius+=radiusStep;}// indices
for(j=0;j<phiSegments;j++){var thetaSegmentLevel=j*(thetaSegments+1);for(i=0;i<thetaSegments;i++){segment=i+thetaSegmentLevel;var a=segment;var b=segment+thetaSegments+1;var c=segment+thetaSegments+2;var d=segment+1;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}RingBufferGeometry.prototype=Object.create(BufferGeometry.prototype);RingBufferGeometry.prototype.constructor=RingBufferGeometry;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */// CylinderGeometry
function CylinderGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){Geometry.call(this);this.type='CylinderGeometry';this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength));this.mergeVertices();}CylinderGeometry.prototype=Object.create(Geometry.prototype);CylinderGeometry.prototype.constructor=CylinderGeometry;// CylinderBufferGeometry
function CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){BufferGeometry.call(this);this.type='CylinderBufferGeometry';this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};var scope=this;radiusTop=radiusTop!==undefined?radiusTop:1;radiusBottom=radiusBottom!==undefined?radiusBottom:1;height=height||1;radialSegments=Math.floor(radialSegments)||8;heightSegments=Math.floor(heightSegments)||1;openEnded=openEnded!==undefined?openEnded:false;thetaStart=thetaStart!==undefined?thetaStart:0.0;thetaLength=thetaLength!==undefined?thetaLength:2.0*Math.PI;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var index=0;var indexArray=[];var halfHeight=height/2;var groupStart=0;// generate geometry
generateTorso();if(openEnded===false){if(radiusTop>0)generateCap(true);if(radiusBottom>0)generateCap(false);}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));function generateTorso(){var x,y;var normal=new Vector3();var vertex=new Vector3();var groupCount=0;// this will be used to calculate the normal
var slope=(radiusBottom-radiusTop)/height;// generate vertices, normals and uvs
for(y=0;y<=heightSegments;y++){var indexRow=[];var v=y/heightSegments;// calculate the radius of the current row
var radius=v*(radiusBottom-radiusTop)+radiusTop;for(x=0;x<=radialSegments;x++){var u=x/radialSegments;var theta=u*thetaLength+thetaStart;var sinTheta=Math.sin(theta);var cosTheta=Math.cos(theta);// vertex
vertex.x=radius*sinTheta;vertex.y=-v*height+halfHeight;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
normal.set(sinTheta,slope,cosTheta).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u,1-v);// save index of vertex in respective row
indexRow.push(index++);}// now save vertices of the row in our index array
indexArray.push(indexRow);}// generate indices
for(x=0;x<radialSegments;x++){for(y=0;y<heightSegments;y++){// we use the index array to access the correct indices
var a=indexArray[y][x];var b=indexArray[y+1][x];var c=indexArray[y+1][x+1];var d=indexArray[y][x+1];// faces
indices.push(a,b,d);indices.push(b,c,d);// update group counter
groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,0);// calculate new start value for groups
groupStart+=groupCount;}function generateCap(top){var x,centerIndexStart,centerIndexEnd;var uv=new Vector2();var vertex=new Vector3();var groupCount=0;var radius=top===true?radiusTop:radiusBottom;var sign=top===true?1:-1;// save the index of the first center vertex
centerIndexStart=index;// first we generate the center vertex data of the cap.
// because the geometry needs one set of uvs per face,
// we must generate a center vertex per face/segment
for(x=1;x<=radialSegments;x++){// vertex
vertices.push(0,halfHeight*sign,0);// normal
normals.push(0,sign,0);// uv
uvs.push(0.5,0.5);// increase index
index++;}// save the index of the last center vertex
centerIndexEnd=index;// now we generate the surrounding vertices, normals and uvs
for(x=0;x<=radialSegments;x++){var u=x/radialSegments;var theta=u*thetaLength+thetaStart;var cosTheta=Math.cos(theta);var sinTheta=Math.sin(theta);// vertex
vertex.x=radius*sinTheta;vertex.y=halfHeight*sign;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,sign,0);// uv
uv.x=cosTheta*0.5+0.5;uv.y=sinTheta*0.5*sign+0.5;uvs.push(uv.x,uv.y);// increase index
index++;}// generate indices
for(x=0;x<radialSegments;x++){var c=centerIndexStart+x;var i=centerIndexEnd+x;if(top===true){// face top
indices.push(i,i+1,c);}else{// face bottom
indices.push(i+1,i,c);}groupCount+=3;}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,top===true?1:2);// calculate new start value for groups
groupStart+=groupCount;}}CylinderBufferGeometry.prototype=Object.create(BufferGeometry.prototype);CylinderBufferGeometry.prototype.constructor=CylinderBufferGeometry;/**
	 * @author abelnation / http://github.com/abelnation
	 */// ConeGeometry
function ConeGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){CylinderGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type='ConeGeometry';this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};}ConeGeometry.prototype=Object.create(CylinderGeometry.prototype);ConeGeometry.prototype.constructor=ConeGeometry;// ConeBufferGeometry
function ConeBufferGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){CylinderBufferGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type='ConeBufferGeometry';this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};}ConeBufferGeometry.prototype=Object.create(CylinderBufferGeometry.prototype);ConeBufferGeometry.prototype.constructor=ConeBufferGeometry;/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author hughes
	 */// CircleGeometry
function CircleGeometry(radius,segments,thetaStart,thetaLength){Geometry.call(this);this.type='CircleGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new CircleBufferGeometry(radius,segments,thetaStart,thetaLength));this.mergeVertices();}CircleGeometry.prototype=Object.create(Geometry.prototype);CircleGeometry.prototype.constructor=CircleGeometry;// CircleBufferGeometry
function CircleBufferGeometry(radius,segments,thetaStart,thetaLength){BufferGeometry.call(this);this.type='CircleBufferGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};radius=radius||1;segments=segments!==undefined?Math.max(3,segments):8;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var i,s;var vertex=new Vector3();var uv=new Vector2();// center point
vertices.push(0,0,0);normals.push(0,0,1);uvs.push(0.5,0.5);for(s=0,i=3;s<=segments;s++,i+=3){var segment=thetaStart+s/segments*thetaLength;// vertex
vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,0,1);// uvs
uv.x=(vertices[i]/radius+1)/2;uv.y=(vertices[i+1]/radius+1)/2;uvs.push(uv.x,uv.y);}// indices
for(i=1;i<=segments;i++){indices.push(i,i+1,0);}// build geometry
this.setIndex(indices);this.addAttribute('position',new Float32BufferAttribute(vertices,3));this.addAttribute('normal',new Float32BufferAttribute(normals,3));this.addAttribute('uv',new Float32BufferAttribute(uvs,2));}CircleBufferGeometry.prototype=Object.create(BufferGeometry.prototype);CircleBufferGeometry.prototype.constructor=CircleBufferGeometry;var Geometries=Object.freeze({ParametricGeometry:ParametricGeometry,ParametricBufferGeometry:ParametricBufferGeometry,TetrahedronGeometry:TetrahedronGeometry,TetrahedronBufferGeometry:TetrahedronBufferGeometry,OctahedronGeometry:OctahedronGeometry,OctahedronBufferGeometry:OctahedronBufferGeometry,IcosahedronGeometry:IcosahedronGeometry,IcosahedronBufferGeometry:IcosahedronBufferGeometry,PolyhedronGeometry:PolyhedronGeometry,PolyhedronBufferGeometry:PolyhedronBufferGeometry,TextGeometry:TextGeometry,TextBufferGeometry:TextBufferGeometry,SphereGeometry:SphereGeometry,SphereBufferGeometry:SphereBufferGeometry,RingGeometry:RingGeometry,RingBufferGeometry:RingBufferGeometry,PlaneGeometry:PlaneGeometry,PlaneBufferGeometry:PlaneBufferGeometry,ExtrudeGeometry:ExtrudeGeometry,ExtrudeBufferGeometry:ExtrudeBufferGeometry,ConeGeometry:ConeGeometry,ConeBufferGeometry:ConeBufferGeometry,CylinderGeometry:CylinderGeometry,CylinderBufferGeometry:CylinderBufferGeometry,CircleGeometry:CircleGeometry,CircleBufferGeometry:CircleBufferGeometry,BoxGeometry:BoxGeometry,BoxBufferGeometry:BoxBufferGeometry,ShapeGeometry:ShapeGeometry,ShapeBufferGeometry:ShapeBufferGeometry});/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  color: <THREE.Color>,
	 *  opacity: <float>
	 * }
	 */function ShadowMaterial(parameters){Material.call(this);this.type='ShadowMaterial';this.color=new Color(0x000000);this.opacity=1.0;this.lights=true;this.transparent=true;this.setValues(parameters);}ShadowMaterial.prototype=Object.create(Material.prototype);ShadowMaterial.prototype.constructor=ShadowMaterial;ShadowMaterial.prototype.isShadowMaterial=true;/**
	 * @author mrdoob / http://mrdoob.com/
	 */function RawShaderMaterial(parameters){ShaderMaterial.call(this,parameters);this.type='RawShaderMaterial';}RawShaderMaterial.prototype=Object.create(ShaderMaterial.prototype);RawShaderMaterial.prototype.constructor=RawShaderMaterial;RawShaderMaterial.prototype.isRawShaderMaterial=true;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */function MeshPhongMaterial(parameters){Material.call(this);this.type='MeshPhongMaterial';this.color=new Color(0xffffff);// diffuse
this.specular=new Color(0x111111);this.shininess=30;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshPhongMaterial.prototype=Object.create(Material.prototype);MeshPhongMaterial.prototype.constructor=MeshPhongMaterial;MeshPhongMaterial.prototype.isMeshPhongMaterial=true;MeshPhongMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};function MeshLambertMaterial(parameters){Material.call(this);this.type='MeshLambertMaterial';this.color=new Color(0xffffff);// diffuse
this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshLambertMaterial.prototype=Object.create(Material.prototype);MeshLambertMaterial.prototype.constructor=MeshLambertMaterial;MeshLambertMaterial.prototype.isMeshLambertMaterial=true;MeshLambertMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */function LineDashedMaterial(parameters){LineBasicMaterial.call(this);this.type='LineDashedMaterial';this.scale=1;this.dashSize=3;this.gapSize=1;this.setValues(parameters);}LineDashedMaterial.prototype=Object.create(LineBasicMaterial.prototype);LineDashedMaterial.prototype.constructor=LineDashedMaterial;LineDashedMaterial.prototype.isLineDashedMaterial=true;LineDashedMaterial.prototype.copy=function(source){LineBasicMaterial.prototype.copy.call(this,source);this.scale=source.scale;this.dashSize=source.dashSize;this.gapSize=source.gapSize;return this;};var Materials=Object.freeze({ShadowMaterial:ShadowMaterial,SpriteMaterial:SpriteMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshLambertMaterial:MeshLambertMaterial,MeshBasicMaterial:MeshBasicMaterial,Material:Material});/**
	 * @author mrdoob / http://mrdoob.com/
	 */var Cache={enabled:false,files:{},add:function add(key,file){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Adding key:', key );
this.files[key]=file;},get:function get(key){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Checking key:', key );
return this.files[key];},remove:function remove(key){delete this.files[key];},clear:function clear(){this.files={};}};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function LoadingManager(onLoad,onProgress,onError){var scope=this;var isLoading=false,itemsLoaded=0,itemsTotal=0;this.onStart=undefined;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;this.itemStart=function(url){itemsTotal++;if(isLoading===false){if(scope.onStart!==undefined){scope.onStart(url,itemsLoaded,itemsTotal);}}isLoading=true;};this.itemEnd=function(url){itemsLoaded++;if(scope.onProgress!==undefined){scope.onProgress(url,itemsLoaded,itemsTotal);}if(itemsLoaded===itemsTotal){isLoading=false;if(scope.onLoad!==undefined){scope.onLoad();}}};this.itemError=function(url){if(scope.onError!==undefined){scope.onError(url);}};}var DefaultLoadingManager=new LoadingManager();/**
	 * @author mrdoob / http://mrdoob.com/
	 */var loading={};function FileLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(FileLoader.prototype,{load:function load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}// Check if request is duplicate
if(loading[url]!==undefined){loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});return;}// Check for data: URI
var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=url.match(dataUriRegex);// Safari can not handle Data URIs through XMLHttpRequest so process manually
if(dataUriRegexResult){var mimeType=dataUriRegexResult[1];var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=window.decodeURIComponent(data);if(isBase64)data=window.atob(data);try{var response;var responseType=(this.responseType||'').toLowerCase();switch(responseType){case'arraybuffer':case'blob':var view=new Uint8Array(data.length);for(var i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}if(responseType==='blob'){response=new Blob([view.buffer],{type:mimeType});}else{response=view.buffer;}break;case'document':var parser=new DOMParser();response=parser.parseFromString(data,mimeType);break;case'json':response=JSON.parse(data);break;default:// 'text' or other
response=data;break;}// Wait for next browser tick like standard XMLHttpRequest event dispatching does
window.setTimeout(function(){if(onLoad)onLoad(response);scope.manager.itemEnd(url);},0);}catch(error){// Wait for next browser tick like standard XMLHttpRequest event dispatching does
window.setTimeout(function(){if(onError)onError(error);scope.manager.itemEnd(url);scope.manager.itemError(url);},0);}}else{// Initialise array for duplicate requests
loading[url]=[];loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});var request=new XMLHttpRequest();request.open('GET',url,true);request.addEventListener('load',function(event){var response=event.target.response;Cache.add(url,response);var callbacks=loading[url];delete loading[url];if(this.status===200){for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onLoad)callback.onLoad(response);}scope.manager.itemEnd(url);}else if(this.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
// e.g. 'file://' or 'data://'. Handle as success.
console.warn('THREE.FileLoader: HTTP Status 0 received.');for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onLoad)callback.onLoad(response);}scope.manager.itemEnd(url);}else{for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onError)callback.onError(event);}scope.manager.itemEnd(url);scope.manager.itemError(url);}},false);request.addEventListener('progress',function(event){var callbacks=loading[url];for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onProgress)callback.onProgress(event);}},false);request.addEventListener('error',function(event){var callbacks=loading[url];for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onError)callback.onError(event);}scope.manager.itemEnd(url);scope.manager.itemError(url);},false);if(this.responseType!==undefined)request.responseType=this.responseType;if(this.withCredentials!==undefined)request.withCredentials=this.withCredentials;if(request.overrideMimeType)request.overrideMimeType(this.mimeType!==undefined?this.mimeType:'text/plain');for(var header in this.requestHeader){request.setRequestHeader(header,this.requestHeader[header]);}request.send(null);}scope.manager.itemStart(url);return request;},setPath:function setPath(value){this.path=value;return this;},setResponseType:function setResponseType(value){this.responseType=value;return this;},setWithCredentials:function setWithCredentials(value){this.withCredentials=value;return this;},setMimeType:function setMimeType(value){this.mimeType=value;return this;},setRequestHeader:function setRequestHeader(value){this.requestHeader=value;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */function CompressedTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;// override in sub classes
this._parser=null;}Object.assign(CompressedTextureLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var images=[];var texture=new CompressedTexture();texture.image=images;var loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType('arraybuffer');function loadTexture(i){loader.load(url[i],function(buffer){var texDatas=scope._parser(buffer,true);images[i]={width:texDatas.width,height:texDatas.height,format:texDatas.format,mipmaps:texDatas.mipmaps};loaded+=1;if(loaded===6){if(texDatas.mipmapCount===1)texture.minFilter=LinearFilter;texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);}},onProgress,onError);}if(Array.isArray(url)){var loaded=0;for(var i=0,il=url.length;i<il;++i){loadTexture(i);}}else{// compressed cubemap texture stored in a single DDS file
loader.load(url,function(buffer){var texDatas=scope._parser(buffer,true);if(texDatas.isCubemap){var faces=texDatas.mipmaps.length/texDatas.mipmapCount;for(var f=0;f<faces;f++){images[f]={mipmaps:[]};for(var i=0;i<texDatas.mipmapCount;i++){images[f].mipmaps.push(texDatas.mipmaps[f*texDatas.mipmapCount+i]);images[f].format=texDatas.format;images[f].width=texDatas.width;images[f].height=texDatas.height;}}}else{texture.image.width=texDatas.width;texture.image.height=texDatas.height;texture.mipmaps=texDatas.mipmaps;}if(texDatas.mipmapCount===1){texture.minFilter=LinearFilter;}texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);},onProgress,onError);}return texture;},setPath:function setPath(value){this.path=value;return this;}});/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */function DataTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;// override in sub classes
this._parser=null;}Object.assign(DataTextureLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var texture=new DataTexture();var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.load(url,function(buffer){var texData=scope._parser(buffer);if(!texData)return;if(undefined!==texData.image){texture.image=texData.image;}else if(undefined!==texData.data){texture.image.width=texData.width;texture.image.height=texData.height;texture.image.data=texData.data;}texture.wrapS=undefined!==texData.wrapS?texData.wrapS:ClampToEdgeWrapping;texture.wrapT=undefined!==texData.wrapT?texData.wrapT:ClampToEdgeWrapping;texture.magFilter=undefined!==texData.magFilter?texData.magFilter:LinearFilter;texture.minFilter=undefined!==texData.minFilter?texData.minFilter:LinearMipMapLinearFilter;texture.anisotropy=undefined!==texData.anisotropy?texData.anisotropy:1;if(undefined!==texData.format){texture.format=texData.format;}if(undefined!==texData.type){texture.type=texData.type;}if(undefined!==texData.mipmaps){texture.mipmaps=texData.mipmaps;}if(1===texData.mipmapCount){texture.minFilter=LinearFilter;}texture.needsUpdate=true;if(onLoad)onLoad(texture,texData);},onProgress,onError);return texture;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function ImageLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(ImageLoader.prototype,{crossOrigin:'Anonymous',load:function load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}var image=document.createElement('img');image.addEventListener('load',function(){Cache.add(url,this);if(onLoad)onLoad(this);scope.manager.itemEnd(url);},false);/*
			image.addEventListener( 'progress', function ( event ) {

				if ( onProgress ) onProgress( event );

			}, false );
			*/image.addEventListener('error',function(event){if(onError)onError(event);scope.manager.itemEnd(url);scope.manager.itemError(url);},false);if(url.substr(0,5)!=='data:'){if(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;}scope.manager.itemStart(url);image.src=url;return image;},setCrossOrigin:function setCrossOrigin(value){this.crossOrigin=value;return this;},setPath:function setPath(value){this.path=value;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function CubeTextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(CubeTextureLoader.prototype,{crossOrigin:'Anonymous',load:function load(urls,onLoad,onProgress,onError){var texture=new CubeTexture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);var loaded=0;function loadTexture(i){loader.load(urls[i],function(image){texture.images[i]=image;loaded++;if(loaded===6){texture.needsUpdate=true;if(onLoad)onLoad(texture);}},undefined,onError);}for(var i=0;i<urls.length;++i){loadTexture(i);}return texture;},setCrossOrigin:function setCrossOrigin(value){this.crossOrigin=value;return this;},setPath:function setPath(value){this.path=value;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function TextureLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(TextureLoader.prototype,{crossOrigin:'Anonymous',load:function load(url,onLoad,onProgress,onError){var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);var texture=new Texture();texture.image=loader.load(url,function(){// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
var isJPEG=url.search(/\.(jpg|jpeg)$/)>0||url.search(/^data\:image\/jpeg/)===0;texture.format=isJPEG?RGBFormat:RGBAFormat;texture.needsUpdate=true;if(onLoad!==undefined){onLoad(texture);}},onProgress,onError);return texture;},setCrossOrigin:function setCrossOrigin(value){this.crossOrigin=value;return this;},setPath:function setPath(value){this.path=value;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function Light(color,intensity){Object3D.call(this);this.type='Light';this.color=new Color(color);this.intensity=intensity!==undefined?intensity:1;this.receiveShadow=undefined;}Light.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Light,isLight:true,copy:function copy(source){Object3D.prototype.copy.call(this,source);this.color.copy(source.color);this.intensity=source.intensity;return this;},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();return data;}});/**
	 * @author alteredq / http://alteredqualia.com/
	 */function HemisphereLight(skyColor,groundColor,intensity){Light.call(this,skyColor,intensity);this.type='HemisphereLight';this.castShadow=undefined;this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.groundColor=new Color(groundColor);}HemisphereLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:HemisphereLight,isHemisphereLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.groundColor.copy(source.groundColor);return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function LightShadow(camera){this.camera=camera;this.bias=0;this.radius=1;this.mapSize=new Vector2(512,512);this.map=null;this.matrix=new Matrix4();}Object.assign(LightShadow.prototype,{copy:function copy(source){this.camera=source.camera.clone();this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this;},clone:function clone(){return new this.constructor().copy(this);},toJSON:function toJSON(){var object={};if(this.bias!==0)object.bias=this.bias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function SpotLightShadow(){LightShadow.call(this,new PerspectiveCamera(50,1,0.5,500));}SpotLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:SpotLightShadow,isSpotLightShadow:true,update:function update(light){var camera=this.camera;var fov=_Math.RAD2DEG*2*light.angle;var aspect=this.mapSize.width/this.mapSize.height;var far=light.distance||camera.far;if(fov!==camera.fov||aspect!==camera.aspect||far!==camera.far){camera.fov=fov;camera.aspect=aspect;camera.far=far;camera.updateProjectionMatrix();}}});/**
	 * @author alteredq / http://alteredqualia.com/
	 */function SpotLight(color,intensity,distance,angle,penumbra,decay){Light.call(this,color,intensity);this.type='SpotLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();Object.defineProperty(this,'power',{get:function get(){// intensity = power per solid angle.
// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
return this.intensity*Math.PI;},set:function set(power){// intensity = power per solid angle.
// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
this.intensity=power/Math.PI;}});this.distance=distance!==undefined?distance:0;this.angle=angle!==undefined?angle:Math.PI/3;this.penumbra=penumbra!==undefined?penumbra:0;this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.
this.shadow=new SpotLightShadow();}SpotLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:SpotLight,isSpotLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.distance=source.distance;this.angle=source.angle;this.penumbra=source.penumbra;this.decay=source.decay;this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function PointLight(color,intensity,distance,decay){Light.call(this,color,intensity);this.type='PointLight';Object.defineProperty(this,'power',{get:function get(){// intensity = power per solid angle.
// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
return this.intensity*4*Math.PI;},set:function set(power){// intensity = power per solid angle.
// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
this.intensity=power/(4*Math.PI);}});this.distance=distance!==undefined?distance:0;this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.
this.shadow=new LightShadow(new PerspectiveCamera(90,1,0.5,500));}PointLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:PointLight,isPointLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.distance=source.distance;this.decay=source.decay;this.shadow=source.shadow.clone();return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function DirectionalLightShadow(){LightShadow.call(this,new OrthographicCamera(-5,5,5,-5,0.5,500));}DirectionalLightShadow.prototype=Object.assign(Object.create(LightShadow.prototype),{constructor:DirectionalLightShadow});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function DirectionalLight(color,intensity){Light.call(this,color,intensity);this.type='DirectionalLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();this.shadow=new DirectionalLightShadow();}DirectionalLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:DirectionalLight,isDirectionalLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function AmbientLight(color,intensity){Light.call(this,color,intensity);this.type='AmbientLight';this.castShadow=undefined;}AmbientLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:AmbientLight,isAmbientLight:true});/**
	 * @author abelnation / http://github.com/abelnation
	 */function RectAreaLight(color,intensity,width,height){Light.call(this,color,intensity);this.type='RectAreaLight';this.position.set(0,1,0);this.updateMatrix();this.width=width!==undefined?width:10;this.height=height!==undefined?height:10;// TODO (abelnation): distance/decay
// TODO (abelnation): update method for RectAreaLight to update transform to lookat target
// TODO (abelnation): shadows
}// TODO (abelnation): RectAreaLight update when light shape is changed
RectAreaLight.prototype=Object.assign(Object.create(Light.prototype),{constructor:RectAreaLight,isRectAreaLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.width=source.width;this.height=source.height;return this;},toJSON:function toJSON(meta){var data=Light.prototype.toJSON.call(this,meta);data.object.width=this.width;data.object.height=this.height;return data;}});/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */var AnimationUtils={// same as Array.prototype.slice, but also works on typed arrays
arraySlice:function arraySlice(array,from,to){if(AnimationUtils.isTypedArray(array)){// in ios9 array.subarray(from, undefined) will return empty array
// but array.subarray(from) or array.subarray(from, len) is correct
return new array.constructor(array.subarray(from,to!==undefined?to:array.length));}return array.slice(from,to);},// converts an array to a specific type
convertArray:function convertArray(array,type,forceClone){if(!array||// let 'undefined' and 'null' pass
!forceClone&&array.constructor===type)return array;if(typeof type.BYTES_PER_ELEMENT==='number'){return new type(array);// create typed array
}return Array.prototype.slice.call(array);// create Array
},isTypedArray:function isTypedArray(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView);},// returns an array by which times and values can be sorted
getKeyframeOrder:function getKeyframeOrder(times){function compareTime(i,j){return times[i]-times[j];}var n=times.length;var result=new Array(n);for(var i=0;i!==n;++i){result[i]=i;}result.sort(compareTime);return result;},// uses the array previously returned by 'getKeyframeOrder' to sort data
sortedArray:function sortedArray(values,stride,order){var nValues=values.length;var result=new values.constructor(nValues);for(var i=0,dstOffset=0;dstOffset!==nValues;++i){var srcOffset=order[i]*stride;for(var j=0;j!==stride;++j){result[dstOffset++]=values[srcOffset+j];}}return result;},// function for parsing AOS keyframe formats
flattenJSON:function flattenJSON(jsonKeys,times,values,valuePropertyName){var i=1,key=jsonKeys[0];while(key!==undefined&&key[valuePropertyName]===undefined){key=jsonKeys[i++];}if(key===undefined)return;// no data
var value=key[valuePropertyName];if(value===undefined)return;// no data
if(Array.isArray(value)){do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push.apply(values,value);// push all elements
}key=jsonKeys[i++];}while(key!==undefined);}else if(value.toArray!==undefined){// ...assume THREE.Math-ish
do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);value.toArray(values,values.length);}key=jsonKeys[i++];}while(key!==undefined);}else{// otherwise push as-is
do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push(value);}key=jsonKeys[i++];}while(key!==undefined);}}};/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */function Interpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){this.parameterPositions=parameterPositions;this._cachedIndex=0;this.resultBuffer=resultBuffer!==undefined?resultBuffer:new sampleValues.constructor(sampleSize);this.sampleValues=sampleValues;this.valueSize=sampleSize;}Object.assign(Interpolant.prototype,{evaluate:function evaluate(t){var pp=this.parameterPositions,i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{var right;linear_scan:{//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
forward_scan:if(!(t<t1)){for(var giveUpAt=i1+2;;){if(t1===undefined){if(t<t0)break forward_scan;// after end
i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t,t0);}if(i1===giveUpAt)break;// this loop
t0=t1;t1=pp[++i1];if(t<t1){// we have arrived at the sought interval
break seek;}}// prepare binary search on the right side of the index
right=pp.length;break linear_scan;}//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
if(!(t>=t0)){// looping?
var t1global=pp[1];if(t<t1global){i1=2;// + 1, using the scan for the details
t0=t1global;}// linear reverse scan
for(var giveUpAt=i1-2;;){if(t0===undefined){// before start
this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(i1===giveUpAt)break;// this loop
t1=t0;t0=pp[--i1-1];if(t>=t0){// we have arrived at the sought interval
break seek;}}// prepare binary search on the left side of the index
right=i1;i1=0;break linear_scan;}// the interval is valid
break validate_interval;}// linear scan
// binary search
while(i1<right){var mid=i1+right>>>1;if(t<pp[mid]){right=mid;}else{i1=mid+1;}}t1=pp[i1];t0=pp[i1-1];// check boundary cases, again
if(t0===undefined){this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(t1===undefined){i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t0,t);}}// seek
this._cachedIndex=i1;this.intervalChanged_(i1,t0,t1);}// validate_interval
return this.interpolate_(i1,t0,t,t1);},settings:null,// optional, subclass-specific settings structure
// Note: The indirection allows central control of many interpolants.
// --- Protected interface
DefaultSettings_:{},getSettings_:function getSettings_(){return this.settings||this.DefaultSettings_;},copySampleValue_:function copySampleValue_(index){// copies a sample value to the result buffer
var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(var i=0;i!==stride;++i){result[i]=values[offset+i];}return result;},// Template methods for derived classes:
interpolate_:function interpolate_()/* i1, t0, t, t1 */{throw new Error('call to abstract method');// implementations shall return this.resultBuffer
},intervalChanged_:function intervalChanged_()/* i1, t0, t1 */{// empty
}});//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(Interpolant.prototype,{//( 0, t, t0 ), returns this.resultBuffer
beforeStart_:Interpolant.prototype.copySampleValue_,//( N-1, tN-1, t ), returns this.resultBuffer
afterEnd_:Interpolant.prototype.copySampleValue_});/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */function CubicInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);this._weightPrev=-0;this._offsetPrev=-0;this._weightNext=-0;this._offsetNext=-0;}CubicInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:CubicInterpolant,DefaultSettings_:{endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding},intervalChanged_:function intervalChanged_(i1,t0,t1){var pp=this.parameterPositions,iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(tPrev===undefined){switch(this.getSettings_().endingStart){case ZeroSlopeEnding:// f'(t0) = 0
iPrev=i1;tPrev=2*t0-t1;break;case WrapAroundEnding:// use the other end of the curve
iPrev=pp.length-2;tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:// ZeroCurvatureEnding
// f''(t0) = 0 a.k.a. Natural Spline
iPrev=i1;tPrev=t1;}}if(tNext===undefined){switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:// f'(tN) = 0
iNext=i1;tNext=2*t1-t0;break;case WrapAroundEnding:// use the other end of the curve
iNext=1;tNext=t1+pp[1]-pp[0];break;default:// ZeroCurvatureEnding
// f''(tN) = 0, a.k.a. Natural Spline
iNext=i1-1;tNext=t0;}}var halfDt=(t1-t0)*0.5,stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev);this._weightNext=halfDt/(tNext-t1);this._offsetPrev=iPrev*stride;this._offsetNext=iNext*stride;},interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0),pp=p*p,ppp=pp*p;// evaluate polynomials
var sP=-wP*ppp+2*wP*pp-wP*p;var s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;var s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;var sN=wN*ppp-wN*pp;// combine data linearly
for(var i=0;i!==stride;++i){result[i]=sP*values[oP+i]+s0*values[o0+i]+s1*values[o1+i]+sN*values[oN+i];}return result;}});/**
	 * @author tschw
	 */function LinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}LinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:LinearInterpolant,interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(var i=0;i!==stride;++i){result[i]=values[offset0+i]*weight0+values[offset1+i]*weight1;}return result;}});/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */function DiscreteInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}DiscreteInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:DiscreteInterpolant,interpolate_:function interpolate_(i1/*, t0, t, t1 */){return this.copySampleValue_(i1-1);}});var KeyframeTrackPrototype;KeyframeTrackPrototype={TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodDiscrete:function InterpolantFactoryMethodDiscrete(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:function InterpolantFactoryMethodSmooth(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result);},setInterpolation:function setInterpolation(interpolation){var factoryMethod;switch(interpolation){case InterpolateDiscrete:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:factoryMethod=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:factoryMethod=this.InterpolantFactoryMethodSmooth;break;}if(factoryMethod===undefined){var message="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===undefined){// fall back to default, unless the default itself is messed up
if(interpolation!==this.DefaultInterpolation){this.setInterpolation(this.DefaultInterpolation);}else{throw new Error(message);// fatal, in this case
}}console.warn('THREE.KeyframeTrackPrototype:',message);return;}this.createInterpolant=factoryMethod;},getInterpolation:function getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth;}},getValueSize:function getValueSize(){return this.values.length/this.times.length;},// move all keyframes either forwards or backwards in time
shift:function shift(timeOffset){if(timeOffset!==0.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]+=timeOffset;}}return this;},// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
scale:function scale(timeScale){if(timeScale!==1.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]*=timeScale;}}return this;},// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
trim:function trim(startTime,endTime){var times=this.times,nKeys=times.length,from=0,to=nKeys-1;while(from!==nKeys&&times[from]<startTime){++from;}while(to!==-1&&times[to]>endTime){--to;}++to;// inclusive -> exclusive bound
if(from!==0||to!==nKeys){// empty tracks are forbidden, so keep at least one keyframe
if(from>=to)to=Math.max(to,1),from=to-1;var stride=this.getValueSize();this.times=AnimationUtils.arraySlice(times,from,to);this.values=AnimationUtils.arraySlice(this.values,from*stride,to*stride);}return this;},// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
validate:function validate(){var valid=true;var valueSize=this.getValueSize();if(valueSize-Math.floor(valueSize)!==0){console.error('THREE.KeyframeTrackPrototype: Invalid value size in track.',this);valid=false;}var times=this.times,values=this.values,nKeys=times.length;if(nKeys===0){console.error('THREE.KeyframeTrackPrototype: Track is empty.',this);valid=false;}var prevTime=null;for(var i=0;i!==nKeys;i++){var currTime=times[i];if(typeof currTime==='number'&&isNaN(currTime)){console.error('THREE.KeyframeTrackPrototype: Time is not a valid number.',this,i,currTime);valid=false;break;}if(prevTime!==null&&prevTime>currTime){console.error('THREE.KeyframeTrackPrototype: Out of order keys.',this,i,currTime,prevTime);valid=false;break;}prevTime=currTime;}if(values!==undefined){if(AnimationUtils.isTypedArray(values)){for(var i=0,n=values.length;i!==n;++i){var value=values[i];if(isNaN(value)){console.error('THREE.KeyframeTrackPrototype: Value is not a valid number.',this,i,value);valid=false;break;}}}}return valid;},// removes equivalent sequential keys as common in morph target sequences
// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
optimize:function optimize(){var times=this.times,values=this.values,stride=this.getValueSize(),smoothInterpolation=this.getInterpolation()===InterpolateSmooth,writeIndex=1,lastIndex=times.length-1;for(var i=1;i<lastIndex;++i){var keep=false;var time=times[i];var timeNext=times[i+1];// remove adjacent keyframes scheduled at the same time
if(time!==timeNext&&(i!==1||time!==time[0])){if(!smoothInterpolation){// remove unnecessary keyframes same as their neighbors
var offset=i*stride,offsetP=offset-stride,offsetN=offset+stride;for(var j=0;j!==stride;++j){var value=values[offset+j];if(value!==values[offsetP+j]||value!==values[offsetN+j]){keep=true;break;}}}else keep=true;}// in-place compaction
if(keep){if(i!==writeIndex){times[writeIndex]=times[i];var readOffset=i*stride,writeOffset=writeIndex*stride;for(var j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}}++writeIndex;}}// flush last keyframe (compaction looks ahead)
if(lastIndex>0){times[writeIndex]=times[lastIndex];for(var readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}++writeIndex;}if(writeIndex!==times.length){this.times=AnimationUtils.arraySlice(times,0,writeIndex);this.values=AnimationUtils.arraySlice(values,0,writeIndex*stride);}return this;}};function KeyframeTrackConstructor(name,times,values,interpolation){if(name===undefined)throw new Error('track name is undefined');if(times===undefined||times.length===0){throw new Error('no keyframes in track named '+name);}this.name=name;this.times=AnimationUtils.convertArray(times,this.TimeBufferType);this.values=AnimationUtils.convertArray(values,this.ValueBufferType);this.setInterpolation(interpolation||this.DefaultInterpolation);this.validate();this.optimize();}/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function VectorKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}VectorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:VectorKeyframeTrack,ValueTypeName:'vector'// ValueBufferType is inherited
// DefaultInterpolation is inherited
});/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */function QuaternionLinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}QuaternionLinearInterpolant.prototype=Object.assign(Object.create(Interpolant.prototype),{constructor:QuaternionLinearInterpolant,interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=i1*stride,alpha=(t-t0)/(t1-t0);for(var end=offset+stride;offset!==end;offset+=4){Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha);}return result;}});/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function QuaternionKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}QuaternionKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:QuaternionKeyframeTrack,ValueTypeName:'quaternion',// ValueBufferType is inherited
DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:undefined// not yet implemented
});/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function NumberKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}NumberKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:NumberKeyframeTrack,ValueTypeName:'number'// ValueBufferType is inherited
// DefaultInterpolation is inherited
});/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function StringKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}StringKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:StringKeyframeTrack,ValueTypeName:'string',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined});/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function BooleanKeyframeTrack(name,times,values){KeyframeTrackConstructor.call(this,name,times,values);}BooleanKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:BooleanKeyframeTrack,ValueTypeName:'bool',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined// Note: Actually this track could have a optimized / compressed
// representation of a single value and a custom interpolant that
// computes "firstValue ^ isOdd( index )".
});/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function ColorKeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.call(this,name,times,values,interpolation);}ColorKeyframeTrack.prototype=Object.assign(Object.create(KeyframeTrackPrototype),{constructor:ColorKeyframeTrack,ValueTypeName:'color'// ValueBufferType is inherited
// DefaultInterpolation is inherited
// Note: Very basic implementation and nothing special yet.
// However, this is the place for color space parameterization.
});/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function KeyframeTrack(name,times,values,interpolation){KeyframeTrackConstructor.apply(this,name,times,values,interpolation);}KeyframeTrack.prototype=KeyframeTrackPrototype;KeyframeTrackPrototype.constructor=KeyframeTrack;// Static methods:
Object.assign(KeyframeTrack,{// Serialization (in static context, because of constructor invocation
// and automatic invocation of .toJSON):
parse:function parse(json){if(json.type===undefined){throw new Error('track type undefined, can not parse');}var trackType=KeyframeTrack._getTrackTypeForValueTypeName(json.type);if(json.times===undefined){var times=[],values=[];AnimationUtils.flattenJSON(json.keys,times,values,'value');json.times=times;json.values=values;}// derived classes can define a static parse method
if(trackType.parse!==undefined){return trackType.parse(json);}else{// by default, we assume a constructor compatible with the base
return new trackType(json.name,json.times,json.values,json.interpolation);}},toJSON:function toJSON(track){var trackType=track.constructor;var json;// derived classes can define a static toJSON method
if(trackType.toJSON!==undefined){json=trackType.toJSON(track);}else{// by default, we assume the data can be serialized as-is
json={'name':track.name,'times':AnimationUtils.convertArray(track.times,Array),'values':AnimationUtils.convertArray(track.values,Array)};var interpolation=track.getInterpolation();if(interpolation!==track.DefaultInterpolation){json.interpolation=interpolation;}}json.type=track.ValueTypeName;// mandatory
return json;},_getTrackTypeForValueTypeName:function _getTrackTypeForValueTypeName(typeName){switch(typeName.toLowerCase()){case'scalar':case'double':case'float':case'number':case'integer':return NumberKeyframeTrack;case'vector':case'vector2':case'vector3':case'vector4':return VectorKeyframeTrack;case'color':return ColorKeyframeTrack;case'quaternion':return QuaternionKeyframeTrack;case'bool':case'boolean':return BooleanKeyframeTrack;case'string':return StringKeyframeTrack;}throw new Error('Unsupported typeName: '+typeName);}});/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */function AnimationClip(name,duration,tracks){this.name=name;this.tracks=tracks;this.duration=duration!==undefined?duration:-1;this.uuid=_Math.generateUUID();// this means it should figure out its duration by scanning the tracks
if(this.duration<0){this.resetDuration();}this.optimize();}Object.assign(AnimationClip,{parse:function parse(json){var tracks=[],jsonTracks=json.tracks,frameTime=1.0/(json.fps||1.0);for(var i=0,n=jsonTracks.length;i!==n;++i){tracks.push(KeyframeTrack.parse(jsonTracks[i]).scale(frameTime));}return new AnimationClip(json.name,json.duration,tracks);},toJSON:function toJSON(clip){var tracks=[],clipTracks=clip.tracks;var json={'name':clip.name,'duration':clip.duration,'tracks':tracks};for(var i=0,n=clipTracks.length;i!==n;++i){tracks.push(KeyframeTrack.toJSON(clipTracks[i]));}return json;},CreateFromMorphTargetSequence:function CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){var numMorphTargets=morphTargetSequence.length;var tracks=[];for(var i=0;i<numMorphTargets;i++){var times=[];var values=[];times.push((i+numMorphTargets-1)%numMorphTargets,i,(i+1)%numMorphTargets);values.push(0,1,0);var order=AnimationUtils.getKeyframeOrder(times);times=AnimationUtils.sortedArray(times,1,order);values=AnimationUtils.sortedArray(values,1,order);// if there is a key at the first frame, duplicate it as the
// last frame as well for perfect loop.
if(!noLoop&&times[0]===0){times.push(numMorphTargets);values.push(values[0]);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluences['+morphTargetSequence[i].name+']',times,values).scale(1.0/fps));}return new AnimationClip(name,-1,tracks);},findByName:function findByName(objectOrClipArray,name){var clipArray=objectOrClipArray;if(!Array.isArray(objectOrClipArray)){var o=objectOrClipArray;clipArray=o.geometry&&o.geometry.animations||o.animations;}for(var i=0;i<clipArray.length;i++){if(clipArray[i].name===name){return clipArray[i];}}return null;},CreateClipsFromMorphTargetSequences:function CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){var animationToMorphTargets={};// tested with https://regex101.com/ on trick sequences
// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
var pattern=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
// patterns like Walk_001, Walk_002, Run_001, Run_002
for(var i=0,il=morphTargets.length;i<il;i++){var morphTarget=morphTargets[i];var parts=morphTarget.name.match(pattern);if(parts&&parts.length>1){var name=parts[1];var animationMorphTargets=animationToMorphTargets[name];if(!animationMorphTargets){animationToMorphTargets[name]=animationMorphTargets=[];}animationMorphTargets.push(morphTarget);}}var clips=[];for(var name in animationToMorphTargets){clips.push(AnimationClip.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));}return clips;},// parse the animation.hierarchy format
parseAnimation:function parseAnimation(animation,bones){if(!animation){console.error('THREE.AnimationClip: No animation in JSONLoader data.');return null;}var addNonemptyTrack=function addNonemptyTrack(trackType,trackName,animationKeys,propertyName,destTracks){// only return track if there are actually keys.
if(animationKeys.length!==0){var times=[];var values=[];AnimationUtils.flattenJSON(animationKeys,times,values,propertyName);// empty keys are filtered out, so check again
if(times.length!==0){destTracks.push(new trackType(trackName,times,values));}}};var tracks=[];var clipName=animation.name||'default';// automatic length determination in AnimationClip.
var duration=animation.length||-1;var fps=animation.fps||30;var hierarchyTracks=animation.hierarchy||[];for(var h=0;h<hierarchyTracks.length;h++){var animationKeys=hierarchyTracks[h].keys;// skip empty tracks
if(!animationKeys||animationKeys.length===0)continue;// process morph targets
if(animationKeys[0].morphTargets){// figure out all morph targets used in this track
var morphTargetNames={};for(var k=0;k<animationKeys.length;k++){if(animationKeys[k].morphTargets){for(var m=0;m<animationKeys[k].morphTargets.length;m++){morphTargetNames[animationKeys[k].morphTargets[m]]=-1;}}}// create a track for each morph target with all zero
// morphTargetInfluences except for the keys in which
// the morphTarget is named.
for(var morphTargetName in morphTargetNames){var times=[];var values=[];for(var m=0;m!==animationKeys[k].morphTargets.length;++m){var animationKey=animationKeys[k];times.push(animationKey.time);values.push(animationKey.morphTarget===morphTargetName?1:0);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluence['+morphTargetName+']',times,values));}duration=morphTargetNames.length*(fps||1.0);}else{// ...assume skeletal animation
var boneName='.bones['+bones[h].name+']';addNonemptyTrack(VectorKeyframeTrack,boneName+'.position',animationKeys,'pos',tracks);addNonemptyTrack(QuaternionKeyframeTrack,boneName+'.quaternion',animationKeys,'rot',tracks);addNonemptyTrack(VectorKeyframeTrack,boneName+'.scale',animationKeys,'scl',tracks);}}if(tracks.length===0){return null;}var clip=new AnimationClip(clipName,duration,tracks);return clip;}});Object.assign(AnimationClip.prototype,{resetDuration:function resetDuration(){var tracks=this.tracks,duration=0;for(var i=0,n=tracks.length;i!==n;++i){var track=this.tracks[i];duration=Math.max(duration,track.times[track.times.length-1]);}this.duration=duration;},trim:function trim(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].trim(0,this.duration);}return this;},optimize:function optimize(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].optimize();}return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function MaterialLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.textures={};}Object.assign(MaterialLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.load(url,function(text){onLoad(scope.parse(JSON.parse(text)));},onProgress,onError);},setTextures:function setTextures(value){this.textures=value;},parse:function parse(json){var textures=this.textures;function getTexture(name){if(textures[name]===undefined){console.warn('THREE.MaterialLoader: Undefined texture',name);}return textures[name];}var material=new Materials[json.type]();if(json.uuid!==undefined)material.uuid=json.uuid;if(json.name!==undefined)material.name=json.name;if(json.color!==undefined)material.color.setHex(json.color);if(json.roughness!==undefined)material.roughness=json.roughness;if(json.metalness!==undefined)material.metalness=json.metalness;if(json.emissive!==undefined)material.emissive.setHex(json.emissive);if(json.specular!==undefined)material.specular.setHex(json.specular);if(json.shininess!==undefined)material.shininess=json.shininess;if(json.clearCoat!==undefined)material.clearCoat=json.clearCoat;if(json.clearCoatRoughness!==undefined)material.clearCoatRoughness=json.clearCoatRoughness;if(json.uniforms!==undefined)material.uniforms=json.uniforms;if(json.vertexShader!==undefined)material.vertexShader=json.vertexShader;if(json.fragmentShader!==undefined)material.fragmentShader=json.fragmentShader;if(json.vertexColors!==undefined)material.vertexColors=json.vertexColors;if(json.fog!==undefined)material.fog=json.fog;if(json.flatShading!==undefined)material.flatShading=json.flatShading;if(json.blending!==undefined)material.blending=json.blending;if(json.side!==undefined)material.side=json.side;if(json.opacity!==undefined)material.opacity=json.opacity;if(json.transparent!==undefined)material.transparent=json.transparent;if(json.alphaTest!==undefined)material.alphaTest=json.alphaTest;if(json.depthTest!==undefined)material.depthTest=json.depthTest;if(json.depthWrite!==undefined)material.depthWrite=json.depthWrite;if(json.colorWrite!==undefined)material.colorWrite=json.colorWrite;if(json.wireframe!==undefined)material.wireframe=json.wireframe;if(json.wireframeLinewidth!==undefined)material.wireframeLinewidth=json.wireframeLinewidth;if(json.wireframeLinecap!==undefined)material.wireframeLinecap=json.wireframeLinecap;if(json.wireframeLinejoin!==undefined)material.wireframeLinejoin=json.wireframeLinejoin;if(json.rotation!==undefined)material.rotation=json.rotation;if(json.linewidth!==1)material.linewidth=json.linewidth;if(json.dashSize!==undefined)material.dashSize=json.dashSize;if(json.gapSize!==undefined)material.gapSize=json.gapSize;if(json.scale!==undefined)material.scale=json.scale;if(json.skinning!==undefined)material.skinning=json.skinning;if(json.morphTargets!==undefined)material.morphTargets=json.morphTargets;if(json.dithering!==undefined)material.dithering=json.dithering;if(json.visible!==undefined)material.visible=json.visible;if(json.userData!==undefined)material.userData=json.userData;// Deprecated
if(json.shading!==undefined)material.flatShading=json.shading===1;// THREE.FlatShading
// for PointsMaterial
if(json.size!==undefined)material.size=json.size;if(json.sizeAttenuation!==undefined)material.sizeAttenuation=json.sizeAttenuation;// maps
if(json.map!==undefined)material.map=getTexture(json.map);if(json.alphaMap!==undefined){material.alphaMap=getTexture(json.alphaMap);material.transparent=true;}if(json.bumpMap!==undefined)material.bumpMap=getTexture(json.bumpMap);if(json.bumpScale!==undefined)material.bumpScale=json.bumpScale;if(json.normalMap!==undefined)material.normalMap=getTexture(json.normalMap);if(json.normalScale!==undefined){var normalScale=json.normalScale;if(Array.isArray(normalScale)===false){// Blender exporter used to export a scalar. See #7459
normalScale=[normalScale,normalScale];}material.normalScale=new Vector2().fromArray(normalScale);}if(json.displacementMap!==undefined)material.displacementMap=getTexture(json.displacementMap);if(json.displacementScale!==undefined)material.displacementScale=json.displacementScale;if(json.displacementBias!==undefined)material.displacementBias=json.displacementBias;if(json.roughnessMap!==undefined)material.roughnessMap=getTexture(json.roughnessMap);if(json.metalnessMap!==undefined)material.metalnessMap=getTexture(json.metalnessMap);if(json.emissiveMap!==undefined)material.emissiveMap=getTexture(json.emissiveMap);if(json.emissiveIntensity!==undefined)material.emissiveIntensity=json.emissiveIntensity;if(json.specularMap!==undefined)material.specularMap=getTexture(json.specularMap);if(json.envMap!==undefined)material.envMap=getTexture(json.envMap);if(json.reflectivity!==undefined)material.reflectivity=json.reflectivity;if(json.lightMap!==undefined)material.lightMap=getTexture(json.lightMap);if(json.lightMapIntensity!==undefined)material.lightMapIntensity=json.lightMapIntensity;if(json.aoMap!==undefined)material.aoMap=getTexture(json.aoMap);if(json.aoMapIntensity!==undefined)material.aoMapIntensity=json.aoMapIntensity;if(json.gradientMap!==undefined)material.gradientMap=getTexture(json.gradientMap);return material;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function BufferGeometryLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(BufferGeometryLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.load(url,function(text){onLoad(scope.parse(JSON.parse(text)));},onProgress,onError);},parse:function parse(json){var geometry=new BufferGeometry();var index=json.data.index;if(index!==undefined){var typedArray=new TYPED_ARRAYS[index.type](index.array);geometry.setIndex(new BufferAttribute(typedArray,1));}var attributes=json.data.attributes;for(var key in attributes){var attribute=attributes[key];var typedArray=new TYPED_ARRAYS[attribute.type](attribute.array);geometry.addAttribute(key,new BufferAttribute(typedArray,attribute.itemSize,attribute.normalized));}var groups=json.data.groups||json.data.drawcalls||json.data.offsets;if(groups!==undefined){for(var i=0,n=groups.length;i!==n;++i){var group=groups[i];geometry.addGroup(group.start,group.count,group.materialIndex);}}var boundingSphere=json.data.boundingSphere;if(boundingSphere!==undefined){var center=new Vector3();if(boundingSphere.center!==undefined){center.fromArray(boundingSphere.center);}geometry.boundingSphere=new Sphere(center,boundingSphere.radius);}return geometry;}});var TYPED_ARRAYS={Int8Array:Int8Array,Uint8Array:Uint8Array,// Workaround for IE11 pre KB2929437. See #11440
Uint8ClampedArray:typeof Uint8ClampedArray!=='undefined'?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};/**
	 * @author alteredq / http://alteredqualia.com/
	 */function Loader(){this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){};}Loader.Handlers={handlers:[],add:function add(regex,loader){this.handlers.push(regex,loader);},get:function get(file){var handlers=this.handlers;for(var i=0,l=handlers.length;i<l;i+=2){var regex=handlers[i];var loader=handlers[i+1];if(regex.test(file)){return loader;}}return null;}};Object.assign(Loader.prototype,{crossOrigin:undefined,extractUrlBase:function extractUrlBase(url){var parts=url.split('/');if(parts.length===1)return'./';parts.pop();return parts.join('/')+'/';},initMaterials:function initMaterials(materials,texturePath,crossOrigin){var array=[];for(var i=0;i<materials.length;++i){array[i]=this.createMaterial(materials[i],texturePath,crossOrigin);}return array;},createMaterial:function(){var BlendingMode={NoBlending:NoBlending,NormalBlending:NormalBlending,AdditiveBlending:AdditiveBlending,SubtractiveBlending:SubtractiveBlending,MultiplyBlending:MultiplyBlending,CustomBlending:CustomBlending};var color=new Color();var textureLoader=new TextureLoader();var materialLoader=new MaterialLoader();return function createMaterial(m,texturePath,crossOrigin){// convert from old material format
var textures={};function loadTexture(path,repeat,offset,wrap,anisotropy){var fullPath=texturePath+path;var loader=Loader.Handlers.get(fullPath);var texture;if(loader!==null){texture=loader.load(fullPath);}else{textureLoader.setCrossOrigin(crossOrigin);texture=textureLoader.load(fullPath);}if(repeat!==undefined){texture.repeat.fromArray(repeat);if(repeat[0]!==1)texture.wrapS=RepeatWrapping;if(repeat[1]!==1)texture.wrapT=RepeatWrapping;}if(offset!==undefined){texture.offset.fromArray(offset);}if(wrap!==undefined){if(wrap[0]==='repeat')texture.wrapS=RepeatWrapping;if(wrap[0]==='mirror')texture.wrapS=MirroredRepeatWrapping;if(wrap[1]==='repeat')texture.wrapT=RepeatWrapping;if(wrap[1]==='mirror')texture.wrapT=MirroredRepeatWrapping;}if(anisotropy!==undefined){texture.anisotropy=anisotropy;}var uuid=_Math.generateUUID();textures[uuid]=texture;return uuid;}//
var json={uuid:_Math.generateUUID(),type:'MeshLambertMaterial'};for(var name in m){var value=m[name];switch(name){case'DbgColor':case'DbgIndex':case'opticalDensity':case'illumination':break;case'DbgName':json.name=value;break;case'blending':json.blending=BlendingMode[value];break;case'colorAmbient':case'mapAmbient':console.warn('THREE.Loader.createMaterial:',name,'is no longer supported.');break;case'colorDiffuse':json.color=color.fromArray(value).getHex();break;case'colorSpecular':json.specular=color.fromArray(value).getHex();break;case'colorEmissive':json.emissive=color.fromArray(value).getHex();break;case'specularCoef':json.shininess=value;break;case'shading':if(value.toLowerCase()==='basic')json.type='MeshBasicMaterial';if(value.toLowerCase()==='phong')json.type='MeshPhongMaterial';if(value.toLowerCase()==='standard')json.type='MeshStandardMaterial';break;case'mapDiffuse':json.map=loadTexture(value,m.mapDiffuseRepeat,m.mapDiffuseOffset,m.mapDiffuseWrap,m.mapDiffuseAnisotropy);break;case'mapDiffuseRepeat':case'mapDiffuseOffset':case'mapDiffuseWrap':case'mapDiffuseAnisotropy':break;case'mapEmissive':json.emissiveMap=loadTexture(value,m.mapEmissiveRepeat,m.mapEmissiveOffset,m.mapEmissiveWrap,m.mapEmissiveAnisotropy);break;case'mapEmissiveRepeat':case'mapEmissiveOffset':case'mapEmissiveWrap':case'mapEmissiveAnisotropy':break;case'mapLight':json.lightMap=loadTexture(value,m.mapLightRepeat,m.mapLightOffset,m.mapLightWrap,m.mapLightAnisotropy);break;case'mapLightRepeat':case'mapLightOffset':case'mapLightWrap':case'mapLightAnisotropy':break;case'mapAO':json.aoMap=loadTexture(value,m.mapAORepeat,m.mapAOOffset,m.mapAOWrap,m.mapAOAnisotropy);break;case'mapAORepeat':case'mapAOOffset':case'mapAOWrap':case'mapAOAnisotropy':break;case'mapBump':json.bumpMap=loadTexture(value,m.mapBumpRepeat,m.mapBumpOffset,m.mapBumpWrap,m.mapBumpAnisotropy);break;case'mapBumpScale':json.bumpScale=value;break;case'mapBumpRepeat':case'mapBumpOffset':case'mapBumpWrap':case'mapBumpAnisotropy':break;case'mapNormal':json.normalMap=loadTexture(value,m.mapNormalRepeat,m.mapNormalOffset,m.mapNormalWrap,m.mapNormalAnisotropy);break;case'mapNormalFactor':json.normalScale=[value,value];break;case'mapNormalRepeat':case'mapNormalOffset':case'mapNormalWrap':case'mapNormalAnisotropy':break;case'mapSpecular':json.specularMap=loadTexture(value,m.mapSpecularRepeat,m.mapSpecularOffset,m.mapSpecularWrap,m.mapSpecularAnisotropy);break;case'mapSpecularRepeat':case'mapSpecularOffset':case'mapSpecularWrap':case'mapSpecularAnisotropy':break;case'mapMetalness':json.metalnessMap=loadTexture(value,m.mapMetalnessRepeat,m.mapMetalnessOffset,m.mapMetalnessWrap,m.mapMetalnessAnisotropy);break;case'mapMetalnessRepeat':case'mapMetalnessOffset':case'mapMetalnessWrap':case'mapMetalnessAnisotropy':break;case'mapRoughness':json.roughnessMap=loadTexture(value,m.mapRoughnessRepeat,m.mapRoughnessOffset,m.mapRoughnessWrap,m.mapRoughnessAnisotropy);break;case'mapRoughnessRepeat':case'mapRoughnessOffset':case'mapRoughnessWrap':case'mapRoughnessAnisotropy':break;case'mapAlpha':json.alphaMap=loadTexture(value,m.mapAlphaRepeat,m.mapAlphaOffset,m.mapAlphaWrap,m.mapAlphaAnisotropy);break;case'mapAlphaRepeat':case'mapAlphaOffset':case'mapAlphaWrap':case'mapAlphaAnisotropy':break;case'flipSided':json.side=BackSide;break;case'doubleSided':json.side=DoubleSide;break;case'transparency':console.warn('THREE.Loader.createMaterial: transparency has been renamed to opacity');json.opacity=value;break;case'depthTest':case'depthWrite':case'colorWrite':case'opacity':case'reflectivity':case'transparent':case'visible':case'wireframe':json[name]=value;break;case'vertexColors':if(value===true)json.vertexColors=VertexColors;if(value==='face')json.vertexColors=FaceColors;break;default:console.error('THREE.Loader.createMaterial: Unsupported',name,value);break;}}if(json.type==='MeshBasicMaterial')delete json.emissive;if(json.type!=='MeshPhongMaterial')delete json.specular;if(json.opacity<1)json.transparent=true;materialLoader.setTextures(textures);return materialLoader.parse(json);};}()});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */function JSONLoader(manager){if(typeof manager==='boolean'){console.warn('THREE.JSONLoader: showStatus parameter has been removed from constructor.');manager=undefined;}this.manager=manager!==undefined?manager:DefaultLoadingManager;this.withCredentials=false;}Object.assign(JSONLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var scope=this;var texturePath=this.texturePath&&typeof this.texturePath==="string"?this.texturePath:Loader.prototype.extractUrlBase(url);var loader=new FileLoader(this.manager);loader.setWithCredentials(this.withCredentials);loader.load(url,function(text){var json=JSON.parse(text);var metadata=json.metadata;if(metadata!==undefined){var type=metadata.type;if(type!==undefined){if(type.toLowerCase()==='object'){console.error('THREE.JSONLoader: '+url+' should be loaded with THREE.ObjectLoader instead.');return;}if(type.toLowerCase()==='scene'){console.error('THREE.JSONLoader: '+url+' should be loaded with THREE.SceneLoader instead.');return;}}}var object=scope.parse(json,texturePath);onLoad(object.geometry,object.materials);},onProgress,onError);},setTexturePath:function setTexturePath(value){this.texturePath=value;},parse:function(){function parseModel(json,geometry){function isBitSet(value,position){return value&1<<position;}var i,j,fi,offset,zLength,colorIndex,normalIndex,uvIndex,materialIndex,type,isQuad,hasMaterial,hasFaceVertexUv,hasFaceNormal,hasFaceVertexNormal,hasFaceColor,hasFaceVertexColor,vertex,face,faceA,faceB,hex,normal,uvLayer,uv,u,v,faces=json.faces,vertices=json.vertices,normals=json.normals,colors=json.colors,scale=json.scale,nUvLayers=0;if(json.uvs!==undefined){// disregard empty arrays
for(i=0;i<json.uvs.length;i++){if(json.uvs[i].length)nUvLayers++;}for(i=0;i<nUvLayers;i++){geometry.faceVertexUvs[i]=[];}}offset=0;zLength=vertices.length;while(offset<zLength){vertex=new Vector3();vertex.x=vertices[offset++]*scale;vertex.y=vertices[offset++]*scale;vertex.z=vertices[offset++]*scale;geometry.vertices.push(vertex);}offset=0;zLength=faces.length;while(offset<zLength){type=faces[offset++];isQuad=isBitSet(type,0);hasMaterial=isBitSet(type,1);hasFaceVertexUv=isBitSet(type,3);hasFaceNormal=isBitSet(type,4);hasFaceVertexNormal=isBitSet(type,5);hasFaceColor=isBitSet(type,6);hasFaceVertexColor=isBitSet(type,7);// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
if(isQuad){faceA=new Face3();faceA.a=faces[offset];faceA.b=faces[offset+1];faceA.c=faces[offset+3];faceB=new Face3();faceB.a=faces[offset+1];faceB.b=faces[offset+2];faceB.c=faces[offset+3];offset+=4;if(hasMaterial){materialIndex=faces[offset++];faceA.materialIndex=materialIndex;faceB.materialIndex=materialIndex;}// to get face <=> uv index correspondence
fi=geometry.faces.length;if(hasFaceVertexUv){for(i=0;i<nUvLayers;i++){uvLayer=json.uvs[i];geometry.faceVertexUvs[i][fi]=[];geometry.faceVertexUvs[i][fi+1]=[];for(j=0;j<4;j++){uvIndex=faces[offset++];u=uvLayer[uvIndex*2];v=uvLayer[uvIndex*2+1];uv=new Vector2(u,v);if(j!==2)geometry.faceVertexUvs[i][fi].push(uv);if(j!==0)geometry.faceVertexUvs[i][fi+1].push(uv);}}}if(hasFaceNormal){normalIndex=faces[offset++]*3;faceA.normal.set(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);faceB.normal.copy(faceA.normal);}if(hasFaceVertexNormal){for(i=0;i<4;i++){normalIndex=faces[offset++]*3;normal=new Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);if(i!==2)faceA.vertexNormals.push(normal);if(i!==0)faceB.vertexNormals.push(normal);}}if(hasFaceColor){colorIndex=faces[offset++];hex=colors[colorIndex];faceA.color.setHex(hex);faceB.color.setHex(hex);}if(hasFaceVertexColor){for(i=0;i<4;i++){colorIndex=faces[offset++];hex=colors[colorIndex];if(i!==2)faceA.vertexColors.push(new Color(hex));if(i!==0)faceB.vertexColors.push(new Color(hex));}}geometry.faces.push(faceA);geometry.faces.push(faceB);}else{face=new Face3();face.a=faces[offset++];face.b=faces[offset++];face.c=faces[offset++];if(hasMaterial){materialIndex=faces[offset++];face.materialIndex=materialIndex;}// to get face <=> uv index correspondence
fi=geometry.faces.length;if(hasFaceVertexUv){for(i=0;i<nUvLayers;i++){uvLayer=json.uvs[i];geometry.faceVertexUvs[i][fi]=[];for(j=0;j<3;j++){uvIndex=faces[offset++];u=uvLayer[uvIndex*2];v=uvLayer[uvIndex*2+1];uv=new Vector2(u,v);geometry.faceVertexUvs[i][fi].push(uv);}}}if(hasFaceNormal){normalIndex=faces[offset++]*3;face.normal.set(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);}if(hasFaceVertexNormal){for(i=0;i<3;i++){normalIndex=faces[offset++]*3;normal=new Vector3(normals[normalIndex++],normals[normalIndex++],normals[normalIndex]);face.vertexNormals.push(normal);}}if(hasFaceColor){colorIndex=faces[offset++];face.color.setHex(colors[colorIndex]);}if(hasFaceVertexColor){for(i=0;i<3;i++){colorIndex=faces[offset++];face.vertexColors.push(new Color(colors[colorIndex]));}}geometry.faces.push(face);}}}function parseSkin(json,geometry){var influencesPerVertex=json.influencesPerVertex!==undefined?json.influencesPerVertex:2;if(json.skinWeights){for(var i=0,l=json.skinWeights.length;i<l;i+=influencesPerVertex){var x=json.skinWeights[i];var y=influencesPerVertex>1?json.skinWeights[i+1]:0;var z=influencesPerVertex>2?json.skinWeights[i+2]:0;var w=influencesPerVertex>3?json.skinWeights[i+3]:0;geometry.skinWeights.push(new Vector4(x,y,z,w));}}if(json.skinIndices){for(var i=0,l=json.skinIndices.length;i<l;i+=influencesPerVertex){var a=json.skinIndices[i];var b=influencesPerVertex>1?json.skinIndices[i+1]:0;var c=influencesPerVertex>2?json.skinIndices[i+2]:0;var d=influencesPerVertex>3?json.skinIndices[i+3]:0;geometry.skinIndices.push(new Vector4(a,b,c,d));}}geometry.bones=json.bones;if(geometry.bones&&geometry.bones.length>0&&(geometry.skinWeights.length!==geometry.skinIndices.length||geometry.skinIndices.length!==geometry.vertices.length)){console.warn('When skinning, number of vertices ('+geometry.vertices.length+'), skinIndices ('+geometry.skinIndices.length+'), and skinWeights ('+geometry.skinWeights.length+') should match.');}}function parseMorphing(json,geometry){var scale=json.scale;if(json.morphTargets!==undefined){for(var i=0,l=json.morphTargets.length;i<l;i++){geometry.morphTargets[i]={};geometry.morphTargets[i].name=json.morphTargets[i].name;geometry.morphTargets[i].vertices=[];var dstVertices=geometry.morphTargets[i].vertices;var srcVertices=json.morphTargets[i].vertices;for(var v=0,vl=srcVertices.length;v<vl;v+=3){var vertex=new Vector3();vertex.x=srcVertices[v]*scale;vertex.y=srcVertices[v+1]*scale;vertex.z=srcVertices[v+2]*scale;dstVertices.push(vertex);}}}if(json.morphColors!==undefined&&json.morphColors.length>0){console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');var faces=geometry.faces;var morphColors=json.morphColors[0].colors;for(var i=0,l=faces.length;i<l;i++){faces[i].color.fromArray(morphColors,i*3);}}}function parseAnimations(json,geometry){var outputAnimations=[];// parse old style Bone/Hierarchy animations
var animations=[];if(json.animation!==undefined){animations.push(json.animation);}if(json.animations!==undefined){if(json.animations.length){animations=animations.concat(json.animations);}else{animations.push(json.animations);}}for(var i=0;i<animations.length;i++){var clip=AnimationClip.parseAnimation(animations[i],geometry.bones);if(clip)outputAnimations.push(clip);}// parse implicit morph animations
if(geometry.morphTargets){// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
var morphAnimationClips=AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets,10);outputAnimations=outputAnimations.concat(morphAnimationClips);}if(outputAnimations.length>0)geometry.animations=outputAnimations;}return function(json,texturePath){if(json.data!==undefined){// Geometry 4.0 spec
json=json.data;}if(json.scale!==undefined){json.scale=1.0/json.scale;}else{json.scale=1.0;}var geometry=new Geometry();parseModel(json,geometry);parseSkin(json,geometry);parseMorphing(json,geometry);parseAnimations(json,geometry);geometry.computeFaceNormals();geometry.computeBoundingSphere();if(json.materials===undefined||json.materials.length===0){return{geometry:geometry};}else{var materials=Loader.prototype.initMaterials(json.materials,texturePath,this.crossOrigin);return{geometry:geometry,materials:materials};}};}()});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function ObjectLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.texturePath='';}Object.assign(ObjectLoader.prototype,{load:function load(url,onLoad,onProgress,onError){if(this.texturePath===''){this.texturePath=url.substring(0,url.lastIndexOf('/')+1);}var scope=this;var loader=new FileLoader(scope.manager);loader.load(url,function(text){var json=null;try{json=JSON.parse(text);}catch(error){if(onError!==undefined)onError(error);console.error('THREE:ObjectLoader: Can\'t parse '+url+'.',error.message);return;}var metadata=json.metadata;if(metadata===undefined||metadata.type===undefined||metadata.type.toLowerCase()==='geometry'){console.error('THREE.ObjectLoader: Can\'t load '+url+'. Use THREE.JSONLoader instead.');return;}scope.parse(json,onLoad);},onProgress,onError);},setTexturePath:function setTexturePath(value){this.texturePath=value;},setCrossOrigin:function setCrossOrigin(value){this.crossOrigin=value;},parse:function parse(json,onLoad){var geometries=this.parseGeometries(json.geometries);var images=this.parseImages(json.images,function(){if(onLoad!==undefined)onLoad(object);});var textures=this.parseTextures(json.textures,images);var materials=this.parseMaterials(json.materials,textures);var object=this.parseObject(json.object,geometries,materials);if(json.animations){object.animations=this.parseAnimations(json.animations);}if(json.images===undefined||json.images.length===0){if(onLoad!==undefined)onLoad(object);}return object;},parseGeometries:function parseGeometries(json){var geometries={};if(json!==undefined){var geometryLoader=new JSONLoader();var bufferGeometryLoader=new BufferGeometryLoader();for(var i=0,l=json.length;i<l;i++){var geometry;var data=json[i];switch(data.type){case'PlaneGeometry':case'PlaneBufferGeometry':geometry=new Geometries[data.type](data.width,data.height,data.widthSegments,data.heightSegments);break;case'BoxGeometry':case'BoxBufferGeometry':case'CubeGeometry':// backwards compatible
geometry=new Geometries[data.type](data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);break;case'CircleGeometry':case'CircleBufferGeometry':geometry=new Geometries[data.type](data.radius,data.segments,data.thetaStart,data.thetaLength);break;case'CylinderGeometry':case'CylinderBufferGeometry':geometry=new Geometries[data.type](data.radiusTop,data.radiusBottom,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);break;case'ConeGeometry':case'ConeBufferGeometry':geometry=new Geometries[data.type](data.radius,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);break;case'SphereGeometry':case'SphereBufferGeometry':geometry=new Geometries[data.type](data.radius,data.widthSegments,data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength);break;case'IcosahedronGeometry':case'IcosahedronBufferGeometry':case'OctahedronGeometry':case'OctahedronBufferGeometry':case'TetrahedronGeometry':case'TetrahedronBufferGeometry':geometry=new Geometries[data.type](data.radius,data.detail);break;case'RingGeometry':case'RingBufferGeometry':geometry=new Geometries[data.type](data.innerRadius,data.outerRadius,data.thetaSegments,data.phiSegments,data.thetaStart,data.thetaLength);break;case'BufferGeometry':geometry=bufferGeometryLoader.parse(data);break;case'Geometry':geometry=geometryLoader.parse(data,this.texturePath).geometry;break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+data.type+'"');continue;}geometry.uuid=data.uuid;if(data.name!==undefined)geometry.name=data.name;geometries[data.uuid]=geometry;}}return geometries;},parseMaterials:function parseMaterials(json,textures){var materials={};if(json!==undefined){var loader=new MaterialLoader();loader.setTextures(textures);for(var i=0,l=json.length;i<l;i++){var data=json[i];if(data.type==='MultiMaterial'){// Deprecated
var array=[];for(var j=0;j<data.materials.length;j++){array.push(loader.parse(data.materials[j]));}materials[data.uuid]=array;}else{materials[data.uuid]=loader.parse(data);}}}return materials;},parseAnimations:function parseAnimations(json){var animations=[];for(var i=0;i<json.length;i++){var clip=AnimationClip.parse(json[i]);animations.push(clip);}return animations;},parseImages:function parseImages(json,onLoad){var scope=this;var images={};function loadImage(url){scope.manager.itemStart(url);return loader.load(url,function(){scope.manager.itemEnd(url);},undefined,function(){scope.manager.itemEnd(url);scope.manager.itemError(url);});}if(json!==undefined&&json.length>0){var manager=new LoadingManager(onLoad);var loader=new ImageLoader(manager);loader.setCrossOrigin(this.crossOrigin);for(var i=0,l=json.length;i<l;i++){var image=json[i];var path=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url)?image.url:scope.texturePath+image.url;images[image.uuid]=loadImage(path);}}return images;},parseTextures:function parseTextures(json,images){function parseConstant(value,type){if(typeof value==='number')return value;console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',value);return type[value];}var textures={};if(json!==undefined){for(var i=0,l=json.length;i<l;i++){var data=json[i];if(data.image===undefined){console.warn('THREE.ObjectLoader: No "image" specified for',data.uuid);}if(images[data.image]===undefined){console.warn('THREE.ObjectLoader: Undefined image',data.image);}var texture=new Texture(images[data.image]);texture.needsUpdate=true;texture.uuid=data.uuid;if(data.name!==undefined)texture.name=data.name;if(data.mapping!==undefined)texture.mapping=parseConstant(data.mapping,TEXTURE_MAPPING);if(data.offset!==undefined)texture.offset.fromArray(data.offset);if(data.repeat!==undefined)texture.repeat.fromArray(data.repeat);if(data.center!==undefined)texture.center.fromArray(data.center);if(data.rotation!==undefined)texture.rotation=data.rotation;if(data.wrap!==undefined){texture.wrapS=parseConstant(data.wrap[0],TEXTURE_WRAPPING);texture.wrapT=parseConstant(data.wrap[1],TEXTURE_WRAPPING);}if(data.minFilter!==undefined)texture.minFilter=parseConstant(data.minFilter,TEXTURE_FILTER);if(data.magFilter!==undefined)texture.magFilter=parseConstant(data.magFilter,TEXTURE_FILTER);if(data.anisotropy!==undefined)texture.anisotropy=data.anisotropy;if(data.flipY!==undefined)texture.flipY=data.flipY;textures[data.uuid]=texture;}}return textures;},parseObject:function(){var matrix=new Matrix4();return function parseObject(data,geometries,materials){var object;function getGeometry(name){if(geometries[name]===undefined){console.warn('THREE.ObjectLoader: Undefined geometry',name);}return geometries[name];}function getMaterial(name){if(name===undefined)return undefined;if(Array.isArray(name)){var array=[];for(var i=0,l=name.length;i<l;i++){var uuid=name[i];if(materials[uuid]===undefined){console.warn('THREE.ObjectLoader: Undefined material',uuid);}array.push(materials[uuid]);}return array;}if(materials[name]===undefined){console.warn('THREE.ObjectLoader: Undefined material',name);}return materials[name];}switch(data.type){case'Scene':object=new Scene();if(data.background!==undefined){if(Number.isInteger(data.background)){object.background=new Color(data.background);}}if(data.fog!==undefined){if(data.fog.type==='Fog'){object.fog=new Fog(data.fog.color,data.fog.near,data.fog.far);}else if(data.fog.type==='FogExp2'){object.fog=new FogExp2(data.fog.color,data.fog.density);}}break;case'PerspectiveCamera':object=new PerspectiveCamera(data.fov,data.aspect,data.near,data.far);if(data.focus!==undefined)object.focus=data.focus;if(data.zoom!==undefined)object.zoom=data.zoom;if(data.filmGauge!==undefined)object.filmGauge=data.filmGauge;if(data.filmOffset!==undefined)object.filmOffset=data.filmOffset;if(data.view!==undefined)object.view=Object.assign({},data.view);break;case'OrthographicCamera':object=new OrthographicCamera(data.left,data.right,data.top,data.bottom,data.near,data.far);break;case'AmbientLight':object=new AmbientLight(data.color,data.intensity);break;case'DirectionalLight':object=new DirectionalLight(data.color,data.intensity);break;case'PointLight':object=new PointLight(data.color,data.intensity,data.distance,data.decay);break;case'RectAreaLight':object=new RectAreaLight(data.color,data.intensity,data.width,data.height);break;case'SpotLight':object=new SpotLight(data.color,data.intensity,data.distance,data.angle,data.penumbra,data.decay);break;case'HemisphereLight':object=new HemisphereLight(data.color,data.groundColor,data.intensity);break;case'SkinnedMesh':console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');case'Mesh':var geometry=getGeometry(data.geometry);var material=getMaterial(data.material);if(geometry.bones&&geometry.bones.length>0){object=new SkinnedMesh(geometry,material);}else{object=new Mesh(geometry,material);}break;case'LOD':object=new LOD();break;case'Line':object=new Line(getGeometry(data.geometry),getMaterial(data.material),data.mode);break;case'LineLoop':object=new LineLoop(getGeometry(data.geometry),getMaterial(data.material));break;case'LineSegments':object=new LineSegments(getGeometry(data.geometry),getMaterial(data.material));break;case'PointCloud':case'Points':object=new Points(getGeometry(data.geometry),getMaterial(data.material));break;case'Sprite':object=new Sprite(getMaterial(data.material));break;case'Group':object=new Group();break;default:object=new Object3D();}object.uuid=data.uuid;if(data.name!==undefined)object.name=data.name;if(data.matrix!==undefined){matrix.fromArray(data.matrix);matrix.decompose(object.position,object.quaternion,object.scale);}else{if(data.position!==undefined)object.position.fromArray(data.position);if(data.rotation!==undefined)object.rotation.fromArray(data.rotation);if(data.quaternion!==undefined)object.quaternion.fromArray(data.quaternion);if(data.scale!==undefined)object.scale.fromArray(data.scale);}if(data.castShadow!==undefined)object.castShadow=data.castShadow;if(data.receiveShadow!==undefined)object.receiveShadow=data.receiveShadow;if(data.shadow){if(data.shadow.bias!==undefined)object.shadow.bias=data.shadow.bias;if(data.shadow.radius!==undefined)object.shadow.radius=data.shadow.radius;if(data.shadow.mapSize!==undefined)object.shadow.mapSize.fromArray(data.shadow.mapSize);if(data.shadow.camera!==undefined)object.shadow.camera=this.parseObject(data.shadow.camera);}if(data.visible!==undefined)object.visible=data.visible;if(data.userData!==undefined)object.userData=data.userData;if(data.children!==undefined){var children=data.children;for(var i=0;i<children.length;i++){object.add(this.parseObject(children[i],geometries,materials));}}if(data.type==='LOD'){var levels=data.levels;for(var l=0;l<levels.length;l++){var level=levels[l];var child=object.getObjectByProperty('uuid',level.object);if(child!==undefined){object.addLevel(child,level.distance);}}}return object;};}()});var TEXTURE_MAPPING={UVMapping:UVMapping,CubeReflectionMapping:CubeReflectionMapping,CubeRefractionMapping:CubeRefractionMapping,EquirectangularReflectionMapping:EquirectangularReflectionMapping,EquirectangularRefractionMapping:EquirectangularRefractionMapping,SphericalReflectionMapping:SphericalReflectionMapping,CubeUVReflectionMapping:CubeUVReflectionMapping,CubeUVRefractionMapping:CubeUVRefractionMapping};var TEXTURE_WRAPPING={RepeatWrapping:RepeatWrapping,ClampToEdgeWrapping:ClampToEdgeWrapping,MirroredRepeatWrapping:MirroredRepeatWrapping};var TEXTURE_FILTER={NearestFilter:NearestFilter,NearestMipMapNearestFilter:NearestMipMapNearestFilter,NearestMipMapLinearFilter:NearestMipMapLinearFilter,LinearFilter:LinearFilter,LinearMipMapNearestFilter:LinearMipMapNearestFilter,LinearMipMapLinearFilter:LinearMipMapLinearFilter};/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bézier_curve
	 */function CatmullRom(t,p0,p1,p2,p3){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;var t2=t*t;var t3=t*t2;return(2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;}//
function QuadraticBezierP0(t,p){var k=1-t;return k*k*p;}function QuadraticBezierP1(t,p){return 2*(1-t)*t*p;}function QuadraticBezierP2(t,p){return t*t*p;}function QuadraticBezier(t,p0,p1,p2){return QuadraticBezierP0(t,p0)+QuadraticBezierP1(t,p1)+QuadraticBezierP2(t,p2);}//
function CubicBezierP0(t,p){var k=1-t;return k*k*k*p;}function CubicBezierP1(t,p){var k=1-t;return 3*k*k*t*p;}function CubicBezierP2(t,p){return 3*(1-t)*t*t*p;}function CubicBezierP3(t,p){return t*t*t*p;}function CubicBezier(t,p0,p1,p2,p3){return CubicBezierP0(t,p0)+CubicBezierP1(t,p1)+CubicBezierP2(t,p2)+CubicBezierP3(t,p3);}/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **//**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/function Curve(){this.arcLengthDivisions=200;}Object.assign(Curve.prototype,{// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]
getPoint:function getPoint()/* t, optionalTarget */{console.warn('THREE.Curve: .getPoint() not implemented.');return null;},// Get point at relative position in curve according to arc length
// - u [0 .. 1]
getPointAt:function getPointAt(u,optionalTarget){var t=this.getUtoTmapping(u);return this.getPoint(t,optionalTarget);},// Get sequence of points using getPoint( t )
getPoints:function getPoints(divisions){if(divisions===undefined)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPoint(d/divisions));}return points;},// Get sequence of points using getPointAt( u )
getSpacedPoints:function getSpacedPoints(divisions){if(divisions===undefined)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPointAt(d/divisions));}return points;},// Get total curve arc length
getLength:function getLength(){var lengths=this.getLengths();return lengths[lengths.length-1];},// Get list of cumulative segment lengths
getLengths:function getLengths(divisions){if(divisions===undefined)divisions=this.arcLengthDivisions;if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate){return this.cacheArcLengths;}this.needsUpdate=false;var cache=[];var current,last=this.getPoint(0);var p,sum=0;cache.push(0);for(p=1;p<=divisions;p++){current=this.getPoint(p/divisions);sum+=current.distanceTo(last);cache.push(sum);last=current;}this.cacheArcLengths=cache;return cache;// { sums: cache, sum: sum }; Sum is in the last element.
},updateArcLengths:function updateArcLengths(){this.needsUpdate=true;this.getLengths();},// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
getUtoTmapping:function getUtoTmapping(u,distance){var arcLengths=this.getLengths();var i=0,il=arcLengths.length;var targetArcLength;// The targeted u distance value to get
if(distance){targetArcLength=distance;}else{targetArcLength=u*arcLengths[il-1];}// binary search for the index with largest value smaller than target u distance
var low=0,high=il-1,comparison;while(low<=high){i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
comparison=arcLengths[i]-targetArcLength;if(comparison<0){low=i+1;}else if(comparison>0){high=i-1;}else{high=i;break;// DONE
}}i=high;if(arcLengths[i]===targetArcLength){return i/(il-1);}// we could get finer grain at lengths, or use simple interpolation between two points
var lengthBefore=arcLengths[i];var lengthAfter=arcLengths[i+1];var segmentLength=lengthAfter-lengthBefore;// determine where we are between the 'before' and 'after' points
var segmentFraction=(targetArcLength-lengthBefore)/segmentLength;// add that fractional amount to t
var t=(i+segmentFraction)/(il-1);return t;},// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation
getTangent:function getTangent(t){var delta=0.0001;var t1=t-delta;var t2=t+delta;// Capping in case of danger
if(t1<0)t1=0;if(t2>1)t2=1;var pt1=this.getPoint(t1);var pt2=this.getPoint(t2);var vec=pt2.clone().sub(pt1);return vec.normalize();},getTangentAt:function getTangentAt(u){var t=this.getUtoTmapping(u);return this.getTangent(t);},computeFrenetFrames:function computeFrenetFrames(segments,closed){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
var normal=new Vector3();var tangents=[];var normals=[];var binormals=[];var vec=new Vector3();var mat=new Matrix4();var i,u,theta;// compute the tangent vectors for each segment on the curve
for(i=0;i<=segments;i++){u=i/segments;tangents[i]=this.getTangentAt(u);tangents[i].normalize();}// select an initial normal vector perpendicular to the first tangent vector,
// and in the direction of the minimum tangent xyz component
normals[0]=new Vector3();binormals[0]=new Vector3();var min=Number.MAX_VALUE;var tx=Math.abs(tangents[0].x);var ty=Math.abs(tangents[0].y);var tz=Math.abs(tangents[0].z);if(tx<=min){min=tx;normal.set(1,0,0);}if(ty<=min){min=ty;normal.set(0,1,0);}if(tz<=min){normal.set(0,0,1);}vec.crossVectors(tangents[0],normal).normalize();normals[0].crossVectors(tangents[0],vec);binormals[0].crossVectors(tangents[0],normals[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
for(i=1;i<=segments;i++){normals[i]=normals[i-1].clone();binormals[i]=binormals[i-1].clone();vec.crossVectors(tangents[i-1],tangents[i]);if(vec.length()>Number.EPSILON){vec.normalize();theta=Math.acos(_Math.clamp(tangents[i-1].dot(tangents[i]),-1,1));// clamp for floating pt errors
normals[i].applyMatrix4(mat.makeRotationAxis(vec,theta));}binormals[i].crossVectors(tangents[i],normals[i]);}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
if(closed===true){theta=Math.acos(_Math.clamp(normals[0].dot(normals[segments]),-1,1));theta/=segments;if(tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0){theta=-theta;}for(i=1;i<=segments;i++){// twist a little...
normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i],theta*i));binormals[i].crossVectors(tangents[i],normals[i]);}}return{tangents:tangents,normals:normals,binormals:binormals};}});function LineCurve(v1,v2){Curve.call(this);this.v1=v1;this.v2=v2;}LineCurve.prototype=Object.create(Curve.prototype);LineCurve.prototype.constructor=LineCurve;LineCurve.prototype.isLineCurve=true;LineCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();if(t===1){point.copy(this.v2);}else{point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;};// Line curve is linear, so we can overwrite default getPointAt
LineCurve.prototype.getPointAt=function(u,optionalTarget){return this.getPoint(u,optionalTarget);};LineCurve.prototype.getTangent=function()/* t */{var tangent=this.v2.clone().sub(this.v1);return tangent.normalize();};/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **//**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/function CurvePath(){Curve.call(this);this.curves=[];this.autoClose=false;// Automatically closes the path
}CurvePath.prototype=Object.assign(Object.create(Curve.prototype),{constructor:CurvePath,add:function add(curve){this.curves.push(curve);},closePath:function closePath(){// Add a line curve if start and end of lines are not connected
var startPoint=this.curves[0].getPoint(0);var endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){this.curves.push(new LineCurve(endPoint,startPoint));}},// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:
// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')
getPoint:function getPoint(t){var d=t*this.getLength();var curveLengths=this.getCurveLengths();var i=0;// To think about boundaries points.
while(i<curveLengths.length){if(curveLengths[i]>=d){var diff=curveLengths[i]-d;var curve=this.curves[i];var segmentLength=curve.getLength();var u=segmentLength===0?0:1-diff/segmentLength;return curve.getPointAt(u);}i++;}return null;// loop where sum != 0, sum > d , sum+1 <d
},// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength
getLength:function getLength(){var lens=this.getCurveLengths();return lens[lens.length-1];},// cacheLengths must be recalculated.
updateArcLengths:function updateArcLengths(){this.needsUpdate=true;this.cacheLengths=null;this.getCurveLengths();},// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.
getCurveLengths:function getCurveLengths(){// We use cache values if curves and cache array are same length
if(this.cacheLengths&&this.cacheLengths.length===this.curves.length){return this.cacheLengths;}// Get length of sub-curve
// Push sums into cached array
var lengths=[],sums=0;for(var i=0,l=this.curves.length;i<l;i++){sums+=this.curves[i].getLength();lengths.push(sums);}this.cacheLengths=lengths;return lengths;},getSpacedPoints:function getSpacedPoints(divisions){if(divisions===undefined)divisions=40;var points=[];for(var i=0;i<=divisions;i++){points.push(this.getPoint(i/divisions));}if(this.autoClose){points.push(points[0]);}return points;},getPoints:function getPoints(divisions){divisions=divisions||12;var points=[],last;for(var i=0,curves=this.curves;i<curves.length;i++){var curve=curves[i];var resolution=curve&&curve.isEllipseCurve?divisions*2:curve&&curve.isLineCurve?1:curve&&curve.isSplineCurve?divisions*curve.points.length:divisions;var pts=curve.getPoints(resolution);for(var j=0;j<pts.length;j++){var point=pts[j];if(last&&last.equals(point))continue;// ensures no consecutive points are duplicates
points.push(point);last=point;}}if(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){points.push(points[0]);}return points;}});function EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){Curve.call(this);this.aX=aX;this.aY=aY;this.xRadius=xRadius;this.yRadius=yRadius;this.aStartAngle=aStartAngle;this.aEndAngle=aEndAngle;this.aClockwise=aClockwise;this.aRotation=aRotation||0;}EllipseCurve.prototype=Object.create(Curve.prototype);EllipseCurve.prototype.constructor=EllipseCurve;EllipseCurve.prototype.isEllipseCurve=true;EllipseCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var twoPi=Math.PI*2;var deltaAngle=this.aEndAngle-this.aStartAngle;var samePoints=Math.abs(deltaAngle)<Number.EPSILON;// ensures that deltaAngle is 0 .. 2 PI
while(deltaAngle<0){deltaAngle+=twoPi;}while(deltaAngle>twoPi){deltaAngle-=twoPi;}if(deltaAngle<Number.EPSILON){if(samePoints){deltaAngle=0;}else{deltaAngle=twoPi;}}if(this.aClockwise===true&&!samePoints){if(deltaAngle===twoPi){deltaAngle=-twoPi;}else{deltaAngle=deltaAngle-twoPi;}}var angle=this.aStartAngle+t*deltaAngle;var x=this.aX+this.xRadius*Math.cos(angle);var y=this.aY+this.yRadius*Math.sin(angle);if(this.aRotation!==0){var cos=Math.cos(this.aRotation);var sin=Math.sin(this.aRotation);var tx=x-this.aX;var ty=y-this.aY;// Rotate the point about the center of the ellipse.
x=tx*cos-ty*sin+this.aX;y=tx*sin+ty*cos+this.aY;}return point.set(x,y);};function SplineCurve(points/* array of Vector2 */){Curve.call(this);this.points=points===undefined?[]:points;}SplineCurve.prototype=Object.create(Curve.prototype);SplineCurve.prototype.constructor=SplineCurve;SplineCurve.prototype.isSplineCurve=true;SplineCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var points=this.points;var p=(points.length-1)*t;var intPoint=Math.floor(p);var weight=p-intPoint;var p0=points[intPoint===0?intPoint:intPoint-1];var p1=points[intPoint];var p2=points[intPoint>points.length-2?points.length-1:intPoint+1];var p3=points[intPoint>points.length-3?points.length-1:intPoint+2];point.set(CatmullRom(weight,p0.x,p1.x,p2.x,p3.x),CatmullRom(weight,p0.y,p1.y,p2.y,p3.y));return point;};function CubicBezierCurve(v0,v1,v2,v3){Curve.call(this);this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3;}CubicBezierCurve.prototype=Object.create(Curve.prototype);CubicBezierCurve.prototype.constructor=CubicBezierCurve;CubicBezierCurve.prototype.isCubicBezierCurve=true;CubicBezierCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y));return point;};function QuadraticBezierCurve(v0,v1,v2){Curve.call(this);this.v0=v0;this.v1=v1;this.v2=v2;}QuadraticBezierCurve.prototype=Object.create(Curve.prototype);QuadraticBezierCurve.prototype.constructor=QuadraticBezierCurve;QuadraticBezierCurve.prototype.isQuadraticBezierCurve=true;QuadraticBezierCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y));return point;};var PathPrototype=Object.assign(Object.create(CurvePath.prototype),{fromPoints:function fromPoints(vectors){this.moveTo(vectors[0].x,vectors[0].y);for(var i=1,l=vectors.length;i<l;i++){this.lineTo(vectors[i].x,vectors[i].y);}},moveTo:function moveTo(x,y){this.currentPoint.set(x,y);// TODO consider referencing vectors instead of copying?
},lineTo:function lineTo(x,y){var curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));this.curves.push(curve);this.currentPoint.set(x,y);},quadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){var curve=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);},bezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){var curve=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);},splineThru:function splineThru(pts/*Array of Vector*/){var npts=[this.currentPoint.clone()].concat(pts);var curve=new SplineCurve(npts);this.curves.push(curve);this.currentPoint.copy(pts[pts.length-1]);},arc:function arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absarc(aX+x0,aY+y0,aRadius,aStartAngle,aEndAngle,aClockwise);},absarc:function absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);},ellipse:function ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);},absellipse:function absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);if(this.curves.length>0){// if a previous curve is present, attempt to join
var firstPoint=curve.getPoint(0);if(!firstPoint.equals(this.currentPoint)){this.lineTo(firstPoint.x,firstPoint.y);}}this.curves.push(curve);var lastPoint=curve.getPoint(1);this.currentPoint.copy(lastPoint);}});/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 **/function Path(points){CurvePath.call(this);this.currentPoint=new Vector2();if(points){this.fromPoints(points);}}Path.prototype=PathPrototype;PathPrototype.constructor=Path;/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.
function Shape(){Path.apply(this,arguments);this.holes=[];}Shape.prototype=Object.assign(Object.create(PathPrototype),{constructor:Shape,getPointsHoles:function getPointsHoles(divisions){var holesPts=[];for(var i=0,l=this.holes.length;i<l;i++){holesPts[i]=this.holes[i].getPoints(divisions);}return holesPts;},// Get points of shape and holes (keypoints based on segments parameter)
extractAllPoints:function extractAllPoints(divisions){return{shape:this.getPoints(divisions),holes:this.getPointsHoles(divisions)};},extractPoints:function extractPoints(divisions){return this.extractAllPoints(divisions);}});/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	 **/function ShapePath(){this.subPaths=[];this.currentPath=null;}Object.assign(ShapePath.prototype,{moveTo:function moveTo(x,y){this.currentPath=new Path();this.subPaths.push(this.currentPath);this.currentPath.moveTo(x,y);},lineTo:function lineTo(x,y){this.currentPath.lineTo(x,y);},quadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){this.currentPath.quadraticCurveTo(aCPx,aCPy,aX,aY);},bezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){this.currentPath.bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY);},splineThru:function splineThru(pts){this.currentPath.splineThru(pts);},toShapes:function toShapes(isCCW,noHoles){function toShapesNoHoles(inSubpaths){var shapes=[];for(var i=0,l=inSubpaths.length;i<l;i++){var tmpPath=inSubpaths[i];var tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);}return shapes;}function isPointInsidePolygon(inPt,inPolygon){var polyLen=inPolygon.length;// inPt on polygon contour => immediate success    or
// toggling of inside/outside at every single! intersection point of an edge
//  with the horizontal line through inPt, left of inPt
//  not counting lowerY endpoints of edges and whole edges on that line
var inside=false;for(var p=polyLen-1,q=0;q<polyLen;p=q++){var edgeLowPt=inPolygon[p];var edgeHighPt=inPolygon[q];var edgeDx=edgeHighPt.x-edgeLowPt.x;var edgeDy=edgeHighPt.y-edgeLowPt.y;if(Math.abs(edgeDy)>Number.EPSILON){// not parallel
if(edgeDy<0){edgeLowPt=inPolygon[q];edgeDx=-edgeDx;edgeHighPt=inPolygon[p];edgeDy=-edgeDy;}if(inPt.y<edgeLowPt.y||inPt.y>edgeHighPt.y)continue;if(inPt.y===edgeLowPt.y){if(inPt.x===edgeLowPt.x)return true;// inPt is on contour ?
// continue;				// no intersection or edgeLowPt => doesn't count !!!
}else{var perpEdge=edgeDy*(inPt.x-edgeLowPt.x)-edgeDx*(inPt.y-edgeLowPt.y);if(perpEdge===0)return true;// inPt is on contour ?
if(perpEdge<0)continue;inside=!inside;// true intersection left of inPt
}}else{// parallel or collinear
if(inPt.y!==edgeLowPt.y)continue;// parallel
// edge lies on the same horizontal line as inPt
if(edgeHighPt.x<=inPt.x&&inPt.x<=edgeLowPt.x||edgeLowPt.x<=inPt.x&&inPt.x<=edgeHighPt.x)return true;// inPt: Point on contour !
// continue;
}}return inside;}var isClockWise=ShapeUtils.isClockWise;var subPaths=this.subPaths;if(subPaths.length===0)return[];if(noHoles===true)return toShapesNoHoles(subPaths);var solid,tmpPath,tmpShape,shapes=[];if(subPaths.length===1){tmpPath=subPaths[0];tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);return shapes;}var holesFirst=!isClockWise(subPaths[0].getPoints());holesFirst=isCCW?!holesFirst:holesFirst;// console.log("Holes first", holesFirst);
var betterShapeHoles=[];var newShapes=[];var newShapeHoles=[];var mainIdx=0;var tmpPoints;newShapes[mainIdx]=undefined;newShapeHoles[mainIdx]=[];for(var i=0,l=subPaths.length;i<l;i++){tmpPath=subPaths[i];tmpPoints=tmpPath.getPoints();solid=isClockWise(tmpPoints);solid=isCCW?!solid:solid;if(solid){if(!holesFirst&&newShapes[mainIdx])mainIdx++;newShapes[mainIdx]={s:new Shape(),p:tmpPoints};newShapes[mainIdx].s.curves=tmpPath.curves;if(holesFirst)mainIdx++;newShapeHoles[mainIdx]=[];//console.log('cw', i);
}else{newShapeHoles[mainIdx].push({h:tmpPath,p:tmpPoints[0]});//console.log('ccw', i);
}}// only Holes? -> probably all Shapes with wrong orientation
if(!newShapes[0])return toShapesNoHoles(subPaths);if(newShapes.length>1){var ambiguous=false;var toChange=[];for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){betterShapeHoles[sIdx]=[];}for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){var sho=newShapeHoles[sIdx];for(var hIdx=0;hIdx<sho.length;hIdx++){var ho=sho[hIdx];var hole_unassigned=true;for(var s2Idx=0;s2Idx<newShapes.length;s2Idx++){if(isPointInsidePolygon(ho.p,newShapes[s2Idx].p)){if(sIdx!==s2Idx)toChange.push({froms:sIdx,tos:s2Idx,hole:hIdx});if(hole_unassigned){hole_unassigned=false;betterShapeHoles[s2Idx].push(ho);}else{ambiguous=true;}}}if(hole_unassigned){betterShapeHoles[sIdx].push(ho);}}}// console.log("ambiguous: ", ambiguous);
if(toChange.length>0){// console.log("to change: ", toChange);
if(!ambiguous)newShapeHoles=betterShapeHoles;}}var tmpHoles;for(var i=0,il=newShapes.length;i<il;i++){tmpShape=newShapes[i].s;shapes.push(tmpShape);tmpHoles=newShapeHoles[i];for(var j=0,jl=tmpHoles.length;j<jl;j++){tmpShape.holes.push(tmpHoles[j].h);}}//console.log("shape", shapes);
return shapes;}});/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */function Font(data){this.data=data;}Object.assign(Font.prototype,{isFont:true,generateShapes:function generateShapes(text,size,divisions){function createPaths(text){var chars=String(text).split('');var scale=size/data.resolution;var line_height=(data.boundingBox.yMax-data.boundingBox.yMin+data.underlineThickness)*scale;var offsetX=0,offsetY=0;var paths=[];for(var i=0;i<chars.length;i++){var char=chars[i];if(char==='\n'){offsetX=0;offsetY-=line_height;}else{var ret=createPath(char,scale,offsetX,offsetY);offsetX+=ret.offsetX;paths.push(ret.path);}}return paths;}function createPath(c,scale,offsetX,offsetY){var glyph=data.glyphs[c]||data.glyphs['?'];if(!glyph)return;var path=new ShapePath();var pts=[];var x,y,cpx,cpy,cpx0,cpy0,cpx1,cpy1,cpx2,cpy2,laste;if(glyph.o){var outline=glyph._cachedOutline||(glyph._cachedOutline=glyph.o.split(' '));for(var i=0,l=outline.length;i<l;){var action=outline[i++];switch(action){case'm':// moveTo
x=outline[i++]*scale+offsetX;y=outline[i++]*scale+offsetY;path.moveTo(x,y);break;case'l':// lineTo
x=outline[i++]*scale+offsetX;y=outline[i++]*scale+offsetY;path.lineTo(x,y);break;case'q':// quadraticCurveTo
cpx=outline[i++]*scale+offsetX;cpy=outline[i++]*scale+offsetY;cpx1=outline[i++]*scale+offsetX;cpy1=outline[i++]*scale+offsetY;path.quadraticCurveTo(cpx1,cpy1,cpx,cpy);laste=pts[pts.length-1];if(laste){cpx0=laste.x;cpy0=laste.y;for(var i2=1;i2<=divisions;i2++){var t=i2/divisions;QuadraticBezier(t,cpx0,cpx1,cpx);QuadraticBezier(t,cpy0,cpy1,cpy);}}break;case'b':// bezierCurveTo
cpx=outline[i++]*scale+offsetX;cpy=outline[i++]*scale+offsetY;cpx1=outline[i++]*scale+offsetX;cpy1=outline[i++]*scale+offsetY;cpx2=outline[i++]*scale+offsetX;cpy2=outline[i++]*scale+offsetY;path.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,cpx,cpy);laste=pts[pts.length-1];if(laste){cpx0=laste.x;cpy0=laste.y;for(var i2=1;i2<=divisions;i2++){var t=i2/divisions;CubicBezier(t,cpx0,cpx1,cpx2,cpx);CubicBezier(t,cpy0,cpy1,cpy2,cpy);}}break;}}}return{offsetX:glyph.ha*scale,path:path};}//
if(size===undefined)size=100;if(divisions===undefined)divisions=4;var data=this.data;var paths=createPaths(text);var shapes=[];for(var p=0,pl=paths.length;p<pl;p++){Array.prototype.push.apply(shapes,paths[p].toShapes());}return shapes;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function FontLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(FontLoader.prototype,{load:function load(text,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(this.manager);//loader.setPath( this.path );
//loader.load( url, function ( text ) {
var json;try{json=JSON.parse(text);}catch(e){console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');json=JSON.parse(text.substring(65,text.length-2));}var font=scope.parse(json);if(onLoad)onLoad(font);//}, onProgress, onError );
},parse:function parse(json){return new Font(json);},setPath:function setPath(value){this.path=value;return this;}});var context;var AudioContext={getContext:function getContext(){if(context===undefined){context=new(window.AudioContext||window.webkitAudioContext)();}return context;},setContext:function setContext(value){context=value;}};/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */function AudioLoader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;}Object.assign(AudioLoader.prototype,{load:function load(url,onLoad,onProgress,onError){var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.load(url,function(buffer){var context=AudioContext.getContext();context.decodeAudioData(buffer,function(audioBuffer){onLoad(audioBuffer);});},onProgress,onError);}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function StereoCamera(){this.type='StereoCamera';this.aspect=1;this.eyeSep=0.064;this.cameraL=new PerspectiveCamera();this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=false;this.cameraR=new PerspectiveCamera();this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=false;}Object.assign(StereoCamera.prototype,{update:function(){var instance,focus,fov,aspect,near,far,zoom,eyeSep;var eyeRight=new Matrix4();var eyeLeft=new Matrix4();return function update(camera){var needsUpdate=instance!==this||focus!==camera.focus||fov!==camera.fov||aspect!==camera.aspect*this.aspect||near!==camera.near||far!==camera.far||zoom!==camera.zoom||eyeSep!==this.eyeSep;if(needsUpdate){instance=this;focus=camera.focus;fov=camera.fov;aspect=camera.aspect*this.aspect;near=camera.near;far=camera.far;zoom=camera.zoom;// Off-axis stereoscopic effect based on
// http://paulbourke.net/stereographics/stereorender/
var projectionMatrix=camera.projectionMatrix.clone();eyeSep=this.eyeSep/2;var eyeSepOnProjection=eyeSep*near/focus;var ymax=near*Math.tan(_Math.DEG2RAD*fov*0.5)/zoom;var xmin,xmax;// translate xOffset
eyeLeft.elements[12]=-eyeSep;eyeRight.elements[12]=eyeSep;// for left eye
xmin=-ymax*aspect+eyeSepOnProjection;xmax=ymax*aspect+eyeSepOnProjection;projectionMatrix.elements[0]=2*near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraL.projectionMatrix.copy(projectionMatrix);// for right eye
xmin=-ymax*aspect-eyeSepOnProjection;xmax=ymax*aspect-eyeSepOnProjection;projectionMatrix.elements[0]=2*near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraR.projectionMatrix.copy(projectionMatrix);}this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(eyeLeft);this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(eyeRight);};}()});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function AudioListener(){Object3D.call(this);this.type='AudioListener';this.context=AudioContext.getContext();this.gain=this.context.createGain();this.gain.connect(this.context.destination);this.filter=null;}AudioListener.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:AudioListener,getInput:function getInput(){return this.gain;},removeFilter:function removeFilter(){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);this.gain.connect(this.context.destination);this.filter=null;}},getFilter:function getFilter(){return this.filter;},setFilter:function setFilter(value){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);}else{this.gain.disconnect(this.context.destination);}this.filter=value;this.gain.connect(this.filter);this.filter.connect(this.context.destination);},getMasterVolume:function getMasterVolume(){return this.gain.gain.value;},setMasterVolume:function setMasterVolume(value){this.gain.gain.value=value;},updateMatrixWorld:function(){var position=new Vector3();var quaternion=new Quaternion();var scale=new Vector3();var orientation=new Vector3();return function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);var listener=this.context.listener;var up=this.up;this.matrixWorld.decompose(position,quaternion,scale);orientation.set(0,0,-1).applyQuaternion(quaternion);if(listener.positionX){listener.positionX.setValueAtTime(position.x,this.context.currentTime);listener.positionY.setValueAtTime(position.y,this.context.currentTime);listener.positionZ.setValueAtTime(position.z,this.context.currentTime);listener.forwardX.setValueAtTime(orientation.x,this.context.currentTime);listener.forwardY.setValueAtTime(orientation.y,this.context.currentTime);listener.forwardZ.setValueAtTime(orientation.z,this.context.currentTime);listener.upX.setValueAtTime(up.x,this.context.currentTime);listener.upY.setValueAtTime(up.y,this.context.currentTime);listener.upZ.setValueAtTime(up.z,this.context.currentTime);}else{listener.setPosition(position.x,position.y,position.z);listener.setOrientation(orientation.x,orientation.y,orientation.z,up.x,up.y,up.z);}};}()});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */function Audio(listener){Object3D.call(this);this.type='Audio';this.context=listener.context;this.gain=this.context.createGain();this.gain.connect(listener.getInput());this.autoplay=false;this.buffer=null;this.loop=false;this.startTime=0;this.offset=0;this.playbackRate=1;this.isPlaying=false;this.hasPlaybackControl=true;this.sourceType='empty';this.filters=[];}Audio.prototype=Object.assign(Object.create(Object3D.prototype),{constructor:Audio,getOutput:function getOutput(){return this.gain;},setNodeSource:function setNodeSource(audioNode){this.hasPlaybackControl=false;this.sourceType='audioNode';this.source=audioNode;this.connect();return this;},setBuffer:function setBuffer(audioBuffer){this.buffer=audioBuffer;this.sourceType='buffer';if(this.autoplay)this.play();return this;},play:function play(){if(this.isPlaying===true){console.warn('THREE.Audio: Audio is already playing.');return;}if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}var source=this.context.createBufferSource();source.buffer=this.buffer;source.loop=this.loop;source.onended=this.onEnded.bind(this);source.playbackRate.setValueAtTime(this.playbackRate,this.startTime);this.startTime=this.context.currentTime;source.start(this.startTime,this.offset);this.isPlaying=true;this.source=source;return this.connect();},pause:function pause(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}if(this.isPlaying===true){this.source.stop();this.offset+=(this.context.currentTime-this.startTime)*this.playbackRate;this.isPlaying=false;}return this;},stop:function stop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.source.stop();this.offset=0;this.isPlaying=false;return this;},connect:function connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var i=1,l=this.filters.length;i<l;i++){this.filters[i-1].connect(this.filters[i]);}this.filters[this.filters.length-1].connect(this.getOutput());}else{this.source.connect(this.getOutput());}return this;},disconnect:function disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(var i=1,l=this.filters.length;i<l;i++){this.filters[i-1].disconnect(this.filters[i]);}this.filters[this.filters.length-1].disconnect(this.getOutput());}else{this.source.disconnect(this.getOutput());}return this;},getFilters:function getFilters(){return this.filters;},setFilters:function setFilters(value){if(!value)value=[];if(this.isPlaying===true){this.disconnect();this.filters=value;this.connect();}else{this.filters=value;}return this;},getFilter:function getFilter(){return this.getFilters()[0];},setFilter:function setFilter(filter){return this.setFilters(filter?[filter]:[]);},setPlaybackRate:function setPlaybackRate(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.playbackRate=value;if(this.isPlaying===true){this.source.playbackRate.setValueAtTime(this.playbackRate,this.context.currentTime);}return this;},getPlaybackRate:function getPlaybackRate(){return this.playbackRate;},onEnded:function onEnded(){this.isPlaying=false;},getLoop:function getLoop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return false;}return this.loop;},setLoop:function setLoop(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.loop=value;if(this.isPlaying===true){this.source.loop=this.loop;}return this;},getVolume:function getVolume(){return this.gain.gain.value;},setVolume:function setVolume(value){this.gain.gain.value=value;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function PositionalAudio(listener){Audio.call(this,listener);this.panner=this.context.createPanner();this.panner.connect(this.gain);}PositionalAudio.prototype=Object.assign(Object.create(Audio.prototype),{constructor:PositionalAudio,getOutput:function getOutput(){return this.panner;},getRefDistance:function getRefDistance(){return this.panner.refDistance;},setRefDistance:function setRefDistance(value){this.panner.refDistance=value;},getRolloffFactor:function getRolloffFactor(){return this.panner.rolloffFactor;},setRolloffFactor:function setRolloffFactor(value){this.panner.rolloffFactor=value;},getDistanceModel:function getDistanceModel(){return this.panner.distanceModel;},setDistanceModel:function setDistanceModel(value){this.panner.distanceModel=value;},getMaxDistance:function getMaxDistance(){return this.panner.maxDistance;},setMaxDistance:function setMaxDistance(value){this.panner.maxDistance=value;},updateMatrixWorld:function(){var position=new Vector3();return function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);position.setFromMatrixPosition(this.matrixWorld);this.panner.setPosition(position.x,position.y,position.z);};}()});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function AudioAnalyser(audio,fftSize){this.analyser=audio.context.createAnalyser();this.analyser.fftSize=fftSize!==undefined?fftSize:2048;this.data=new Uint8Array(this.analyser.frequencyBinCount);audio.getOutput().connect(this.analyser);}Object.assign(AudioAnalyser.prototype,{getFrequencyData:function getFrequencyData(){this.analyser.getByteFrequencyData(this.data);return this.data;},getAverageFrequency:function getAverageFrequency(){var value=0,data=this.getFrequencyData();for(var i=0;i<data.length;i++){value+=data[i];}return value/data.length;}});/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function PropertyMixer(binding,typeName,valueSize){this.binding=binding;this.valueSize=valueSize;var bufferType=Float64Array,mixFunction;switch(typeName){case'quaternion':mixFunction=this._slerp;break;case'string':case'bool':bufferType=Array;mixFunction=this._select;break;default:mixFunction=this._lerp;}this.buffer=new bufferType(valueSize*4);// layout: [ incoming | accu0 | accu1 | orig ]
//
// interpolators can use .buffer as their .result
// the data then goes to 'incoming'
//
// 'accu0' and 'accu1' are used frame-interleaved for
// the cumulative result and are compared to detect
// changes
//
// 'orig' stores the original state of the property
this._mixBufferRegion=mixFunction;this.cumulativeWeight=0;this.useCount=0;this.referenceCount=0;}Object.assign(PropertyMixer.prototype,{// accumulate data in the 'incoming' region into 'accu<i>'
accumulate:function accumulate(accuIndex,weight){// note: happily accumulating nothing when weight = 0, the caller knows
// the weight and shouldn't have made the call in the first place
var buffer=this.buffer,stride=this.valueSize,offset=accuIndex*stride+stride,currentWeight=this.cumulativeWeight;if(currentWeight===0){// accuN := incoming * weight
for(var i=0;i!==stride;++i){buffer[offset+i]=buffer[i];}currentWeight=weight;}else{// accuN := accuN + incoming * weight
currentWeight+=weight;var mix=weight/currentWeight;this._mixBufferRegion(buffer,offset,0,mix,stride);}this.cumulativeWeight=currentWeight;},// apply the state of 'accu<i>' to the binding when accus differ
apply:function apply(accuIndex){var stride=this.valueSize,buffer=this.buffer,offset=accuIndex*stride+stride,weight=this.cumulativeWeight,binding=this.binding;this.cumulativeWeight=0;if(weight<1){// accuN := accuN + original * ( 1 - cumulativeWeight )
var originalValueOffset=stride*3;this._mixBufferRegion(buffer,offset,originalValueOffset,1-weight,stride);}for(var i=stride,e=stride+stride;i!==e;++i){if(buffer[i]!==buffer[i+stride]){// value has changed -> update scene graph
binding.setValue(buffer,offset);break;}}},// remember the state of the bound property and copy it to both accus
saveOriginalState:function saveOriginalState(){var binding=this.binding;var buffer=this.buffer,stride=this.valueSize,originalValueOffset=stride*3;binding.getValue(buffer,originalValueOffset);// accu[0..1] := orig -- initially detect changes against the original
for(var i=stride,e=originalValueOffset;i!==e;++i){buffer[i]=buffer[originalValueOffset+i%stride];}this.cumulativeWeight=0;},// apply the state previously taken via 'saveOriginalState' to the binding
restoreOriginalState:function restoreOriginalState(){var originalValueOffset=this.valueSize*3;this.binding.setValue(this.buffer,originalValueOffset);},// mix functions
_select:function _select(buffer,dstOffset,srcOffset,t,stride){if(t>=0.5){for(var i=0;i!==stride;++i){buffer[dstOffset+i]=buffer[srcOffset+i];}}},_slerp:function _slerp(buffer,dstOffset,srcOffset,t){Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,srcOffset,t);},_lerp:function _lerp(buffer,dstOffset,srcOffset,t,stride){var s=1-t;for(var i=0;i!==stride;++i){var j=dstOffset+i;buffer[j]=buffer[j]*s+buffer[srcOffset+i]*t;}}});/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function Composite(targetGroup,path,optionalParsedPath){var parsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path);this._targetGroup=targetGroup;this._bindings=targetGroup.subscribe_(path,parsedPath);}Object.assign(Composite.prototype,{getValue:function getValue(array,offset){this.bind();// bind all binding
var firstValidIndex=this._targetGroup.nCachedObjects_,binding=this._bindings[firstValidIndex];// and only call .getValue on the first
if(binding!==undefined)binding.getValue(array,offset);},setValue:function setValue(array,offset){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].setValue(array,offset);}},bind:function bind(){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].bind();}},unbind:function unbind(){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].unbind();}}});function PropertyBinding(rootNode,path,parsedPath){this.path=path;this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path);this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName)||rootNode;this.rootNode=rootNode;}Object.assign(PropertyBinding,{Composite:Composite,create:function create(root,path,parsedPath){if(!(root&&root.isAnimationObjectGroup)){return new PropertyBinding(root,path,parsedPath);}else{return new PropertyBinding.Composite(root,path,parsedPath);}},/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param  {string} name Node name to be sanitized.
		 * @return {string}
		 */sanitizeNodeName:function sanitizeNodeName(name){return name.replace(/\s/g,'_').replace(/[^\w-]/g,'');},parseTrackName:function(){// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
var directoryRe=/((?:[\w-]+[\/:])*)/;// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
var nodeRe=/([\w-\.]+)?/;// Object on target node, and accessor. Name may contain only word
// characters. Accessor may contain any character except closing bracket.
var objectRe=/(?:\.([\w-]+)(?:\[(.+)\])?)?/;// Property and accessor. May contain only word characters. Accessor may
// contain any non-bracket characters.
var propertyRe=/\.([\w-]+)(?:\[(.+)\])?/;var trackRe=new RegExp(''+'^'+directoryRe.source+nodeRe.source+objectRe.source+propertyRe.source+'$');var supportedObjectNames=['material','materials','bones'];return function(trackName){var matches=trackRe.exec(trackName);if(!matches){throw new Error('PropertyBinding: Cannot parse trackName: '+trackName);}var results={// directoryName: matches[ 1 ], // (tschw) currently unused
nodeName:matches[2],objectName:matches[3],objectIndex:matches[4],propertyName:matches[5],// required
propertyIndex:matches[6]};var lastDot=results.nodeName&&results.nodeName.lastIndexOf('.');if(lastDot!==undefined&&lastDot!==-1){var objectName=results.nodeName.substring(lastDot+1);// Object names must be checked against a whitelist. Otherwise, there
// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
// 'bar' could be the objectName, or part of a nodeName (which can
// include '.' characters).
if(supportedObjectNames.indexOf(objectName)!==-1){results.nodeName=results.nodeName.substring(0,lastDot);results.objectName=objectName;}}if(results.propertyName===null||results.propertyName.length===0){throw new Error('PropertyBinding: can not parse propertyName from trackName: '+trackName);}return results;};}(),findNode:function findNode(root,nodeName){if(!nodeName||nodeName===""||nodeName==="root"||nodeName==="."||nodeName===-1||nodeName===root.name||nodeName===root.uuid){return root;}// search into skeleton bones.
if(root.skeleton){var searchSkeleton=function searchSkeleton(skeleton){for(var i=0;i<skeleton.bones.length;i++){var bone=skeleton.bones[i];if(bone.name===nodeName){return bone;}}return null;};var bone=searchSkeleton(root.skeleton);if(bone){return bone;}}// search into node subtree.
if(root.children){var searchNodeSubtree=function searchNodeSubtree(children){for(var i=0;i<children.length;i++){var childNode=children[i];if(childNode.name===nodeName||childNode.uuid===nodeName){return childNode;}var result=searchNodeSubtree(childNode.children);if(result)return result;}return null;};var subTreeNode=searchNodeSubtree(root.children);if(subTreeNode){return subTreeNode;}}return null;}});Object.assign(PropertyBinding.prototype,{// prototype, continued
// these are used to "bind" a nonexistent property
_getValue_unavailable:function _getValue_unavailable(){},_setValue_unavailable:function _setValue_unavailable(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function getValue_direct(buffer,offset){buffer[offset]=this.node[this.propertyName];},function getValue_array(buffer,offset){var source=this.resolvedProperty;for(var i=0,n=source.length;i!==n;++i){buffer[offset++]=source[i];}},function getValue_arrayElement(buffer,offset){buffer[offset]=this.resolvedProperty[this.propertyIndex];},function getValue_toArray(buffer,offset){this.resolvedProperty.toArray(buffer,offset);}],SetterByBindingTypeAndVersioning:[[// Direct
function setValue_direct(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];},function setValue_direct_setNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.needsUpdate=true;},function setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}],[// EntireArray
function setValue_array(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}},function setValue_array_setNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.needsUpdate=true;},function setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.matrixWorldNeedsUpdate=true;}],[// ArrayElement
function setValue_arrayElement(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];},function setValue_arrayElement_setNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.needsUpdate=true;},function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}],[// HasToFromArray
function setValue_fromArray(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);},function setValue_fromArray_setNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.needsUpdate=true;},function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.matrixWorldNeedsUpdate=true;}]],getValue:function getValue_unbound(targetArray,offset){this.bind();this.getValue(targetArray,offset);// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
},setValue:function getValue_unbound(sourceArray,offset){this.bind();this.setValue(sourceArray,offset);},// create getter / setter pair for a property in the scene graph
bind:function bind(){var targetObject=this.node,parsedPath=this.parsedPath,objectName=parsedPath.objectName,propertyName=parsedPath.propertyName,propertyIndex=parsedPath.propertyIndex;if(!targetObject){targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName)||this.rootNode;this.node=targetObject;}// set fail state so we can just 'return' on error
this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;// ensure there is a value node
if(!targetObject){console.error('THREE.PropertyBinding: Trying to update node for track: '+this.path+' but it wasn\'t found.');return;}if(objectName){var objectIndex=parsedPath.objectIndex;// special cases were we need to reach deeper into the hierarchy to get the face materials....
switch(objectName){case'materials':if(!targetObject.material){console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.',this);return;}if(!targetObject.material.materials){console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',this);return;}targetObject=targetObject.material.materials;break;case'bones':if(!targetObject.skeleton){console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',this);return;}// potential future optimization: skip this if propertyIndex is already an integer
// and convert the integer string to a true integer.
targetObject=targetObject.skeleton.bones;// support resolving morphTarget names into indices.
for(var i=0;i<targetObject.length;i++){if(targetObject[i].name===objectIndex){objectIndex=i;break;}}break;default:if(targetObject[objectName]===undefined){console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.',this);return;}targetObject=targetObject[objectName];}if(objectIndex!==undefined){if(targetObject[objectIndex]===undefined){console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',this,targetObject);return;}targetObject=targetObject[objectIndex];}}// resolve property
var nodeProperty=targetObject[propertyName];if(nodeProperty===undefined){var nodeName=parsedPath.nodeName;console.error('THREE.PropertyBinding: Trying to update property for track: '+nodeName+'.'+propertyName+' but it wasn\'t found.',targetObject);return;}// determine versioning scheme
var versioning=this.Versioning.None;if(targetObject.needsUpdate!==undefined){// material
versioning=this.Versioning.NeedsUpdate;this.targetObject=targetObject;}else if(targetObject.matrixWorldNeedsUpdate!==undefined){// node transform
versioning=this.Versioning.MatrixWorldNeedsUpdate;this.targetObject=targetObject;}// determine how the property gets bound
var bindingType=this.BindingType.Direct;if(propertyIndex!==undefined){// access a sub element of the property array (only primitives are supported right now)
if(propertyName==="morphTargetInfluences"){// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
// support resolving morphTarget names into indices.
if(!targetObject.geometry){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',this);return;}if(targetObject.geometry.isBufferGeometry){if(!targetObject.geometry.morphAttributes){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',this);return;}for(var i=0;i<this.node.geometry.morphAttributes.position.length;i++){if(targetObject.geometry.morphAttributes.position[i].name===propertyIndex){propertyIndex=i;break;}}}else{if(!targetObject.geometry.morphTargets){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.',this);return;}for(var i=0;i<this.node.geometry.morphTargets.length;i++){if(targetObject.geometry.morphTargets[i].name===propertyIndex){propertyIndex=i;break;}}}}bindingType=this.BindingType.ArrayElement;this.resolvedProperty=nodeProperty;this.propertyIndex=propertyIndex;}else if(nodeProperty.fromArray!==undefined&&nodeProperty.toArray!==undefined){// must use copy for Object3D.Euler/Quaternion
bindingType=this.BindingType.HasFromToArray;this.resolvedProperty=nodeProperty;}else if(Array.isArray(nodeProperty)){bindingType=this.BindingType.EntireArray;this.resolvedProperty=nodeProperty;}else{this.propertyName=propertyName;}// select getter / setter
this.getValue=this.GetterByBindingType[bindingType];this.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning];},unbind:function unbind(){this.node=null;// back to the prototype version of getValue / setValue
// note: avoiding to mutate the shape of 'this' via 'delete'
this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound;}});//!\ DECLARE ALIAS AFTER assign prototype !
Object.assign(PropertyBinding.prototype,{// initial state of these methods that calls 'bind'
_getValue_unbound:PropertyBinding.prototype.getValue,_setValue_unbound:PropertyBinding.prototype.setValue});/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 * 	-	Add objects you would otherwise pass as 'root' to the
	 * 		constructor or the .clipAction method of AnimationMixer.
	 *
	 * 	-	Instead pass this object as 'root'.
	 *
	 * 	-	You can also add and remove objects later when the mixer
	 * 		is running.
	 *
	 * Note:
	 *
	 *  	Objects of this class appear as one object to the mixer,
	 *  	so cache control of the individual objects must be done
	 *  	on the group.
	 *
	 * Limitation:
	 *
	 * 	- 	The animated properties must be compatible among the
	 * 		all objects in the group.
	 *
	 *  -	A single property can either be controlled through a
	 *  	target group or directly, but not both.
	 *
	 * @author tschw
	 */function AnimationObjectGroup(){this.uuid=_Math.generateUUID();// cached objects followed by the active ones
this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;// threshold
// note: read by PropertyBinding.Composite
var indices={};this._indicesByUUID=indices;// for bookkeeping
for(var i=0,n=arguments.length;i!==n;++i){indices[arguments[i].uuid]=i;}this._paths=[];// inside: string
this._parsedPaths=[];// inside: { we don't care, here }
this._bindings=[];// inside: Array< PropertyBinding >
this._bindingsIndicesByPath={};// inside: indices in these arrays
var scope=this;this.stats={objects:{get total(){return scope._objects.length;},get inUse(){return this.total-scope.nCachedObjects_;}},get bindingsPerObject(){return scope._bindings.length;}};}Object.assign(AnimationObjectGroup.prototype,{isAnimationObjectGroup:true,add:function add(){var objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid],knownObject=undefined;if(index===undefined){// unknown object -> add it to the ACTIVE region
index=nObjects++;indicesByUUID[uuid]=index;objects.push(object);// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){bindings[j].push(new PropertyBinding(object,paths[j],parsedPaths[j]));}}else if(index<nCachedObjects){knownObject=objects[index];// move existing object to the ACTIVE region
var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex];indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;indicesByUUID[uuid]=firstActiveIndex;objects[firstActiveIndex]=object;// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],binding=bindingsForPath[index];bindingsForPath[index]=lastCached;if(binding===undefined){// since we do not bother to create new bindings
// for objects that are cached, the binding may
// or may not exist
binding=new PropertyBinding(object,paths[j],parsedPaths[j]);}bindingsForPath[firstActiveIndex]=binding;}}else if(objects[index]!==knownObject){console.error('THREE.AnimationObjectGroup: Different objects with the same UUID '+'detected. Clean the caches or recreate your infrastructure when reloading scenes.');}// else the object is already where we want it to be
}// for arguments
this.nCachedObjects_=nCachedObjects;},remove:function remove(){var objects=this._objects,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined&&index>=nCachedObjects){// move existing object into the CACHED region
var lastCachedIndex=nCachedObjects++,firstActiveObject=objects[lastCachedIndex];indicesByUUID[firstActiveObject.uuid]=index;objects[index]=firstActiveObject;indicesByUUID[uuid]=lastCachedIndex;objects[lastCachedIndex]=object;// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],firstActive=bindingsForPath[lastCachedIndex],binding=bindingsForPath[index];bindingsForPath[index]=firstActive;bindingsForPath[lastCachedIndex]=binding;}}}// for arguments
this.nCachedObjects_=nCachedObjects;},// remove & forget
uncache:function uncache(){var objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined){delete indicesByUUID[uuid];if(index<nCachedObjects){// object is cached, shrink the CACHED region
var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex],lastIndex=--nObjects,lastObject=objects[lastIndex];// last cached object takes this object's place
indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;// last object goes to the activated slot and pop
indicesByUUID[lastObject.uuid]=firstActiveIndex;objects[firstActiveIndex]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],last=bindingsForPath[lastIndex];bindingsForPath[index]=lastCached;bindingsForPath[firstActiveIndex]=last;bindingsForPath.pop();}}else{// object is active, just swap with the last and pop
var lastIndex=--nObjects,lastObject=objects[lastIndex];indicesByUUID[lastObject.uuid]=index;objects[index]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j];bindingsForPath[index]=bindingsForPath[lastIndex];bindingsForPath.pop();}}// cached or active
}// if object is known
}// for arguments
this.nCachedObjects_=nCachedObjects;},// Internal interface used by befriended PropertyBinding.Composite:
subscribe_:function subscribe_(path,parsedPath){// returns an array of bindings for the given path that is changed
// according to the contained objects in the group
var indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path],bindings=this._bindings;if(index!==undefined)return bindings[index];var paths=this._paths,parsedPaths=this._parsedPaths,objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,bindingsForPath=new Array(nObjects);index=bindings.length;indicesByPath[path]=index;paths.push(path);parsedPaths.push(parsedPath);bindings.push(bindingsForPath);for(var i=nCachedObjects,n=objects.length;i!==n;++i){var object=objects[i];bindingsForPath[i]=new PropertyBinding(object,path,parsedPath);}return bindingsForPath;},unsubscribe_:function unsubscribe_(path){// tells the group to forget about a property path and no longer
// update the array previously obtained with 'subscribe_'
var indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path];if(index!==undefined){var paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,lastBindingsIndex=bindings.length-1,lastBindings=bindings[lastBindingsIndex],lastBindingsPath=path[lastBindingsIndex];indicesByPath[lastBindingsPath]=index;bindings[index]=lastBindings;bindings.pop();parsedPaths[index]=parsedPaths[lastBindingsIndex];parsedPaths.pop();paths[index]=paths[lastBindingsIndex];paths.pop();}}});/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */function AnimationAction(mixer,clip,localRoot){this._mixer=mixer;this._clip=clip;this._localRoot=localRoot||null;var tracks=clip.tracks,nTracks=tracks.length,interpolants=new Array(nTracks);var interpolantSettings={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(var i=0;i!==nTracks;++i){var interpolant=tracks[i].createInterpolant(null);interpolants[i]=interpolant;interpolant.settings=interpolantSettings;}this._interpolantSettings=interpolantSettings;this._interpolants=interpolants;// bound by the mixer
// inside: PropertyMixer (managed by the mixer)
this._propertyBindings=new Array(nTracks);this._cacheIndex=null;// for the memory manager
this._byClipCacheIndex=null;// for the memory manager
this._timeScaleInterpolant=null;this._weightInterpolant=null;this.loop=LoopRepeat;this._loopCount=-1;// global mixer time when the action is to be started
// it's set back to 'null' upon start of the action
this._startTime=null;// scaled local time of the action
// gets clamped or wrapped to 0..clip.duration according to loop
this.time=0;this.timeScale=1;this._effectiveTimeScale=1;this.weight=1;this._effectiveWeight=1;this.repetitions=Infinity;// no. of repetitions when looping
this.paused=false;// true -> zero effective time scale
this.enabled=true;// false -> zero effective weight
this.clampWhenFinished=false;// keep feeding the last frame?
this.zeroSlopeAtStart=true;// for smooth interpolation w/o separate
this.zeroSlopeAtEnd=true;// clips for start, loop and end
}Object.assign(AnimationAction.prototype,{// State & Scheduling
play:function play(){this._mixer._activateAction(this);return this;},stop:function stop(){this._mixer._deactivateAction(this);return this.reset();},reset:function reset(){this.paused=false;this.enabled=true;this.time=0;// restart clip
this._loopCount=-1;// forget previous loops
this._startTime=null;// forget scheduling
return this.stopFading().stopWarping();},isRunning:function isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this);},// return true when play has been called
isScheduled:function isScheduled(){return this._mixer._isActiveAction(this);},startAt:function startAt(time){this._startTime=time;return this;},setLoop:function setLoop(mode,repetitions){this.loop=mode;this.repetitions=repetitions;return this;},// Weight
// set the weight stopping any scheduled fading
// although .enabled = false yields an effective weight of zero, this
// method does *not* change .enabled, because it would be confusing
setEffectiveWeight:function setEffectiveWeight(weight){this.weight=weight;// note: same logic as when updated at runtime
this._effectiveWeight=this.enabled?weight:0;return this.stopFading();},// return the weight considering fading and .enabled
getEffectiveWeight:function getEffectiveWeight(){return this._effectiveWeight;},fadeIn:function fadeIn(duration){return this._scheduleFading(duration,0,1);},fadeOut:function fadeOut(duration){return this._scheduleFading(duration,1,0);},crossFadeFrom:function crossFadeFrom(fadeOutAction,duration,warp){fadeOutAction.fadeOut(duration);this.fadeIn(duration);if(warp){var fadeInDuration=this._clip.duration,fadeOutDuration=fadeOutAction._clip.duration,startEndRatio=fadeOutDuration/fadeInDuration,endStartRatio=fadeInDuration/fadeOutDuration;fadeOutAction.warp(1.0,startEndRatio,duration);this.warp(endStartRatio,1.0,duration);}return this;},crossFadeTo:function crossFadeTo(fadeInAction,duration,warp){return fadeInAction.crossFadeFrom(this,duration,warp);},stopFading:function stopFading(){var weightInterpolant=this._weightInterpolant;if(weightInterpolant!==null){this._weightInterpolant=null;this._mixer._takeBackControlInterpolant(weightInterpolant);}return this;},// Time Scale Control
// set the time scale stopping any scheduled warping
// although .paused = true yields an effective time scale of zero, this
// method does *not* change .paused, because it would be confusing
setEffectiveTimeScale:function setEffectiveTimeScale(timeScale){this.timeScale=timeScale;this._effectiveTimeScale=this.paused?0:timeScale;return this.stopWarping();},// return the time scale considering warping and .paused
getEffectiveTimeScale:function getEffectiveTimeScale(){return this._effectiveTimeScale;},setDuration:function setDuration(duration){this.timeScale=this._clip.duration/duration;return this.stopWarping();},syncWith:function syncWith(action){this.time=action.time;this.timeScale=action.timeScale;return this.stopWarping();},halt:function halt(duration){return this.warp(this._effectiveTimeScale,0,duration);},warp:function warp(startTimeScale,endTimeScale,duration){var mixer=this._mixer,now=mixer.time,interpolant=this._timeScaleInterpolant,timeScale=this.timeScale;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._timeScaleInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;times[1]=now+duration;values[0]=startTimeScale/timeScale;values[1]=endTimeScale/timeScale;return this;},stopWarping:function stopWarping(){var timeScaleInterpolant=this._timeScaleInterpolant;if(timeScaleInterpolant!==null){this._timeScaleInterpolant=null;this._mixer._takeBackControlInterpolant(timeScaleInterpolant);}return this;},// Object Accessors
getMixer:function getMixer(){return this._mixer;},getClip:function getClip(){return this._clip;},getRoot:function getRoot(){return this._localRoot||this._mixer._root;},// Interna
_update:function _update(time,deltaTime,timeDirection,accuIndex){// called by the mixer
if(!this.enabled){// call ._updateWeight() to update ._effectiveWeight
this._updateWeight(time);return;}var startTime=this._startTime;if(startTime!==null){// check for scheduled start of action
var timeRunning=(time-startTime)*timeDirection;if(timeRunning<0||timeDirection===0){return;// yet to come / don't decide when delta = 0
}// start
this._startTime=null;// unschedule
deltaTime=timeDirection*timeRunning;}// apply time scale and advance time
deltaTime*=this._updateTimeScale(time);var clipTime=this._updateTime(deltaTime);// note: _updateTime may disable the action resulting in
// an effective weight of 0
var weight=this._updateWeight(time);if(weight>0){var interpolants=this._interpolants;var propertyMixers=this._propertyBindings;for(var j=0,m=interpolants.length;j!==m;++j){interpolants[j].evaluate(clipTime);propertyMixers[j].accumulate(accuIndex,weight);}}},_updateWeight:function _updateWeight(time){var weight=0;if(this.enabled){weight=this.weight;var interpolant=this._weightInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];weight*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopFading();if(interpolantValue===0){// faded out, disable
this.enabled=false;}}}}this._effectiveWeight=weight;return weight;},_updateTimeScale:function _updateTimeScale(time){var timeScale=0;if(!this.paused){timeScale=this.timeScale;var interpolant=this._timeScaleInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];timeScale*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopWarping();if(timeScale===0){// motion has halted, pause
this.paused=true;}else{// warp done - apply final time scale
this.timeScale=timeScale;}}}}this._effectiveTimeScale=timeScale;return timeScale;},_updateTime:function _updateTime(deltaTime){var time=this.time+deltaTime;if(deltaTime===0)return time;var duration=this._clip.duration,loop=this.loop,loopCount=this._loopCount;if(loop===LoopOnce){if(loopCount===-1){// just started
this._loopCount=0;this._setEndings(true,true,false);}handle_stop:{if(time>=duration){time=duration;}else if(time<0){time=0;}else break handle_stop;if(this.clampWhenFinished)this.paused=true;else this.enabled=false;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime<0?-1:1});}}else{// repetitive Repeat or PingPong
var pingPong=loop===LoopPingPong;if(loopCount===-1){// just started
if(deltaTime>=0){loopCount=0;this._setEndings(true,this.repetitions===0,pingPong);}else{// when looping in reverse direction, the initial
// transition through zero counts as a repetition,
// so leave loopCount at -1
this._setEndings(this.repetitions===0,true,pingPong);}}if(time>=duration||time<0){// wrap around
var loopDelta=Math.floor(time/duration);// signed
time-=duration*loopDelta;loopCount+=Math.abs(loopDelta);var pending=this.repetitions-loopCount;if(pending<0){// have to stop (switch state, clamp time, fire event)
if(this.clampWhenFinished)this.paused=true;else this.enabled=false;time=deltaTime>0?duration:0;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime>0?1:-1});}else{// keep running
if(pending===0){// entering the last round
var atStart=deltaTime<0;this._setEndings(atStart,!atStart,pingPong);}else{this._setEndings(false,false,pingPong);}this._loopCount=loopCount;this._mixer.dispatchEvent({type:'loop',action:this,loopDelta:loopDelta});}}if(pingPong&&(loopCount&1)===1){// invert time for the "pong round"
this.time=time;return duration-time;}}this.time=time;return time;},_setEndings:function _setEndings(atStart,atEnd,pingPong){var settings=this._interpolantSettings;if(pingPong){settings.endingStart=ZeroSlopeEnding;settings.endingEnd=ZeroSlopeEnding;}else{// assuming for LoopOnce atStart == atEnd == true
if(atStart){settings.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingStart=WrapAroundEnding;}if(atEnd){settings.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingEnd=WrapAroundEnding;}}},_scheduleFading:function _scheduleFading(duration,weightNow,weightThen){var mixer=this._mixer,now=mixer.time,interpolant=this._weightInterpolant;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._weightInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;values[0]=weightNow;times[1]=now+duration;values[1]=weightThen;return this;}});/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */function AnimationMixer(root){this._root=root;this._initMemoryManager();this._accuIndex=0;this.time=0;this.timeScale=1.0;}Object.assign(AnimationMixer.prototype,EventDispatcher.prototype,{_bindAction:function _bindAction(action,prototypeAction){var root=action._localRoot||this._root,tracks=action._clip.tracks,nTracks=tracks.length,bindings=action._propertyBindings,interpolants=action._interpolants,rootUuid=root.uuid,bindingsByRoot=this._bindingsByRootAndName,bindingsByName=bindingsByRoot[rootUuid];if(bindingsByName===undefined){bindingsByName={};bindingsByRoot[rootUuid]=bindingsByName;}for(var i=0;i!==nTracks;++i){var track=tracks[i],trackName=track.name,binding=bindingsByName[trackName];if(binding!==undefined){bindings[i]=binding;}else{binding=bindings[i];if(binding!==undefined){// existing binding, make sure the cache knows
if(binding._cacheIndex===null){++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);}continue;}var path=prototypeAction&&prototypeAction._propertyBindings[i].binding.parsedPath;binding=new PropertyMixer(PropertyBinding.create(root,trackName,path),track.ValueTypeName,track.getValueSize());++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);bindings[i]=binding;}interpolants[i].resultBuffer=binding.buffer;}},_activateAction:function _activateAction(action){if(!this._isActiveAction(action)){if(action._cacheIndex===null){// this action has been forgotten by the cache, but the user
// appears to be still using it -> rebind
var rootUuid=(action._localRoot||this._root).uuid,clipUuid=action._clip.uuid,actionsForClip=this._actionsByClip[clipUuid];this._bindAction(action,actionsForClip&&actionsForClip.knownActions[0]);this._addInactiveAction(action,clipUuid,rootUuid);}var bindings=action._propertyBindings;// increment reference counts / sort out state
for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(binding.useCount++===0){this._lendBinding(binding);binding.saveOriginalState();}}this._lendAction(action);}},_deactivateAction:function _deactivateAction(action){if(this._isActiveAction(action)){var bindings=action._propertyBindings;// decrement reference counts / sort out state
for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(--binding.useCount===0){binding.restoreOriginalState();this._takeBackBinding(binding);}}this._takeBackAction(action);}},// Memory manager
_initMemoryManager:function _initMemoryManager(){this._actions=[];// 'nActiveActions' followed by inactive ones
this._nActiveActions=0;this._actionsByClip={};// inside:
// {
// 		knownActions: Array< AnimationAction >	- used as prototypes
// 		actionByRoot: AnimationAction			- lookup
// }
this._bindings=[];// 'nActiveBindings' followed by inactive ones
this._nActiveBindings=0;this._bindingsByRootAndName={};// inside: Map< name, PropertyMixer >
this._controlInterpolants=[];// same game as above
this._nActiveControlInterpolants=0;var scope=this;this.stats={actions:{get total(){return scope._actions.length;},get inUse(){return scope._nActiveActions;}},bindings:{get total(){return scope._bindings.length;},get inUse(){return scope._nActiveBindings;}},controlInterpolants:{get total(){return scope._controlInterpolants.length;},get inUse(){return scope._nActiveControlInterpolants;}}};},// Memory management for AnimationAction objects
_isActiveAction:function _isActiveAction(action){var index=action._cacheIndex;return index!==null&&index<this._nActiveActions;},_addInactiveAction:function _addInactiveAction(action,clipUuid,rootUuid){var actions=this._actions,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip===undefined){actionsForClip={knownActions:[action],actionByRoot:{}};action._byClipCacheIndex=0;actionsByClip[clipUuid]=actionsForClip;}else{var knownActions=actionsForClip.knownActions;action._byClipCacheIndex=knownActions.length;knownActions.push(action);}action._cacheIndex=actions.length;actions.push(action);actionsForClip.actionByRoot[rootUuid]=action;},_removeInactiveAction:function _removeInactiveAction(action){var actions=this._actions,lastInactiveAction=actions[actions.length-1],cacheIndex=action._cacheIndex;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();action._cacheIndex=null;var clipUuid=action._clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid],knownActionsForClip=actionsForClip.knownActions,lastKnownAction=knownActionsForClip[knownActionsForClip.length-1],byClipCacheIndex=action._byClipCacheIndex;lastKnownAction._byClipCacheIndex=byClipCacheIndex;knownActionsForClip[byClipCacheIndex]=lastKnownAction;knownActionsForClip.pop();action._byClipCacheIndex=null;var actionByRoot=actionsForClip.actionByRoot,rootUuid=(action._localRoot||this._root).uuid;delete actionByRoot[rootUuid];if(knownActionsForClip.length===0){delete actionsByClip[clipUuid];}this._removeInactiveBindingsForAction(action);},_removeInactiveBindingsForAction:function _removeInactiveBindingsForAction(action){var bindings=action._propertyBindings;for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(--binding.referenceCount===0){this._removeInactiveBinding(binding);}}},_lendAction:function _lendAction(action){// [ active actions |  inactive actions  ]
// [  active actions >| inactive actions ]
//                 s        a
//                  <-swap->
//                 a        s
var actions=this._actions,prevIndex=action._cacheIndex,lastActiveIndex=this._nActiveActions++,firstInactiveAction=actions[lastActiveIndex];action._cacheIndex=lastActiveIndex;actions[lastActiveIndex]=action;firstInactiveAction._cacheIndex=prevIndex;actions[prevIndex]=firstInactiveAction;},_takeBackAction:function _takeBackAction(action){// [  active actions  | inactive actions ]
// [ active actions |< inactive actions  ]
//        a        s
//         <-swap->
//        s        a
var actions=this._actions,prevIndex=action._cacheIndex,firstInactiveIndex=--this._nActiveActions,lastActiveAction=actions[firstInactiveIndex];action._cacheIndex=firstInactiveIndex;actions[firstInactiveIndex]=action;lastActiveAction._cacheIndex=prevIndex;actions[prevIndex]=lastActiveAction;},// Memory management for PropertyMixer objects
_addInactiveBinding:function _addInactiveBinding(binding,rootUuid,trackName){var bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],bindings=this._bindings;if(bindingByName===undefined){bindingByName={};bindingsByRoot[rootUuid]=bindingByName;}bindingByName[trackName]=binding;binding._cacheIndex=bindings.length;bindings.push(binding);},_removeInactiveBinding:function _removeInactiveBinding(binding){var bindings=this._bindings,propBinding=binding.binding,rootUuid=propBinding.rootNode.uuid,trackName=propBinding.path,bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],lastInactiveBinding=bindings[bindings.length-1],cacheIndex=binding._cacheIndex;lastInactiveBinding._cacheIndex=cacheIndex;bindings[cacheIndex]=lastInactiveBinding;bindings.pop();delete bindingByName[trackName];remove_empty_map:{for(var _ in bindingByName){break remove_empty_map;}// eslint-disable-line no-unused-vars
delete bindingsByRoot[rootUuid];}},_lendBinding:function _lendBinding(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,lastActiveIndex=this._nActiveBindings++,firstInactiveBinding=bindings[lastActiveIndex];binding._cacheIndex=lastActiveIndex;bindings[lastActiveIndex]=binding;firstInactiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=firstInactiveBinding;},_takeBackBinding:function _takeBackBinding(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,firstInactiveIndex=--this._nActiveBindings,lastActiveBinding=bindings[firstInactiveIndex];binding._cacheIndex=firstInactiveIndex;bindings[firstInactiveIndex]=binding;lastActiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=lastActiveBinding;},// Memory management of Interpolants for weight and time scale
_lendControlInterpolant:function _lendControlInterpolant(){var interpolants=this._controlInterpolants,lastActiveIndex=this._nActiveControlInterpolants++,interpolant=interpolants[lastActiveIndex];if(interpolant===undefined){interpolant=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer);interpolant.__cacheIndex=lastActiveIndex;interpolants[lastActiveIndex]=interpolant;}return interpolant;},_takeBackControlInterpolant:function _takeBackControlInterpolant(interpolant){var interpolants=this._controlInterpolants,prevIndex=interpolant.__cacheIndex,firstInactiveIndex=--this._nActiveControlInterpolants,lastActiveInterpolant=interpolants[firstInactiveIndex];interpolant.__cacheIndex=firstInactiveIndex;interpolants[firstInactiveIndex]=interpolant;lastActiveInterpolant.__cacheIndex=prevIndex;interpolants[prevIndex]=lastActiveInterpolant;},_controlInterpolantsResultBuffer:new Float32Array(1),// return an action for a clip optionally using a custom root target
// object (this method allocates a lot of dynamic memory in case a
// previously unknown clip/root combination is specified)
clipAction:function clipAction(clip,optionalRoot){var root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject!==null?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid],prototypeAction=null;if(actionsForClip!==undefined){var existingAction=actionsForClip.actionByRoot[rootUuid];if(existingAction!==undefined){return existingAction;}// we know the clip, so we don't have to parse all
// the bindings again but can just copy
prototypeAction=actionsForClip.knownActions[0];// also, take the clip from the prototype action
if(clipObject===null)clipObject=prototypeAction._clip;}// clip must be known when specified via string
if(clipObject===null)return null;// allocate all resources required to run it
var newAction=new AnimationAction(this,clipObject,optionalRoot);this._bindAction(newAction,prototypeAction);// and make the action known to the memory manager
this._addInactiveAction(newAction,clipUuid,rootUuid);return newAction;},// get an existing action
existingAction:function existingAction(clip,optionalRoot){var root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid];if(actionsForClip!==undefined){return actionsForClip.actionByRoot[rootUuid]||null;}return null;},// deactivates all previously scheduled actions
stopAllAction:function stopAllAction(){var actions=this._actions,nActions=this._nActiveActions,bindings=this._bindings,nBindings=this._nActiveBindings;this._nActiveActions=0;this._nActiveBindings=0;for(var i=0;i!==nActions;++i){actions[i].reset();}for(var i=0;i!==nBindings;++i){bindings[i].useCount=0;}return this;},// advance the time and update apply the animation
update:function update(deltaTime){deltaTime*=this.timeScale;var actions=this._actions,nActions=this._nActiveActions,time=this.time+=deltaTime,timeDirection=Math.sign(deltaTime),accuIndex=this._accuIndex^=1;// run active actions
for(var i=0;i!==nActions;++i){var action=actions[i];action._update(time,deltaTime,timeDirection,accuIndex);}// update scene graph
var bindings=this._bindings,nBindings=this._nActiveBindings;for(var i=0;i!==nBindings;++i){bindings[i].apply(accuIndex);}return this;},// return this mixer's root target object
getRoot:function getRoot(){return this._root;},// free all resources specific to a particular clip
uncacheClip:function uncacheClip(clip){var actions=this._actions,clipUuid=clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip!==undefined){// note: just calling _removeInactiveAction would mess up the
// iteration state and also require updating the state we can
// just throw away
var actionsToRemove=actionsForClip.knownActions;for(var i=0,n=actionsToRemove.length;i!==n;++i){var action=actionsToRemove[i];this._deactivateAction(action);var cacheIndex=action._cacheIndex,lastInactiveAction=actions[actions.length-1];action._cacheIndex=null;action._byClipCacheIndex=null;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();this._removeInactiveBindingsForAction(action);}delete actionsByClip[clipUuid];}},// free all resources specific to a particular root target object
uncacheRoot:function uncacheRoot(root){var rootUuid=root.uuid,actionsByClip=this._actionsByClip;for(var clipUuid in actionsByClip){var actionByRoot=actionsByClip[clipUuid].actionByRoot,action=actionByRoot[rootUuid];if(action!==undefined){this._deactivateAction(action);this._removeInactiveAction(action);}}var bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid];if(bindingByName!==undefined){for(var trackName in bindingByName){var binding=bindingByName[trackName];binding.restoreOriginalState();this._removeInactiveBinding(binding);}}},// remove a targeted clip from the cache
uncacheAction:function uncacheAction(clip,optionalRoot){var action=this.existingAction(clip,optionalRoot);if(action!==null){this._deactivateAction(action);this._removeInactiveAction(action);}}});/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Uniform(value){if(typeof value==='string'){console.warn('THREE.Uniform: Type parameter is no longer needed.');value=arguments[1];}this.value=value;}Uniform.prototype.clone=function(){return new Uniform(this.value.clone===undefined?this.value:this.value.clone());};/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */function InstancedBufferGeometry(){BufferGeometry.call(this);this.type='InstancedBufferGeometry';this.maxInstancedCount=undefined;}InstancedBufferGeometry.prototype=Object.assign(Object.create(BufferGeometry.prototype),{constructor:InstancedBufferGeometry,isInstancedBufferGeometry:true,copy:function copy(source){BufferGeometry.prototype.copy.call(this,source);this.maxInstancedCount=source.maxInstancedCount;return this;},clone:function clone(){return new this.constructor().copy(this);}});/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */function InterleavedBufferAttribute(interleavedBuffer,itemSize,offset,normalized){this.uuid=_Math.generateUUID();this.data=interleavedBuffer;this.itemSize=itemSize;this.offset=offset;this.normalized=normalized===true;}Object.defineProperties(InterleavedBufferAttribute.prototype,{count:{get:function get(){return this.data.count;}},array:{get:function get(){return this.data.array;}}});Object.assign(InterleavedBufferAttribute.prototype,{isInterleavedBufferAttribute:true,setX:function setX(index,x){this.data.array[index*this.data.stride+this.offset]=x;return this;},setY:function setY(index,y){this.data.array[index*this.data.stride+this.offset+1]=y;return this;},setZ:function setZ(index,z){this.data.array[index*this.data.stride+this.offset+2]=z;return this;},setW:function setW(index,w){this.data.array[index*this.data.stride+this.offset+3]=w;return this;},getX:function getX(index){return this.data.array[index*this.data.stride+this.offset];},getY:function getY(index){return this.data.array[index*this.data.stride+this.offset+1];},getZ:function getZ(index){return this.data.array[index*this.data.stride+this.offset+2];},getW:function getW(index){return this.data.array[index*this.data.stride+this.offset+3];},setXY:function setXY(index,x,y){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;return this;},setXYZ:function setXYZ(index,x,y,z){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;return this;},setXYZW:function setXYZW(index,x,y,z,w){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;this.data.array[index+3]=w;return this;}});/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */function InterleavedBuffer(array,stride){this.uuid=_Math.generateUUID();this.array=array;this.stride=stride;this.count=array!==undefined?array.length/stride:0;this.dynamic=false;this.updateRange={offset:0,count:-1};this.onUploadCallback=function(){};this.version=0;}Object.defineProperty(InterleavedBuffer.prototype,'needsUpdate',{set:function set(value){if(value===true)this.version++;}});Object.assign(InterleavedBuffer.prototype,{isInterleavedBuffer:true,setArray:function setArray(array){if(Array.isArray(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.count=array!==undefined?array.length/this.stride:0;this.array=array;},setDynamic:function setDynamic(value){this.dynamic=value;return this;},copy:function copy(source){this.array=new source.array.constructor(source.array);this.count=source.count;this.stride=source.stride;this.dynamic=source.dynamic;return this;},copyAt:function copyAt(index1,attribute,index2){index1*=this.stride;index2*=attribute.stride;for(var i=0,l=this.stride;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;},set:function set(value,offset){if(offset===undefined)offset=0;this.array.set(value,offset);return this;},clone:function clone(){return new this.constructor().copy(this);},onUpload:function onUpload(callback){this.onUploadCallback=callback;return this;}});/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */function InstancedInterleavedBuffer(array,stride,meshPerAttribute){InterleavedBuffer.call(this,array,stride);this.meshPerAttribute=meshPerAttribute||1;}InstancedInterleavedBuffer.prototype=Object.assign(Object.create(InterleavedBuffer.prototype),{constructor:InstancedInterleavedBuffer,isInstancedInterleavedBuffer:true,copy:function copy(source){InterleavedBuffer.prototype.copy.call(this,source);this.meshPerAttribute=source.meshPerAttribute;return this;}});/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */function InstancedBufferAttribute(array,itemSize,meshPerAttribute){BufferAttribute.call(this,array,itemSize);this.meshPerAttribute=meshPerAttribute||1;}InstancedBufferAttribute.prototype=Object.assign(Object.create(BufferAttribute.prototype),{constructor:InstancedBufferAttribute,isInstancedBufferAttribute:true,copy:function copy(source){BufferAttribute.prototype.copy.call(this,source);this.meshPerAttribute=source.meshPerAttribute;return this;}});/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */function Raycaster(origin,direction,near,far){this.ray=new Ray(origin,direction);// direction is assumed to be normalized (for accurate distance calculations)
this.near=near||0;this.far=far||Infinity;this.params={Mesh:{},Line:{},LOD:{},Points:{threshold:1},Sprite:{}};Object.defineProperties(this.params,{PointCloud:{get:function get(){console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');return this.Points;}}});}function ascSort(a,b){return a.distance-b.distance;}function _intersectObject(object,raycaster,intersects,recursive){if(object.visible===false)return;object.raycast(raycaster,intersects);if(recursive===true){var children=object.children;for(var i=0,l=children.length;i<l;i++){_intersectObject(children[i],raycaster,intersects,true);}}}Object.assign(Raycaster.prototype,{linePrecision:1,set:function set(origin,direction){// direction is assumed to be normalized (for accurate distance calculations)
this.ray.set(origin,direction);},setFromCamera:function setFromCamera(coords,camera){if(camera&&camera.isPerspectiveCamera){this.ray.origin.setFromMatrixPosition(camera.matrixWorld);this.ray.direction.set(coords.x,coords.y,0.5).unproject(camera).sub(this.ray.origin).normalize();}else if(camera&&camera.isOrthographicCamera){this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera);// set origin in plane of camera
this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld);}else{console.error('THREE.Raycaster: Unsupported camera type.');}},intersectObject:function intersectObject(object,recursive){var intersects=[];_intersectObject(object,this,intersects,recursive);intersects.sort(ascSort);return intersects;},intersectObjects:function intersectObjects(objects,recursive){var intersects=[];if(Array.isArray(objects)===false){console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');return intersects;}for(var i=0,l=objects.length;i<l;i++){_intersectObject(objects[i],this,intersects,recursive);}intersects.sort(ascSort);return intersects;}});/**
	 * @author alteredq / http://alteredqualia.com/
	 */function Clock(autoStart){this.autoStart=autoStart!==undefined?autoStart:true;this.startTime=0;this.oldTime=0;this.elapsedTime=0;this.running=false;}Object.assign(Clock.prototype,{start:function start(){this.startTime=(typeof performance==='undefined'?Date:performance).now();// see #10732
this.oldTime=this.startTime;this.elapsedTime=0;this.running=true;},stop:function stop(){this.getElapsedTime();this.running=false;this.autoStart=false;},getElapsedTime:function getElapsedTime(){this.getDelta();return this.elapsedTime;},getDelta:function getDelta(){var diff=0;if(this.autoStart&&!this.running){this.start();return 0;}if(this.running){var newTime=(typeof performance==='undefined'?Date:performance).now();diff=(newTime-this.oldTime)/1000;this.oldTime=newTime;this.elapsedTime+=diff;}return diff;}});/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The poles (phi) are at the positive and negative y axis.
	 * The equator starts at positive z.
	 */function Spherical(radius,phi,theta){this.radius=radius!==undefined?radius:1.0;this.phi=phi!==undefined?phi:0;// up / down towards top and bottom pole
this.theta=theta!==undefined?theta:0;// around the equator of the sphere
return this;}Object.assign(Spherical.prototype,{set:function set(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(other){this.radius=other.radius;this.phi=other.phi;this.theta=other.theta;return this;},// restrict phi to be betwee EPS and PI-EPS
makeSafe:function makeSafe(){var EPS=0.000001;this.phi=Math.max(EPS,Math.min(Math.PI-EPS,this.phi));return this;},setFromVector3:function setFromVector3(vec3){this.radius=vec3.length();if(this.radius===0){this.theta=0;this.phi=0;}else{this.theta=Math.atan2(vec3.x,vec3.z);// equator angle around y-up axis
this.phi=Math.acos(_Math.clamp(vec3.y/this.radius,-1,1));// polar angle
}return this;}});/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 *
	 */function Cylindrical(radius,theta,y){this.radius=radius!==undefined?radius:1.0;// distance from the origin to a point in the x-z plane
this.theta=theta!==undefined?theta:0;// counterclockwise angle in the x-z plane measured in radians from the positive z-axis
this.y=y!==undefined?y:0;// height above the x-z plane
return this;}Object.assign(Cylindrical.prototype,{set:function set(radius,theta,y){this.radius=radius;this.theta=theta;this.y=y;return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(other){this.radius=other.radius;this.theta=other.theta;this.y=other.y;return this;},setFromVector3:function setFromVector3(vec3){this.radius=Math.sqrt(vec3.x*vec3.x+vec3.z*vec3.z);this.theta=Math.atan2(vec3.x,vec3.z);this.y=vec3.y;return this;}});/**
	 * @author alteredq / http://alteredqualia.com/
	 */function ImmediateRenderObject(material){Object3D.call(this);this.material=material;this.render=function()/* renderCallback */{};}ImmediateRenderObject.prototype=Object.create(Object3D.prototype);ImmediateRenderObject.prototype.constructor=ImmediateRenderObject;ImmediateRenderObject.prototype.isImmediateRenderObject=true;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */function VertexNormalsHelper(object,size,hex,linewidth){this.object=object;this.size=size!==undefined?size:1;var color=hex!==undefined?hex:0xff0000;var width=linewidth!==undefined?linewidth:1;//
var nNormals=0;var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){nNormals=objGeometry.faces.length*3;}else if(objGeometry&&objGeometry.isBufferGeometry){nNormals=objGeometry.attributes.normal.count;}//
var geometry=new BufferGeometry();var positions=new Float32BufferAttribute(nNormals*2*3,3);geometry.addAttribute('position',positions);LineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));//
this.matrixAutoUpdate=false;this.update();}VertexNormalsHelper.prototype=Object.create(LineSegments.prototype);VertexNormalsHelper.prototype.constructor=VertexNormalsHelper;VertexNormalsHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var normalMatrix=new Matrix3();return function update(){var keys=['a','b','c'];this.object.updateMatrixWorld(true);normalMatrix.getNormalMatrix(this.object.matrixWorld);var matrixWorld=this.object.matrixWorld;var position=this.geometry.attributes.position;//
var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){var vertices=objGeometry.vertices;var faces=objGeometry.faces;var idx=0;for(var i=0,l=faces.length;i<l;i++){var face=faces[i];for(var j=0,jl=face.vertexNormals.length;j<jl;j++){var vertex=vertices[face[keys[j]]];var normal=face.vertexNormals[j];v1.copy(vertex).applyMatrix4(matrixWorld);v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}}}else if(objGeometry&&objGeometry.isBufferGeometry){var objPos=objGeometry.attributes.position;var objNorm=objGeometry.attributes.normal;var idx=0;// for simplicity, ignore index and drawcalls, and render every normal
for(var j=0,jl=objPos.count;j<jl;j++){v1.set(objPos.getX(j),objPos.getY(j),objPos.getZ(j)).applyMatrix4(matrixWorld);v2.set(objNorm.getX(j),objNorm.getY(j),objNorm.getZ(j));v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}}position.needsUpdate=true;};}();/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */function SpotLightHelper(light,color){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;var geometry=new BufferGeometry();var positions=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(var i=0,j=1,l=32;i<l;i++,j++){var p1=i/l*Math.PI*2;var p2=j/l*Math.PI*2;positions.push(Math.cos(p1),Math.sin(p1),1,Math.cos(p2),Math.sin(p2),1);}geometry.addAttribute('position',new Float32BufferAttribute(positions,3));var material=new LineBasicMaterial({fog:false});this.cone=new LineSegments(geometry,material);this.add(this.cone);this.update();}SpotLightHelper.prototype=Object.create(Object3D.prototype);SpotLightHelper.prototype.constructor=SpotLightHelper;SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose();};SpotLightHelper.prototype.update=function(){var vector=new Vector3();var vector2=new Vector3();return function update(){this.light.updateMatrixWorld();var coneLength=this.light.distance?this.light.distance:1000;var coneWidth=coneLength*Math.tan(this.light.angle);this.cone.scale.set(coneWidth,coneWidth,coneLength);vector.setFromMatrixPosition(this.light.matrixWorld);vector2.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(vector2.sub(vector));if(this.color!==undefined){this.cone.material.color.set(this.color);}else{this.cone.material.color.copy(this.light.color);}};}();/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */function getBoneList(object){var boneList=[];if(object&&object.isBone){boneList.push(object);}for(var i=0;i<object.children.length;i++){boneList.push.apply(boneList,getBoneList(object.children[i]));}return boneList;}function SkeletonHelper(object){var bones=getBoneList(object);var geometry=new BufferGeometry();var vertices=[];var colors=[];var color1=new Color(0,0,1);var color2=new Color(0,1,0);for(var i=0;i<bones.length;i++){var bone=bones[i];if(bone.parent&&bone.parent.isBone){vertices.push(0,0,0);vertices.push(0,0,0);colors.push(color1.r,color1.g,color1.b);colors.push(color2.r,color2.g,color2.b);}}geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors,depthTest:false,depthWrite:false,transparent:true});LineSegments.call(this,geometry,material);this.root=object;this.bones=bones;this.matrix=object.matrixWorld;this.matrixAutoUpdate=false;}SkeletonHelper.prototype=Object.create(LineSegments.prototype);SkeletonHelper.prototype.constructor=SkeletonHelper;SkeletonHelper.prototype.updateMatrixWorld=function(){var vector=new Vector3();var boneMatrix=new Matrix4();var matrixWorldInv=new Matrix4();return function updateMatrixWorld(force){var bones=this.bones;var geometry=this.geometry;var position=geometry.getAttribute('position');matrixWorldInv.getInverse(this.root.matrixWorld);for(var i=0,j=0;i<bones.length;i++){var bone=bones[i];if(bone.parent&&bone.parent.isBone){boneMatrix.multiplyMatrices(matrixWorldInv,bone.matrixWorld);vector.setFromMatrixPosition(boneMatrix);position.setXYZ(j,vector.x,vector.y,vector.z);boneMatrix.multiplyMatrices(matrixWorldInv,bone.parent.matrixWorld);vector.setFromMatrixPosition(boneMatrix);position.setXYZ(j+1,vector.x,vector.y,vector.z);j+=2;}}geometry.getAttribute('position').needsUpdate=true;Object3D.prototype.updateMatrixWorld.call(this,force);};}();/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */function PointLightHelper(light,sphereSize,color){this.light=light;this.light.updateMatrixWorld();this.color=color;var geometry=new SphereBufferGeometry(sphereSize,4,2);var material=new MeshBasicMaterial({wireframe:true,fog:false});Mesh.call(this,geometry,material);this.matrix=this.light.matrixWorld;this.matrixAutoUpdate=false;this.update();/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/}PointLightHelper.prototype=Object.create(Mesh.prototype);PointLightHelper.prototype.constructor=PointLightHelper;PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose();};PointLightHelper.prototype.update=function(){if(this.color!==undefined){this.material.color.set(this.color);}else{this.material.color.copy(this.light.color);}/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/};/**
	 * @author abelnation / http://github.com/abelnation
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author WestLangley / http://github.com/WestLangley
	 */function RectAreaLightHelper(light,color){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;var material=new LineBasicMaterial({fog:false});var geometry=new BufferGeometry();geometry.addAttribute('position',new BufferAttribute(new Float32Array(5*3),3));this.line=new Line(geometry,material);this.add(this.line);this.update();}RectAreaLightHelper.prototype=Object.create(Object3D.prototype);RectAreaLightHelper.prototype.constructor=RectAreaLightHelper;RectAreaLightHelper.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose();};RectAreaLightHelper.prototype.update=function(){// calculate new dimensions of the helper
var hx=this.light.width*0.5;var hy=this.light.height*0.5;var position=this.line.geometry.attributes.position;var array=position.array;// update vertices
array[0]=hx;array[1]=-hy;array[2]=0;array[3]=hx;array[4]=hy;array[5]=0;array[6]=-hx;array[7]=hy;array[8]=0;array[9]=-hx;array[10]=-hy;array[11]=0;array[12]=hx;array[13]=-hy;array[14]=0;position.needsUpdate=true;if(this.color!==undefined){this.line.material.color.set(this.color);}else{this.line.material.color.copy(this.light.color);}};/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */function HemisphereLightHelper(light,size,color){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;var geometry=new OctahedronBufferGeometry(size);geometry.rotateY(Math.PI*0.5);this.material=new MeshBasicMaterial({wireframe:true,fog:false});if(this.color===undefined)this.material.vertexColors=VertexColors;var position=geometry.getAttribute('position');var colors=new Float32Array(position.count*3);geometry.addAttribute('color',new BufferAttribute(colors,3));this.add(new Mesh(geometry,this.material));this.update();}HemisphereLightHelper.prototype=Object.create(Object3D.prototype);HemisphereLightHelper.prototype.constructor=HemisphereLightHelper;HemisphereLightHelper.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose();};HemisphereLightHelper.prototype.update=function(){var vector=new Vector3();var color1=new Color();var color2=new Color();return function update(){var mesh=this.children[0];if(this.color!==undefined){this.material.color.set(this.color);}else{var colors=mesh.geometry.getAttribute('color');color1.copy(this.light.color);color2.copy(this.light.groundColor);for(var i=0,l=colors.count;i<l;i++){var color=i<l/2?color1:color2;colors.setXYZ(i,color.r,color.g,color.b);}colors.needsUpdate=true;}mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());};}();/**
	 * @author mrdoob / http://mrdoob.com/
	 */function GridHelper(size,divisions,color1,color2){size=size||10;divisions=divisions||10;color1=new Color(color1!==undefined?color1:0x444444);color2=new Color(color2!==undefined?color2:0x888888);var center=divisions/2;var step=size/divisions;var halfSize=size/2;var vertices=[],colors=[];for(var i=0,j=0,k=-halfSize;i<=divisions;i++,k+=step){vertices.push(-halfSize,0,k,halfSize,0,k);vertices.push(k,0,-halfSize,k,0,halfSize);var color=i===center?color1:color2;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;}var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}GridHelper.prototype=Object.create(LineSegments.prototype);GridHelper.prototype.constructor=GridHelper;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author Hectate / http://www.github.com/Hectate
	 */function PolarGridHelper(radius,radials,circles,divisions,color1,color2){radius=radius||10;radials=radials||16;circles=circles||8;divisions=divisions||64;color1=new Color(color1!==undefined?color1:0x444444);color2=new Color(color2!==undefined?color2:0x888888);var vertices=[];var colors=[];var x,z;var v,i,j,r,color;// create the radials
for(i=0;i<=radials;i++){v=i/radials*(Math.PI*2);x=Math.sin(v)*radius;z=Math.cos(v)*radius;vertices.push(0,0,0);vertices.push(x,0,z);color=i&1?color1:color2;colors.push(color.r,color.g,color.b);colors.push(color.r,color.g,color.b);}// create the circles
for(i=0;i<=circles;i++){color=i&1?color1:color2;r=radius-radius/circles*i;for(j=0;j<divisions;j++){// first vertex
v=j/divisions*(Math.PI*2);x=Math.sin(v)*r;z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);// second vertex
v=(j+1)/divisions*(Math.PI*2);x=Math.sin(v)*r;z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);}}var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}PolarGridHelper.prototype=Object.create(LineSegments.prototype);PolarGridHelper.prototype.constructor=PolarGridHelper;/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */function FaceNormalsHelper(object,size,hex,linewidth){// FaceNormalsHelper only supports THREE.Geometry
this.object=object;this.size=size!==undefined?size:1;var color=hex!==undefined?hex:0xffff00;var width=linewidth!==undefined?linewidth:1;//
var nNormals=0;var objGeometry=this.object.geometry;if(objGeometry&&objGeometry.isGeometry){nNormals=objGeometry.faces.length;}else{console.warn('THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.');}//
var geometry=new BufferGeometry();var positions=new Float32BufferAttribute(nNormals*2*3,3);geometry.addAttribute('position',positions);LineSegments.call(this,geometry,new LineBasicMaterial({color:color,linewidth:width}));//
this.matrixAutoUpdate=false;this.update();}FaceNormalsHelper.prototype=Object.create(LineSegments.prototype);FaceNormalsHelper.prototype.constructor=FaceNormalsHelper;FaceNormalsHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var normalMatrix=new Matrix3();return function update(){this.object.updateMatrixWorld(true);normalMatrix.getNormalMatrix(this.object.matrixWorld);var matrixWorld=this.object.matrixWorld;var position=this.geometry.attributes.position;//
var objGeometry=this.object.geometry;var vertices=objGeometry.vertices;var faces=objGeometry.faces;var idx=0;for(var i=0,l=faces.length;i<l;i++){var face=faces[i];var normal=face.normal;v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);position.setXYZ(idx,v1.x,v1.y,v1.z);idx=idx+1;position.setXYZ(idx,v2.x,v2.y,v2.z);idx=idx+1;}position.needsUpdate=true;};}();/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */function DirectionalLightHelper(light,size,color){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;if(size===undefined)size=1;var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute([-size,size,0,size,size,0,size,-size,0,-size,-size,0,-size,size,0],3));var material=new LineBasicMaterial({fog:false});this.lightPlane=new Line(geometry,material);this.add(this.lightPlane);geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,0,1],3));this.targetLine=new Line(geometry,material);this.add(this.targetLine);this.update();}DirectionalLightHelper.prototype=Object.create(Object3D.prototype);DirectionalLightHelper.prototype.constructor=DirectionalLightHelper;DirectionalLightHelper.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose();};DirectionalLightHelper.prototype.update=function(){var v1=new Vector3();var v2=new Vector3();var v3=new Vector3();return function update(){v1.setFromMatrixPosition(this.light.matrixWorld);v2.setFromMatrixPosition(this.light.target.matrixWorld);v3.subVectors(v2,v1);this.lightPlane.lookAt(v3);if(this.color!==undefined){this.lightPlane.material.color.set(this.color);this.targetLine.material.color.set(this.color);}else{this.lightPlane.material.color.copy(this.light.color);this.targetLine.material.color.copy(this.light.color);}this.targetLine.lookAt(v3);this.targetLine.scale.z=v3.length();};}();/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */function CameraHelper(camera){var geometry=new BufferGeometry();var material=new LineBasicMaterial({color:0xffffff,vertexColors:FaceColors});var vertices=[];var colors=[];var pointMap={};// colors
var colorFrustum=new Color(0xffaa00);var colorCone=new Color(0xff0000);var colorUp=new Color(0x00aaff);var colorTarget=new Color(0xffffff);var colorCross=new Color(0x333333);// near
addLine('n1','n2',colorFrustum);addLine('n2','n4',colorFrustum);addLine('n4','n3',colorFrustum);addLine('n3','n1',colorFrustum);// far
addLine('f1','f2',colorFrustum);addLine('f2','f4',colorFrustum);addLine('f4','f3',colorFrustum);addLine('f3','f1',colorFrustum);// sides
addLine('n1','f1',colorFrustum);addLine('n2','f2',colorFrustum);addLine('n3','f3',colorFrustum);addLine('n4','f4',colorFrustum);// cone
addLine('p','n1',colorCone);addLine('p','n2',colorCone);addLine('p','n3',colorCone);addLine('p','n4',colorCone);// up
addLine('u1','u2',colorUp);addLine('u2','u3',colorUp);addLine('u3','u1',colorUp);// target
addLine('c','t',colorTarget);addLine('p','c',colorCross);// cross
addLine('cn1','cn2',colorCross);addLine('cn3','cn4',colorCross);addLine('cf1','cf2',colorCross);addLine('cf3','cf4',colorCross);function addLine(a,b,color){addPoint(a,color);addPoint(b,color);}function addPoint(id,color){vertices.push(0,0,0);colors.push(color.r,color.g,color.b);if(pointMap[id]===undefined){pointMap[id]=[];}pointMap[id].push(vertices.length/3-1);}geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));LineSegments.call(this,geometry,material);this.camera=camera;if(this.camera.updateProjectionMatrix)this.camera.updateProjectionMatrix();this.matrix=camera.matrixWorld;this.matrixAutoUpdate=false;this.pointMap=pointMap;this.update();}CameraHelper.prototype=Object.create(LineSegments.prototype);CameraHelper.prototype.constructor=CameraHelper;CameraHelper.prototype.update=function(){var geometry,pointMap;var vector=new Vector3();var camera=new Camera();function setPoint(point,x,y,z){vector.set(x,y,z).unproject(camera);var points=pointMap[point];if(points!==undefined){var position=geometry.getAttribute('position');for(var i=0,l=points.length;i<l;i++){position.setXYZ(points[i],vector.x,vector.y,vector.z);}}}return function update(){geometry=this.geometry;pointMap=this.pointMap;var w=1,h=1;// we need just camera projection matrix
// world matrix must be identity
camera.projectionMatrix.copy(this.camera.projectionMatrix);// center / target
setPoint('c',0,0,-1);setPoint('t',0,0,1);// near
setPoint('n1',-w,-h,-1);setPoint('n2',w,-h,-1);setPoint('n3',-w,h,-1);setPoint('n4',w,h,-1);// far
setPoint('f1',-w,-h,1);setPoint('f2',w,-h,1);setPoint('f3',-w,h,1);setPoint('f4',w,h,1);// up
setPoint('u1',w*0.7,h*1.1,-1);setPoint('u2',-w*0.7,h*1.1,-1);setPoint('u3',0,h*2,-1);// cross
setPoint('cf1',-w,0,1);setPoint('cf2',w,0,1);setPoint('cf3',0,-h,1);setPoint('cf4',0,h,1);setPoint('cn1',-w,0,-1);setPoint('cn2',w,0,-1);setPoint('cn3',0,-h,-1);setPoint('cn4',0,h,-1);geometry.getAttribute('position').needsUpdate=true;};}();/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 */function BoxHelper(object,color){this.object=object;if(color===undefined)color=0xffff00;var indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var positions=new Float32Array(8*3);var geometry=new BufferGeometry();geometry.setIndex(new BufferAttribute(indices,1));geometry.addAttribute('position',new BufferAttribute(positions,3));LineSegments.call(this,geometry,new LineBasicMaterial({color:color}));this.matrixAutoUpdate=false;this.update();}BoxHelper.prototype=Object.create(LineSegments.prototype);BoxHelper.prototype.constructor=BoxHelper;BoxHelper.prototype.update=function(){var box=new Box3();return function update(object){if(object!==undefined){console.warn('THREE.BoxHelper: .update() has no longer arguments.');}if(this.object!==undefined){box.setFromObject(this.object);}if(box.isEmpty())return;var min=box.min;var max=box.max;/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/var position=this.geometry.attributes.position;var array=position.array;array[0]=max.x;array[1]=max.y;array[2]=max.z;array[3]=min.x;array[4]=max.y;array[5]=max.z;array[6]=min.x;array[7]=min.y;array[8]=max.z;array[9]=max.x;array[10]=min.y;array[11]=max.z;array[12]=max.x;array[13]=max.y;array[14]=min.z;array[15]=min.x;array[16]=max.y;array[17]=min.z;array[18]=min.x;array[19]=min.y;array[20]=min.z;array[21]=max.x;array[22]=min.y;array[23]=min.z;position.needsUpdate=true;this.geometry.computeBoundingSphere();};}();BoxHelper.prototype.setFromObject=function(object){this.object=object;this.update();return this;};/**
	 * @author WestLangley / http://github.com/WestLangley
	 */function Box3Helper(box,hex){this.type='Box3Helper';this.box=box;var color=hex!==undefined?hex:0xffff00;var indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var positions=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1];var geometry=new BufferGeometry();geometry.setIndex(new BufferAttribute(indices,1));geometry.addAttribute('position',new Float32BufferAttribute(positions,3));LineSegments.call(this,geometry,new LineBasicMaterial({color:color}));this.geometry.computeBoundingSphere();}Box3Helper.prototype=Object.create(LineSegments.prototype);Box3Helper.prototype.constructor=Box3Helper;Box3Helper.prototype.updateMatrixWorld=function(force){var box=this.box;if(box.isEmpty())return;box.getCenter(this.position);box.getSize(this.scale);this.scale.multiplyScalar(0.5);Object3D.prototype.updateMatrixWorld.call(this,force);};/**
	 * @author WestLangley / http://github.com/WestLangley
	 */function PlaneHelper(plane,size,hex){this.type='PlaneHelper';this.plane=plane;this.size=size===undefined?1:size;var color=hex!==undefined?hex:0xffff00;var positions=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0];var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(positions,3));geometry.computeBoundingSphere();Line.call(this,geometry,new LineBasicMaterial({color:color}));//
var positions2=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1];var geometry2=new BufferGeometry();geometry2.addAttribute('position',new Float32BufferAttribute(positions2,3));geometry2.computeBoundingSphere();this.add(new Mesh(geometry2,new MeshBasicMaterial({color:color,opacity:0.2,transparent:true,depthWrite:false})));}PlaneHelper.prototype=Object.create(Line.prototype);PlaneHelper.prototype.constructor=PlaneHelper;PlaneHelper.prototype.updateMatrixWorld=function(force){var scale=-this.plane.constant;if(Math.abs(scale)<1e-8)scale=1e-8;// sign does not matter
this.scale.set(0.5*this.size,0.5*this.size,scale);this.lookAt(this.plane.normal);Object3D.prototype.updateMatrixWorld.call(this,force);};/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */var lineGeometry;var coneGeometry;function ArrowHelper(dir,origin,length,color,headLength,headWidth){// dir is assumed to be normalized
Object3D.call(this);if(color===undefined)color=0xffff00;if(length===undefined)length=1;if(headLength===undefined)headLength=0.2*length;if(headWidth===undefined)headWidth=0.2*headLength;if(lineGeometry===undefined){lineGeometry=new BufferGeometry();lineGeometry.addAttribute('position',new Float32BufferAttribute([0,0,0,0,1,0],3));coneGeometry=new CylinderBufferGeometry(0,0.5,1,5,1);coneGeometry.translate(0,-0.5,0);}this.position.copy(origin);this.line=new Line(lineGeometry,new LineBasicMaterial({color:color}));this.line.matrixAutoUpdate=false;this.add(this.line);this.cone=new Mesh(coneGeometry,new MeshBasicMaterial({color:color}));this.cone.matrixAutoUpdate=false;this.add(this.cone);this.setDirection(dir);this.setLength(length,headLength,headWidth);}ArrowHelper.prototype=Object.create(Object3D.prototype);ArrowHelper.prototype.constructor=ArrowHelper;ArrowHelper.prototype.setDirection=function(){var axis=new Vector3();var radians;return function setDirection(dir){// dir is assumed to be normalized
if(dir.y>0.99999){this.quaternion.set(0,0,0,1);}else if(dir.y<-0.99999){this.quaternion.set(1,0,0,0);}else{axis.set(dir.z,0,-dir.x).normalize();radians=Math.acos(dir.y);this.quaternion.setFromAxisAngle(axis,radians);}};}();ArrowHelper.prototype.setLength=function(length,headLength,headWidth){if(headLength===undefined)headLength=0.2*length;if(headWidth===undefined)headWidth=0.2*headLength;this.line.scale.set(1,Math.max(0,length-headLength),1);this.line.updateMatrix();this.cone.scale.set(headWidth,headLength,headWidth);this.cone.position.y=length;this.cone.updateMatrix();};ArrowHelper.prototype.setColor=function(color){this.line.material.color.copy(color);this.cone.material.color.copy(color);};/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */function AxesHelper(size){size=size||1;var vertices=[0,0,0,size,0,0,0,0,0,0,size,0,0,0,0,0,0,size];var colors=[1,0,0,1,0.6,0,0,1,0,0.6,1,0,0,0,1,0,0.6,1];var geometry=new BufferGeometry();geometry.addAttribute('position',new Float32BufferAttribute(vertices,3));geometry.addAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:VertexColors});LineSegments.call(this,geometry,material);}AxesHelper.prototype=Object.create(LineSegments.prototype);AxesHelper.prototype.constructor=AxesHelper;/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 *//*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/function CubicPoly(){var c0=0,c1=0,c2=0,c3=0;/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */function init(x0,x1,t0,t1){c0=x0;c1=t0;c2=-3*x0+3*x1-2*t0-t1;c3=2*x0-2*x1+t0+t1;}return{initCatmullRom:function initCatmullRom(x0,x1,x2,x3,tension){init(x1,x2,tension*(x2-x0),tension*(x3-x1));},initNonuniformCatmullRom:function initNonuniformCatmullRom(x0,x1,x2,x3,dt0,dt1,dt2){// compute tangents when parameterized in [t1,t2]
var t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1;var t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;// rescale tangents for parametrization in [0,1]
t1*=dt1;t2*=dt1;init(x1,x2,t1,t2);},calc:function calc(t){var t2=t*t;var t3=t2*t;return c0+c1*t+c2*t2+c3*t3;}};}//
var tmp=new Vector3();var px=new CubicPoly();var py=new CubicPoly();var pz=new CubicPoly();function CatmullRomCurve3(points){Curve.call(this);if(points.length<2)console.warn('THREE.CatmullRomCurve3: Points array needs at least two entries.');this.points=points||[];this.closed=false;}CatmullRomCurve3.prototype=Object.create(Curve.prototype);CatmullRomCurve3.prototype.constructor=CatmullRomCurve3;CatmullRomCurve3.prototype.isCatmullRomCurve3=true;CatmullRomCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();var points=this.points;var l=points.length;var p=(l-(this.closed?0:1))*t;var intPoint=Math.floor(p);var weight=p-intPoint;if(this.closed){intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/points.length)+1)*points.length;}else if(weight===0&&intPoint===l-1){intPoint=l-2;weight=1;}var p0,p1,p2,p3;// 4 points
if(this.closed||intPoint>0){p0=points[(intPoint-1)%l];}else{// extrapolate first point
tmp.subVectors(points[0],points[1]).add(points[0]);p0=tmp;}p1=points[intPoint%l];p2=points[(intPoint+1)%l];if(this.closed||intPoint+2<l){p3=points[(intPoint+2)%l];}else{// extrapolate last point
tmp.subVectors(points[l-1],points[l-2]).add(points[l-1]);p3=tmp;}if(this.type===undefined||this.type==='centripetal'||this.type==='chordal'){// init Centripetal / Chordal Catmull-Rom
var pow=this.type==='chordal'?0.5:0.25;var dt0=Math.pow(p0.distanceToSquared(p1),pow);var dt1=Math.pow(p1.distanceToSquared(p2),pow);var dt2=Math.pow(p2.distanceToSquared(p3),pow);// safety check for repeated points
if(dt1<1e-4)dt1=1.0;if(dt0<1e-4)dt0=dt1;if(dt2<1e-4)dt2=dt1;px.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2);py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2);pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2);}else if(this.type==='catmullrom'){var tension=this.tension!==undefined?this.tension:0.5;px.initCatmullRom(p0.x,p1.x,p2.x,p3.x,tension);py.initCatmullRom(p0.y,p1.y,p2.y,p3.y,tension);pz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,tension);}point.set(px.calc(weight),py.calc(weight),pz.calc(weight));return point;};function CubicBezierCurve3(v0,v1,v2,v3){Curve.call(this);this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3;}CubicBezierCurve3.prototype=Object.create(Curve.prototype);CubicBezierCurve3.prototype.constructor=CubicBezierCurve3;CubicBezierCurve3.prototype.isCubicBezierCurve3=true;CubicBezierCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y),CubicBezier(t,v0.z,v1.z,v2.z,v3.z));return point;};function QuadraticBezierCurve3(v0,v1,v2){Curve.call(this);this.v0=v0;this.v1=v1;this.v2=v2;}QuadraticBezierCurve3.prototype=Object.create(Curve.prototype);QuadraticBezierCurve3.prototype.constructor=QuadraticBezierCurve3;QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3=true;QuadraticBezierCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();var v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y),QuadraticBezier(t,v0.z,v1.z,v2.z));return point;};function LineCurve3(v1,v2){Curve.call(this);this.v1=v1;this.v2=v2;}LineCurve3.prototype=Object.create(Curve.prototype);LineCurve3.prototype.constructor=LineCurve3;LineCurve3.prototype.isLineCurve3=true;LineCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();if(t===1){point.copy(this.v2);}else{point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;};// Line curve is linear, so we can overwrite default getPointAt
LineCurve3.prototype.getPointAt=function(u,optionalTarget){return this.getPoint(u,optionalTarget);};function ArcCurve(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){EllipseCurve.call(this,aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);}ArcCurve.prototype=Object.create(EllipseCurve.prototype);ArcCurve.prototype.constructor=ArcCurve;ArcCurve.prototype.isArcCurve=true;/**
	 * @author alteredq / http://alteredqualia.com/
	 */var SceneUtils={createMultiMaterialObject:function createMultiMaterialObject(geometry,materials){var group=new Group();for(var i=0,l=materials.length;i<l;i++){group.add(new Mesh(geometry,materials[i]));}return group;},detach:function detach(child,parent,scene){child.applyMatrix(parent.matrixWorld);parent.remove(child);scene.add(child);},attach:function attach(child,scene,parent){child.applyMatrix(new Matrix4().getInverse(parent.matrixWorld));scene.remove(child);parent.add(child);}};/**
	 * @author mrdoob / http://mrdoob.com/
	 */function Face4(a,b,c,d,normal,color,materialIndex){console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');return new Face3(a,b,c,normal,color,materialIndex);}var LineStrip=0;var LinePieces=1;function MeshFaceMaterial(materials){console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');return materials;}function MultiMaterial(materials){if(materials===undefined)materials=[];console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');materials.isMultiMaterial=true;materials.materials=materials;materials.clone=function(){return materials.slice();};return materials;}function PointCloud(geometry,material){console.warn('THREE.PointCloud has been renamed to THREE.Points.');return new Points(geometry,material);}function Particle(material){console.warn('THREE.Particle has been renamed to THREE.Sprite.');return new Sprite(material);}function ParticleSystem(geometry,material){console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');return new Points(geometry,material);}function PointCloudMaterial(parameters){console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function ParticleBasicMaterial(parameters){console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function ParticleSystemMaterial(parameters){console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function Vertex(x,y,z){console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');return new Vector3(x,y,z);}//
function DynamicBufferAttribute(array,itemSize){console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.');return new BufferAttribute(array,itemSize).setDynamic(true);}function Int8Attribute(array,itemSize){console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');return new Int8BufferAttribute(array,itemSize);}function Uint8Attribute(array,itemSize){console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');return new Uint8BufferAttribute(array,itemSize);}function Uint8ClampedAttribute(array,itemSize){console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');return new Uint8ClampedBufferAttribute(array,itemSize);}function Int16Attribute(array,itemSize){console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');return new Int16BufferAttribute(array,itemSize);}function Uint16Attribute(array,itemSize){console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');return new Uint16BufferAttribute(array,itemSize);}function Int32Attribute(array,itemSize){console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');return new Int32BufferAttribute(array,itemSize);}function Uint32Attribute(array,itemSize){console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');return new Uint32BufferAttribute(array,itemSize);}function Float32Attribute(array,itemSize){console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');return new Float32BufferAttribute(array,itemSize);}function Float64Attribute(array,itemSize){console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');return new Float64BufferAttribute(array,itemSize);}//
Curve.create=function(construct,getPoint){console.log('THREE.Curve.create() has been deprecated');construct.prototype=Object.create(Curve.prototype);construct.prototype.constructor=construct;construct.prototype.getPoint=getPoint;return construct;};//
Object.assign(CurvePath.prototype,{createPointsGeometry:function createPointsGeometry(divisions){console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');// generate geometry from path points (for Line or Points objects)
var pts=this.getPoints(divisions);return this.createGeometry(pts);},createSpacedPointsGeometry:function createSpacedPointsGeometry(divisions){console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');// generate geometry from equidistant sampling along the path
var pts=this.getSpacedPoints(divisions);return this.createGeometry(pts);},createGeometry:function createGeometry(points){console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');var geometry=new Geometry();for(var i=0,l=points.length;i<l;i++){var point=points[i];geometry.vertices.push(new Vector3(point.x,point.y,point.z||0));}return geometry;}});//
function ClosedSplineCurve3(points){console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';this.closed=true;}ClosedSplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype);//
function SplineCurve3(points){console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';}SplineCurve3.prototype=Object.create(CatmullRomCurve3.prototype);//
function Spline(points){console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';}Spline.prototype=Object.create(CatmullRomCurve3.prototype);Object.assign(Spline.prototype,{initFromArray:function initFromArray()/* a */{console.error('THREE.Spline: .initFromArray() has been removed.');},getControlPointsArray:function getControlPointsArray()/* optionalTarget */{console.error('THREE.Spline: .getControlPointsArray() has been removed.');},reparametrizeByArcLength:function reparametrizeByArcLength()/* samplingCoef */{console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');}});//
function AxisHelper(size){console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');return new AxesHelper(size);}function BoundingBoxHelper(object,color){console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');return new BoxHelper(object,color);}function EdgesHelper(object,hex){console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');return new LineSegments(new EdgesGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));}GridHelper.prototype.setColors=function(){console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');};SkeletonHelper.prototype.update=function(){console.error('THREE.SkeletonHelper: update() no longer needs to be called.');};function WireframeHelper(object,hex){console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');return new LineSegments(new WireframeGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));}//
function XHRLoader(manager){console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');return new FileLoader(manager);}function BinaryTextureLoader(manager){console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');return new DataTextureLoader(manager);}//
Object.assign(Box2.prototype,{center:function center(optionalTarget){console.warn('THREE.Box2: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);},empty:function empty(){console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');return this.isEmpty();},isIntersectionBox:function isIntersectionBox(box){console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},size:function size(optionalTarget){console.warn('THREE.Box2: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);}});Object.assign(Box3.prototype,{center:function center(optionalTarget){console.warn('THREE.Box3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);},empty:function empty(){console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');return this.isEmpty();},isIntersectionBox:function isIntersectionBox(box){console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},isIntersectionSphere:function isIntersectionSphere(sphere){console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);},size:function size(optionalTarget){console.warn('THREE.Box3: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);}});Line3.prototype.center=function(optionalTarget){console.warn('THREE.Line3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};Object.assign(_Math,{random16:function random16(){console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');return Math.random();},nearestPowerOfTwo:function nearestPowerOfTwo(value){console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');return _Math.floorPowerOfTwo(value);},nextPowerOfTwo:function nextPowerOfTwo(value){console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');return _Math.ceilPowerOfTwo(value);}});Object.assign(Matrix3.prototype,{flattenToArrayOffset:function flattenToArrayOffset(array,offset){console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(array,offset);},multiplyVector3:function multiplyVector3(vector){console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');return vector.applyMatrix3(this);},multiplyVector3Array:function multiplyVector3Array()/* a */{console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');},applyToBuffer:function applyToBuffer(buffer/*, offset, length */){console.warn('THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');return this.applyToBufferAttribute(buffer);},applyToVector3Array:function applyToVector3Array()/* array, offset, length */{console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');}});Object.assign(Matrix4.prototype,{extractPosition:function extractPosition(m){console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');return this.copyPosition(m);},flattenToArrayOffset:function flattenToArrayOffset(array,offset){console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(array,offset);},getPosition:function(){var v1;return function getPosition(){if(v1===undefined)v1=new Vector3();console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');return v1.setFromMatrixColumn(this,3);};}(),setRotationFromQuaternion:function setRotationFromQuaternion(q){console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');return this.makeRotationFromQuaternion(q);},multiplyToArray:function multiplyToArray(){console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');},multiplyVector3:function multiplyVector3(vector){console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},multiplyVector4:function multiplyVector4(vector){console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},multiplyVector3Array:function multiplyVector3Array()/* a */{console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');},rotateAxis:function rotateAxis(v){console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');v.transformDirection(this);},crossVector:function crossVector(vector){console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},translate:function translate(){console.error('THREE.Matrix4: .translate() has been removed.');},rotateX:function rotateX(){console.error('THREE.Matrix4: .rotateX() has been removed.');},rotateY:function rotateY(){console.error('THREE.Matrix4: .rotateY() has been removed.');},rotateZ:function rotateZ(){console.error('THREE.Matrix4: .rotateZ() has been removed.');},rotateByAxis:function rotateByAxis(){console.error('THREE.Matrix4: .rotateByAxis() has been removed.');},applyToBuffer:function applyToBuffer(buffer/*, offset, length */){console.warn('THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.');return this.applyToBufferAttribute(buffer);},applyToVector3Array:function applyToVector3Array()/* array, offset, length */{console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');},makeFrustum:function makeFrustum(left,right,bottom,top,near,far){console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');return this.makePerspective(left,right,top,bottom,near,far);}});Plane.prototype.isIntersectionLine=function(line){console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');return this.intersectsLine(line);};Quaternion.prototype.multiplyVector3=function(vector){console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');return vector.applyQuaternion(this);};Object.assign(Ray.prototype,{isIntersectionBox:function isIntersectionBox(box){console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},isIntersectionPlane:function isIntersectionPlane(plane){console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');return this.intersectsPlane(plane);},isIntersectionSphere:function isIntersectionSphere(sphere){console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);}});Object.assign(Shape.prototype,{extrude:function extrude(options){console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');return new ExtrudeGeometry(this,options);},makeGeometry:function makeGeometry(options){console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');return new ShapeGeometry(this,options);}});Object.assign(Vector2.prototype,{fromAttribute:function fromAttribute(attribute,index,offset){console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);},distanceToManhattan:function distanceToManhattan(v){console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);},lengthManhattan:function lengthManhattan(){console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();}});Object.assign(Vector3.prototype,{setEulerFromRotationMatrix:function setEulerFromRotationMatrix(){console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');},setEulerFromQuaternion:function setEulerFromQuaternion(){console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');},getPositionFromMatrix:function getPositionFromMatrix(m){console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');return this.setFromMatrixPosition(m);},getScaleFromMatrix:function getScaleFromMatrix(m){console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');return this.setFromMatrixScale(m);},getColumnFromMatrix:function getColumnFromMatrix(index,matrix){console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');return this.setFromMatrixColumn(matrix,index);},applyProjection:function applyProjection(m){console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');return this.applyMatrix4(m);},fromAttribute:function fromAttribute(attribute,index,offset){console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);},distanceToManhattan:function distanceToManhattan(v){console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);},lengthManhattan:function lengthManhattan(){console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();}});Object.assign(Vector4.prototype,{fromAttribute:function fromAttribute(attribute,index,offset){console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);},lengthManhattan:function lengthManhattan(){console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();}});//
Geometry.prototype.computeTangents=function(){console.warn('THREE.Geometry: .computeTangents() has been removed.');};Object.assign(Object3D.prototype,{getChildByName:function getChildByName(name){console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');return this.getObjectByName(name);},renderDepth:function renderDepth(){console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');},translate:function translate(distance,axis){console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');return this.translateOnAxis(axis,distance);}});Object.defineProperties(Object3D.prototype,{eulerOrder:{get:function get(){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');return this.rotation.order;},set:function set(value){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');this.rotation.order=value;}},useQuaternion:{get:function get(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');},set:function set(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');}}});Object.defineProperties(LOD.prototype,{objects:{get:function get(){console.warn('THREE.LOD: .objects has been renamed to .levels.');return this.levels;}}});Object.defineProperty(Skeleton.prototype,'useVertexTexture',{get:function get(){console.warn('THREE.Skeleton: useVertexTexture has been removed.');},set:function set(){console.warn('THREE.Skeleton: useVertexTexture has been removed.');}});Object.defineProperty(Curve.prototype,'__arcLengthDivisions',{get:function get(){console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');return this.arcLengthDivisions;},set:function set(value){console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');this.arcLengthDivisions=value;}});//
PerspectiveCamera.prototype.setLens=function(focalLength,filmGauge){console.warn("THREE.PerspectiveCamera.setLens is deprecated. "+"Use .setFocalLength and .filmGauge for a photographic setup.");if(filmGauge!==undefined)this.filmGauge=filmGauge;this.setFocalLength(focalLength);};//
Object.defineProperties(Light.prototype,{onlyShadow:{set:function set(){console.warn('THREE.Light: .onlyShadow has been removed.');}},shadowCameraFov:{set:function set(value){console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');this.shadow.camera.fov=value;}},shadowCameraLeft:{set:function set(value){console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');this.shadow.camera.left=value;}},shadowCameraRight:{set:function set(value){console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');this.shadow.camera.right=value;}},shadowCameraTop:{set:function set(value){console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');this.shadow.camera.top=value;}},shadowCameraBottom:{set:function set(value){console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');this.shadow.camera.bottom=value;}},shadowCameraNear:{set:function set(value){console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');this.shadow.camera.near=value;}},shadowCameraFar:{set:function set(value){console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');this.shadow.camera.far=value;}},shadowCameraVisible:{set:function set(){console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');}},shadowBias:{set:function set(value){console.warn('THREE.Light: .shadowBias is now .shadow.bias.');this.shadow.bias=value;}},shadowDarkness:{set:function set(){console.warn('THREE.Light: .shadowDarkness has been removed.');}},shadowMapWidth:{set:function set(value){console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');this.shadow.mapSize.width=value;}},shadowMapHeight:{set:function set(value){console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');this.shadow.mapSize.height=value;}}});//
Object.defineProperties(BufferAttribute.prototype,{length:{get:function get(){console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');return this.array.length;}}});Object.assign(BufferGeometry.prototype,{addIndex:function addIndex(index){console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');this.setIndex(index);},addDrawCall:function addDrawCall(start,count,indexOffset){if(indexOffset!==undefined){console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');}console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');this.addGroup(start,count);},clearDrawCalls:function clearDrawCalls(){console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');this.clearGroups();},computeTangents:function computeTangents(){console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');},computeOffsets:function computeOffsets(){console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');}});Object.defineProperties(BufferGeometry.prototype,{drawcalls:{get:function get(){console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');return this.groups;}},offsets:{get:function get(){console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');return this.groups;}}});//
Object.defineProperties(Uniform.prototype,{dynamic:{set:function set(){console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');}},onUpdate:{value:function value(){console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');return this;}}});//
Object.defineProperties(Material.prototype,{wrapAround:{get:function get(){console.warn('THREE.Material: .wrapAround has been removed.');},set:function set(){console.warn('THREE.Material: .wrapAround has been removed.');}},wrapRGB:{get:function get(){console.warn('THREE.Material: .wrapRGB has been removed.');return new Color();}},shading:{get:function get(){console.error('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');},set:function set(value){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=value===FlatShading;}}});Object.defineProperties(MeshPhongMaterial.prototype,{metal:{get:function get(){console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');return false;},set:function set(){console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');}}});Object.defineProperties(ShaderMaterial.prototype,{derivatives:{get:function get(){console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');return this.extensions.derivatives;},set:function set(value){console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');this.extensions.derivatives=value;}}});//
Object.assign(WebGLRenderer.prototype,{getCurrentRenderTarget:function getCurrentRenderTarget(){console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');return this.getRenderTarget();},getMaxAnisotropy:function getMaxAnisotropy(){console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');return this.capabilities.getMaxAnisotropy();},getPrecision:function getPrecision(){console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');return this.capabilities.precision;},resetGLState:function resetGLState(){console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');return this.state.reset();},supportsFloatTextures:function supportsFloatTextures(){console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');return this.extensions.get('OES_texture_float');},supportsHalfFloatTextures:function supportsHalfFloatTextures(){console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');return this.extensions.get('OES_texture_half_float');},supportsStandardDerivatives:function supportsStandardDerivatives(){console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');return this.extensions.get('OES_standard_derivatives');},supportsCompressedTextureS3TC:function supportsCompressedTextureS3TC(){console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');return this.extensions.get('WEBGL_compressed_texture_s3tc');},supportsCompressedTexturePVRTC:function supportsCompressedTexturePVRTC(){console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');return this.extensions.get('WEBGL_compressed_texture_pvrtc');},supportsBlendMinMax:function supportsBlendMinMax(){console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');return this.extensions.get('EXT_blend_minmax');},supportsVertexTextures:function supportsVertexTextures(){console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');return this.capabilities.vertexTextures;},supportsInstancedArrays:function supportsInstancedArrays(){console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');return this.extensions.get('ANGLE_instanced_arrays');},enableScissorTest:function enableScissorTest(boolean){console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');this.setScissorTest(boolean);},initMaterial:function initMaterial(){console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');},addPrePlugin:function addPrePlugin(){console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');},addPostPlugin:function addPostPlugin(){console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');},updateShadowMap:function updateShadowMap(){console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');}});Object.defineProperties(WebGLRenderer.prototype,{shadowMapEnabled:{get:function get(){return this.shadowMap.enabled;},set:function set(value){console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');this.shadowMap.enabled=value;}},shadowMapType:{get:function get(){return this.shadowMap.type;},set:function set(value){console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');this.shadowMap.type=value;}},shadowMapCullFace:{get:function get(){return this.shadowMap.cullFace;},set:function set(value){console.warn('THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.');this.shadowMap.cullFace=value;}}});Object.defineProperties(WebGLShadowMap.prototype,{cullFace:{get:function get(){return this.renderReverseSided?CullFaceFront:CullFaceBack;},set:function set(cullFace){var value=cullFace!==CullFaceBack;console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to "+value+".");this.renderReverseSided=value;}}});//
Object.defineProperties(WebGLRenderTarget.prototype,{wrapS:{get:function get(){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');return this.texture.wrapS;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');this.texture.wrapS=value;}},wrapT:{get:function get(){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');return this.texture.wrapT;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');this.texture.wrapT=value;}},magFilter:{get:function get(){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');return this.texture.magFilter;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');this.texture.magFilter=value;}},minFilter:{get:function get(){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');return this.texture.minFilter;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');this.texture.minFilter=value;}},anisotropy:{get:function get(){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');return this.texture.anisotropy;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');this.texture.anisotropy=value;}},offset:{get:function get(){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');return this.texture.offset;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');this.texture.offset=value;}},repeat:{get:function get(){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');return this.texture.repeat;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');this.texture.repeat=value;}},format:{get:function get(){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');return this.texture.format;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');this.texture.format=value;}},type:{get:function get(){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');return this.texture.type;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');this.texture.type=value;}},generateMipmaps:{get:function get(){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');return this.texture.generateMipmaps;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');this.texture.generateMipmaps=value;}}});//
Audio.prototype.load=function(file){console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');var scope=this;var audioLoader=new AudioLoader();audioLoader.load(file,function(buffer){scope.setBuffer(buffer);});return this;};AudioAnalyser.prototype.getData=function(){console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');return this.getFrequencyData();};//
var GeometryUtils={merge:function merge(geometry1,geometry2,materialIndexOffset){console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');var matrix;if(geometry2.isMesh){geometry2.matrixAutoUpdate&&geometry2.updateMatrix();matrix=geometry2.matrix;geometry2=geometry2.geometry;}geometry1.merge(geometry2,matrix,materialIndexOffset);},center:function center(geometry){console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');return geometry.center();}};var ImageUtils={crossOrigin:undefined,loadTexture:function loadTexture(url,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');var loader=new TextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(url,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;},loadTextureCube:function loadTextureCube(urls,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');var loader=new CubeTextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(urls,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;},loadCompressedTexture:function loadCompressedTexture(){console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');},loadCompressedTextureCube:function loadCompressedTextureCube(){console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');}};//
function Projector(){console.error('THREE.Projector has been moved to /examples/js/renderers/Projector.js.');this.projectVector=function(vector,camera){console.warn('THREE.Projector: .projectVector() is now vector.project().');vector.project(camera);};this.unprojectVector=function(vector,camera){console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().');vector.unproject(camera);};this.pickingRay=function(){console.error('THREE.Projector: .pickingRay() is now raycaster.setFromCamera().');};}//
function CanvasRenderer(){console.error('THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js');this.domElement=document.createElement('canvas');this.clear=function(){};this.render=function(){};this.setClearColor=function(){};this.setSize=function(){};}exports.WebGLRenderTargetCube=WebGLRenderTargetCube;exports.WebGLRenderTarget=WebGLRenderTarget;exports.WebGLRenderer=WebGLRenderer;exports.ShaderLib=ShaderLib;exports.UniformsLib=UniformsLib;exports.UniformsUtils=UniformsUtils;exports.ShaderChunk=ShaderChunk;exports.FogExp2=FogExp2;exports.Fog=Fog;exports.Scene=Scene;exports.LensFlare=LensFlare;exports.Sprite=Sprite;exports.LOD=LOD;exports.SkinnedMesh=SkinnedMesh;exports.Skeleton=Skeleton;exports.Bone=Bone;exports.Mesh=Mesh;exports.LineSegments=LineSegments;exports.LineLoop=LineLoop;exports.Line=Line;exports.Points=Points;exports.Group=Group;exports.VideoTexture=VideoTexture;exports.DataTexture=DataTexture;exports.CompressedTexture=CompressedTexture;exports.CubeTexture=CubeTexture;exports.CanvasTexture=CanvasTexture;exports.DepthTexture=DepthTexture;exports.Texture=Texture;exports.CompressedTextureLoader=CompressedTextureLoader;exports.DataTextureLoader=DataTextureLoader;exports.CubeTextureLoader=CubeTextureLoader;exports.TextureLoader=TextureLoader;exports.ObjectLoader=ObjectLoader;exports.MaterialLoader=MaterialLoader;exports.BufferGeometryLoader=BufferGeometryLoader;exports.DefaultLoadingManager=DefaultLoadingManager;exports.LoadingManager=LoadingManager;exports.JSONLoader=JSONLoader;exports.ImageLoader=ImageLoader;exports.FontLoader=FontLoader;exports.FileLoader=FileLoader;exports.Loader=Loader;exports.Cache=Cache;exports.AudioLoader=AudioLoader;exports.SpotLightShadow=SpotLightShadow;exports.SpotLight=SpotLight;exports.PointLight=PointLight;exports.RectAreaLight=RectAreaLight;exports.HemisphereLight=HemisphereLight;exports.DirectionalLightShadow=DirectionalLightShadow;exports.DirectionalLight=DirectionalLight;exports.AmbientLight=AmbientLight;exports.LightShadow=LightShadow;exports.Light=Light;exports.StereoCamera=StereoCamera;exports.PerspectiveCamera=PerspectiveCamera;exports.OrthographicCamera=OrthographicCamera;exports.ArrayCamera=ArrayCamera;exports.Camera=Camera;exports.AudioListener=AudioListener;exports.PositionalAudio=PositionalAudio;exports.AudioContext=AudioContext;exports.AudioAnalyser=AudioAnalyser;exports.Audio=Audio;exports.VectorKeyframeTrack=VectorKeyframeTrack;exports.StringKeyframeTrack=StringKeyframeTrack;exports.QuaternionKeyframeTrack=QuaternionKeyframeTrack;exports.NumberKeyframeTrack=NumberKeyframeTrack;exports.ColorKeyframeTrack=ColorKeyframeTrack;exports.BooleanKeyframeTrack=BooleanKeyframeTrack;exports.PropertyMixer=PropertyMixer;exports.PropertyBinding=PropertyBinding;exports.KeyframeTrack=KeyframeTrack;exports.AnimationUtils=AnimationUtils;exports.AnimationObjectGroup=AnimationObjectGroup;exports.AnimationMixer=AnimationMixer;exports.AnimationClip=AnimationClip;exports.Uniform=Uniform;exports.InstancedBufferGeometry=InstancedBufferGeometry;exports.BufferGeometry=BufferGeometry;exports.Geometry=Geometry;exports.InterleavedBufferAttribute=InterleavedBufferAttribute;exports.InstancedInterleavedBuffer=InstancedInterleavedBuffer;exports.InterleavedBuffer=InterleavedBuffer;exports.InstancedBufferAttribute=InstancedBufferAttribute;exports.Face3=Face3;exports.Object3D=Object3D;exports.Raycaster=Raycaster;exports.Layers=Layers;exports.EventDispatcher=EventDispatcher;exports.Clock=Clock;exports.QuaternionLinearInterpolant=QuaternionLinearInterpolant;exports.LinearInterpolant=LinearInterpolant;exports.DiscreteInterpolant=DiscreteInterpolant;exports.CubicInterpolant=CubicInterpolant;exports.Interpolant=Interpolant;exports.Triangle=Triangle;exports.Math=_Math;exports.Spherical=Spherical;exports.Cylindrical=Cylindrical;exports.Plane=Plane;exports.Frustum=Frustum;exports.Sphere=Sphere;exports.Ray=Ray;exports.Matrix4=Matrix4;exports.Matrix3=Matrix3;exports.Box3=Box3;exports.Box2=Box2;exports.Line3=Line3;exports.Euler=Euler;exports.Vector4=Vector4;exports.Vector3=Vector3;exports.Vector2=Vector2;exports.Quaternion=Quaternion;exports.Color=Color;exports.ImmediateRenderObject=ImmediateRenderObject;exports.VertexNormalsHelper=VertexNormalsHelper;exports.SpotLightHelper=SpotLightHelper;exports.SkeletonHelper=SkeletonHelper;exports.PointLightHelper=PointLightHelper;exports.RectAreaLightHelper=RectAreaLightHelper;exports.HemisphereLightHelper=HemisphereLightHelper;exports.GridHelper=GridHelper;exports.PolarGridHelper=PolarGridHelper;exports.FaceNormalsHelper=FaceNormalsHelper;exports.DirectionalLightHelper=DirectionalLightHelper;exports.CameraHelper=CameraHelper;exports.BoxHelper=BoxHelper;exports.Box3Helper=Box3Helper;exports.PlaneHelper=PlaneHelper;exports.ArrowHelper=ArrowHelper;exports.AxesHelper=AxesHelper;exports.CatmullRomCurve3=CatmullRomCurve3;exports.CubicBezierCurve3=CubicBezierCurve3;exports.QuadraticBezierCurve3=QuadraticBezierCurve3;exports.LineCurve3=LineCurve3;exports.ArcCurve=ArcCurve;exports.EllipseCurve=EllipseCurve;exports.SplineCurve=SplineCurve;exports.CubicBezierCurve=CubicBezierCurve;exports.QuadraticBezierCurve=QuadraticBezierCurve;exports.LineCurve=LineCurve;exports.Shape=Shape;exports.Path=Path;exports.ShapePath=ShapePath;exports.Font=Font;exports.CurvePath=CurvePath;exports.Curve=Curve;exports.ShapeUtils=ShapeUtils;exports.SceneUtils=SceneUtils;exports.WebGLUtils=WebGLUtils;exports.ParametricGeometry=ParametricGeometry;exports.ParametricBufferGeometry=ParametricBufferGeometry;exports.TetrahedronGeometry=TetrahedronGeometry;exports.TetrahedronBufferGeometry=TetrahedronBufferGeometry;exports.OctahedronGeometry=OctahedronGeometry;exports.OctahedronBufferGeometry=OctahedronBufferGeometry;exports.IcosahedronGeometry=IcosahedronGeometry;exports.IcosahedronBufferGeometry=IcosahedronBufferGeometry;exports.PolyhedronGeometry=PolyhedronGeometry;exports.PolyhedronBufferGeometry=PolyhedronBufferGeometry;exports.TextGeometry=TextGeometry;exports.TextBufferGeometry=TextBufferGeometry;exports.SphereGeometry=SphereGeometry;exports.SphereBufferGeometry=SphereBufferGeometry;exports.RingGeometry=RingGeometry;exports.RingBufferGeometry=RingBufferGeometry;exports.PlaneGeometry=PlaneGeometry;exports.PlaneBufferGeometry=PlaneBufferGeometry;exports.ExtrudeGeometry=ExtrudeGeometry;exports.ExtrudeBufferGeometry=ExtrudeBufferGeometry;exports.ShapeGeometry=ShapeGeometry;exports.ShapeBufferGeometry=ShapeBufferGeometry;exports.ConeGeometry=ConeGeometry;exports.ConeBufferGeometry=ConeBufferGeometry;exports.CylinderGeometry=CylinderGeometry;exports.CylinderBufferGeometry=CylinderBufferGeometry;exports.CircleGeometry=CircleGeometry;exports.CircleBufferGeometry=CircleBufferGeometry;exports.BoxGeometry=BoxGeometry;exports.BoxBufferGeometry=BoxBufferGeometry;exports.ShadowMaterial=ShadowMaterial;exports.SpriteMaterial=SpriteMaterial;exports.MeshPhongMaterial=MeshPhongMaterial;exports.MeshLambertMaterial=MeshLambertMaterial;exports.MeshBasicMaterial=MeshBasicMaterial;exports.Material=Material;exports.Float64BufferAttribute=Float64BufferAttribute;exports.Float32BufferAttribute=Float32BufferAttribute;exports.Uint32BufferAttribute=Uint32BufferAttribute;exports.Int32BufferAttribute=Int32BufferAttribute;exports.Uint16BufferAttribute=Uint16BufferAttribute;exports.Int16BufferAttribute=Int16BufferAttribute;exports.Uint8ClampedBufferAttribute=Uint8ClampedBufferAttribute;exports.Uint8BufferAttribute=Uint8BufferAttribute;exports.Int8BufferAttribute=Int8BufferAttribute;exports.BufferAttribute=BufferAttribute;exports.REVISION=REVISION;exports.MOUSE=MOUSE;exports.CullFaceNone=CullFaceNone;exports.CullFaceBack=CullFaceBack;exports.CullFaceFront=CullFaceFront;exports.CullFaceFrontBack=CullFaceFrontBack;exports.FrontFaceDirectionCW=FrontFaceDirectionCW;exports.FrontFaceDirectionCCW=FrontFaceDirectionCCW;exports.BasicShadowMap=BasicShadowMap;exports.PCFShadowMap=PCFShadowMap;exports.PCFSoftShadowMap=PCFSoftShadowMap;exports.FrontSide=FrontSide;exports.BackSide=BackSide;exports.DoubleSide=DoubleSide;exports.FlatShading=FlatShading;exports.SmoothShading=SmoothShading;exports.NoColors=NoColors;exports.FaceColors=FaceColors;exports.VertexColors=VertexColors;exports.NoBlending=NoBlending;exports.NormalBlending=NormalBlending;exports.AdditiveBlending=AdditiveBlending;exports.SubtractiveBlending=SubtractiveBlending;exports.MultiplyBlending=MultiplyBlending;exports.CustomBlending=CustomBlending;exports.AddEquation=AddEquation;exports.SubtractEquation=SubtractEquation;exports.ReverseSubtractEquation=ReverseSubtractEquation;exports.MinEquation=MinEquation;exports.MaxEquation=MaxEquation;exports.ZeroFactor=ZeroFactor;exports.OneFactor=OneFactor;exports.SrcColorFactor=SrcColorFactor;exports.OneMinusSrcColorFactor=OneMinusSrcColorFactor;exports.SrcAlphaFactor=SrcAlphaFactor;exports.OneMinusSrcAlphaFactor=OneMinusSrcAlphaFactor;exports.DstAlphaFactor=DstAlphaFactor;exports.OneMinusDstAlphaFactor=OneMinusDstAlphaFactor;exports.DstColorFactor=DstColorFactor;exports.OneMinusDstColorFactor=OneMinusDstColorFactor;exports.SrcAlphaSaturateFactor=SrcAlphaSaturateFactor;exports.NeverDepth=NeverDepth;exports.AlwaysDepth=AlwaysDepth;exports.LessDepth=LessDepth;exports.LessEqualDepth=LessEqualDepth;exports.EqualDepth=EqualDepth;exports.GreaterEqualDepth=GreaterEqualDepth;exports.GreaterDepth=GreaterDepth;exports.NotEqualDepth=NotEqualDepth;exports.MultiplyOperation=MultiplyOperation;exports.MixOperation=MixOperation;exports.AddOperation=AddOperation;exports.NoToneMapping=NoToneMapping;exports.LinearToneMapping=LinearToneMapping;exports.ReinhardToneMapping=ReinhardToneMapping;exports.Uncharted2ToneMapping=Uncharted2ToneMapping;exports.CineonToneMapping=CineonToneMapping;exports.UVMapping=UVMapping;exports.CubeReflectionMapping=CubeReflectionMapping;exports.CubeRefractionMapping=CubeRefractionMapping;exports.EquirectangularReflectionMapping=EquirectangularReflectionMapping;exports.EquirectangularRefractionMapping=EquirectangularRefractionMapping;exports.SphericalReflectionMapping=SphericalReflectionMapping;exports.CubeUVReflectionMapping=CubeUVReflectionMapping;exports.CubeUVRefractionMapping=CubeUVRefractionMapping;exports.RepeatWrapping=RepeatWrapping;exports.ClampToEdgeWrapping=ClampToEdgeWrapping;exports.MirroredRepeatWrapping=MirroredRepeatWrapping;exports.NearestFilter=NearestFilter;exports.NearestMipMapNearestFilter=NearestMipMapNearestFilter;exports.NearestMipMapLinearFilter=NearestMipMapLinearFilter;exports.LinearFilter=LinearFilter;exports.LinearMipMapNearestFilter=LinearMipMapNearestFilter;exports.LinearMipMapLinearFilter=LinearMipMapLinearFilter;exports.UnsignedByteType=UnsignedByteType;exports.ByteType=ByteType;exports.ShortType=ShortType;exports.UnsignedShortType=UnsignedShortType;exports.IntType=IntType;exports.UnsignedIntType=UnsignedIntType;exports.FloatType=FloatType;exports.HalfFloatType=HalfFloatType;exports.UnsignedShort4444Type=UnsignedShort4444Type;exports.UnsignedShort5551Type=UnsignedShort5551Type;exports.UnsignedShort565Type=UnsignedShort565Type;exports.UnsignedInt248Type=UnsignedInt248Type;exports.AlphaFormat=AlphaFormat;exports.RGBFormat=RGBFormat;exports.RGBAFormat=RGBAFormat;exports.LuminanceFormat=LuminanceFormat;exports.LuminanceAlphaFormat=LuminanceAlphaFormat;exports.RGBEFormat=RGBEFormat;exports.DepthFormat=DepthFormat;exports.DepthStencilFormat=DepthStencilFormat;exports.RGB_S3TC_DXT1_Format=RGB_S3TC_DXT1_Format;exports.RGBA_S3TC_DXT1_Format=RGBA_S3TC_DXT1_Format;exports.RGBA_S3TC_DXT3_Format=RGBA_S3TC_DXT3_Format;exports.RGBA_S3TC_DXT5_Format=RGBA_S3TC_DXT5_Format;exports.RGB_PVRTC_4BPPV1_Format=RGB_PVRTC_4BPPV1_Format;exports.RGB_PVRTC_2BPPV1_Format=RGB_PVRTC_2BPPV1_Format;exports.RGBA_PVRTC_4BPPV1_Format=RGBA_PVRTC_4BPPV1_Format;exports.RGBA_PVRTC_2BPPV1_Format=RGBA_PVRTC_2BPPV1_Format;exports.RGB_ETC1_Format=RGB_ETC1_Format;exports.LoopOnce=LoopOnce;exports.LoopRepeat=LoopRepeat;exports.LoopPingPong=LoopPingPong;exports.InterpolateDiscrete=InterpolateDiscrete;exports.InterpolateLinear=InterpolateLinear;exports.InterpolateSmooth=InterpolateSmooth;exports.ZeroCurvatureEnding=ZeroCurvatureEnding;exports.ZeroSlopeEnding=ZeroSlopeEnding;exports.WrapAroundEnding=WrapAroundEnding;exports.TrianglesDrawMode=TrianglesDrawMode;exports.TriangleStripDrawMode=TriangleStripDrawMode;exports.TriangleFanDrawMode=TriangleFanDrawMode;exports.LinearEncoding=LinearEncoding;exports.sRGBEncoding=sRGBEncoding;exports.GammaEncoding=GammaEncoding;exports.RGBEEncoding=RGBEEncoding;exports.LogLuvEncoding=LogLuvEncoding;exports.RGBM7Encoding=RGBM7Encoding;exports.RGBM16Encoding=RGBM16Encoding;exports.RGBDEncoding=RGBDEncoding;exports.BasicDepthPacking=BasicDepthPacking;exports.RGBADepthPacking=RGBADepthPacking;exports.CubeGeometry=BoxGeometry;exports.Face4=Face4;exports.LineStrip=LineStrip;exports.LinePieces=LinePieces;exports.MeshFaceMaterial=MeshFaceMaterial;exports.MultiMaterial=MultiMaterial;exports.PointCloud=PointCloud;exports.Particle=Particle;exports.ParticleSystem=ParticleSystem;exports.PointCloudMaterial=PointCloudMaterial;exports.ParticleBasicMaterial=ParticleBasicMaterial;exports.ParticleSystemMaterial=ParticleSystemMaterial;exports.Vertex=Vertex;exports.DynamicBufferAttribute=DynamicBufferAttribute;exports.Int8Attribute=Int8Attribute;exports.Uint8Attribute=Uint8Attribute;exports.Uint8ClampedAttribute=Uint8ClampedAttribute;exports.Int16Attribute=Int16Attribute;exports.Uint16Attribute=Uint16Attribute;exports.Int32Attribute=Int32Attribute;exports.Uint32Attribute=Uint32Attribute;exports.Float32Attribute=Float32Attribute;exports.Float64Attribute=Float64Attribute;exports.ClosedSplineCurve3=ClosedSplineCurve3;exports.SplineCurve3=SplineCurve3;exports.Spline=Spline;exports.AxisHelper=AxisHelper;exports.BoundingBoxHelper=BoundingBoxHelper;exports.EdgesHelper=EdgesHelper;exports.WireframeHelper=WireframeHelper;exports.XHRLoader=XHRLoader;exports.BinaryTextureLoader=BinaryTextureLoader;exports.GeometryUtils=GeometryUtils;exports.ImageUtils=ImageUtils;exports.Projector=Projector;exports.CanvasRenderer=CanvasRenderer;Object.defineProperty(exports,'__esModule',{value:true});});

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.REPORTERTIMEOUT = exports.numberMaterial = exports.grayMaterial = exports.shadow = exports.desk_shadow = exports.cylinder_shadow = exports.loader = exports.FRUSTUMSIZE = exports.BLOCK = exports.AUDIO = exports.CAMERA = exports.WAVE = exports.GAME = exports.PARTICLE = exports.BOTTLE = exports.COLORS = undefined;

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var COLORS = exports.COLORS = {
	red: 0xCC463D,
	pureRed: 0xff0000,
	white: 0xd8d0d1,
	brown: 0x59332e,
	pink: 0xf39ab7,
	brownDark: 0x23190f,
	blue: 0x009FF7,
	yellow: 0xFFBE00,
	pureWhite: 0xffffff,
	orange: 0xf7aa6c,
	orangeDark: 0xFF8C00,
	black: 0x000000,
	cream: 0xF5F5F5,
	green: 0x2C9F67,
	lightBlue: 0xD1EEEE,
	cyan: 0x93e4ce,
	yellowBrown: 0xffcf8b,
	purple: 0x8a9ad6

};

var BOTTLE = exports.BOTTLE = {
	// bodyWidth: 2.8,
	// bodyDepth: 2.8,
	headRadius: 0.945,
	bodyWidth: 2.34,
	bodyDepth: 2.34,

	bodyHeight: 3.2,

	reduction: 0.005,
	minScale: 0.5,
	velocityYIncrement: 15,
	velocityY: 135,
	velocityZIncrement: 70
};

var PARTICLE = exports.PARTICLE = {
	radius: 0.3,
	detail: 2
};

var GAME = exports.GAME = {
	BOTTOMBOUND: -55,
	TOPBOUND: 41,
	gravity: 720,
	//gravity: 750,
	touchmoveTolerance: 20,
	LEFTBOUND: -140,
	topTrackZ: -30,
	rightBound: 90,
	HEIGHT: window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth,
	WIDTH: window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth,
	canShadow: true
};

var WAVE = exports.WAVE = {
	innerRadius: 2.2,
	outerRadius: 3,
	thetaSeg: 25
};

var CAMERA = exports.CAMERA = {
	fov: 60
};

var AUDIO = exports.AUDIO = {
	success: 'res/success.mp3',
	perfect: 'res/perfect.mp3',
	scale_loop: 'res/scale_loop.mp3',
	scale_intro: 'res/scale_intro.mp3',
	restart: 'res/start.mp3',
	fall: 'res/fall.mp3',
	fall_2: 'res/fall_2.mp3',
	combo1: 'res/combo1.mp3',
	combo2: 'res/combo2.mp3',
	combo3: 'res/combo3.mp3',
	combo4: 'res/combo4.mp3',
	combo5: 'res/combo5.mp3',
	combo6: 'res/combo6.mp3',
	combo7: 'res/combo7.mp3',
	combo8: 'res/combo8.mp3',
	icon: 'res/icon.mp3',
	pop: 'res/pop.mp3',
	sing: 'res/sing.mp3',
	store: 'res/store.mp3',
	water: 'res/water.mp3'
};

var BLOCK = exports.BLOCK = {
	radius: 5,
	width: 10,
	minRadiusScale: 0.8,
	maxRadiusScale: 1,
	height: 5.5,
	radiusSegments: [4, 50],
	floatHeight: 0,
	minDistance: 1,
	maxDistance: 17,
	minScale: BOTTLE.minScale,
	reduction: BOTTLE.reduction,
	moveDownVelocity: 0.07,
	fullHeight: 5.5 / 21 * 40
};

var FRUSTUMSIZE = exports.FRUSTUMSIZE = window.innerHeight / window.innerWidth / 736 * 414 * 60;

var loader = exports.loader = new THREE.TextureLoader();

var cylinder_shadow = exports.cylinder_shadow = new THREE.MeshBasicMaterial({ map: loader.load('res/cylinder_shadow.png'), transparent: true, alphaTest: 0.01 });
var desk_shadow = exports.desk_shadow = new THREE.MeshBasicMaterial({ map: loader.load('res/desk_shadow.png'), transparent: true, alphaTest: 0.01 });
var shadow = exports.shadow = new THREE.MeshBasicMaterial({ map: loader.load('res/shadow.png'), transparent: true, alphaTest: 0.01 });
var grayMaterial = exports.grayMaterial = new THREE.MeshLambertMaterial({ map: loader.load('res/gray.png') });
var numberMaterial = exports.numberMaterial = new THREE.MeshLambertMaterial({ map: loader.load('res/number.png'), alphaTest: 0.6 });

var REPORTERTIMEOUT = exports.REPORTERTIMEOUT = 60001;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _session = __webpack_require__(6);

var _session2 = _interopRequireDefault(_session);

var _storage = __webpack_require__(5);

var _storage2 = _interopRequireDefault(_storage);

var _encryption = __webpack_require__(59);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * 配置目前有：
 * {
 *  audience_mode_switch:0, // 围观模式，围观在前端拦截
 *  friends_score_switch:0,
 *  group_score_switch:0,
 *  game_center_entry_switch, // 目前没有
 *  bad_js_ratio
 * }
 */

var networkConfig = {
  // AJAX_URL: 'https://wxardm.weixin.qq.com',
  AJAX_URL: 'https://mp.weixin.qq.com'
};

var Network = function () {
  function Network() {
    _classCallCheck(this, Network);
  }

  _createClass(Network, null, [{
    key: 'onServerConfigForbid',
    value: function onServerConfigForbid(cb) {
      this.emmitServerConfigForbid = cb;
    }
  }, {
    key: 'getUserInfo',
    value: function getUserInfo() {
      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1
        }
      };

      wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_getuserinfo',
        method: 'POST',
        data: obj,
        success: function success(res) {
          if (res.statusCode !== 200) {
            // // console.log('Network getUserInfo not ok', res)
            return;
          }

          // 当sessionId过期的逻辑 待测
          // if (res.data.base_resp.errcode === -5) {

          //   this.reGetSessionId('getUserInfo')
          //   return
          // }

          if (res.data.base_resp.errcode !== 0) {
            // console.log('Network getUserInfo not ok', res)
            return;
          }

          // console.log('Network getUserInfo success', res)
          _storage2.default.saveMyUserInfo(res.data);
        },
        fail: function fail(err) {
          // console.log('Network getUserInfo fail', err)
        }
      });
    }
  }, {
    key: 'requestLogin',
    value: function requestLogin(afterLoginProcess) {
      if (!afterLoginProcess) {
        afterLoginProcess = function afterLoginProcess() {
          // console.log('Network requestLogin parameter')
        };
      }
      wx.login({
        success: function success(res) {
          if (res.code) {
            // console.log('Network login ok', res.code)

            // 存session
            _session2.default.setLoginState(res.code);

            // 存sessionId到缓存里
            // Storage.saveSessionId(res.code)
            afterLoginProcess(true);
          } else {
            // console.log('Network wx.login fail', res)
            afterLoginProcess(false);
          }
        },
        fail: function fail(res) {

          // 处理失败逻辑
          // console.log('Network wx.login fail: ', res)
          afterLoginProcess(false);
        }
      });
    }
  }, {
    key: 'requestFriendsScore',
    value: function requestFriendsScore() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

      if (_session2.default.serverConfig) {
        if (!_session2.default.serverConfig.friends_score_switch) {
          // console.log('Network requestFriendsScore server forbidden')
          // this.errHandler()
          return;
        }
      }

      if (!_session2.default.sessionId) {
        // console.log('Network requestFriendsScore abort for no sessionId')
        callback(false);
        return;
      }
      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1
        }

        // 数据格式 testData = {
        //   user_info: [
        //     {
        //       nickname: 'juto',
        //       headimg: 'http://wx.qlogo.cn/mmhead/qE9MKluetOlFQg1u4bfs14LFdlRu2MSFKzj5iceWeia4ibZCngaibibE1NQ/0',
        //       score_info: [
        //         {type: 0, score: 1000}
        //       ],
        //     }
        //   ]
        // }
      };wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_getfriendsscore',
        method: 'POST',
        data: obj,
        success: function success(res) {
          if (res.statusCode !== 200) {
            // console.log('Network getfriendsscore not ok', res)
            if (callback) {
              callback(false);
            }
            return;
          }

          // 当sessionId过期的逻辑 待测
          // if (res.data.base_resp.errcode === -5) {
          //   this.reGetSessionId('requestFriendsScore', callback)
          //   return
          // }

          if (res.data.base_resp.errcode !== 0) {
            // console.log('Network getfriendsscore not ok', res)
            if (callback) {
              callback(false);
            }
            return;
          }

          // console.log('Network requestFriendsScore success', res)

          callback(true, res.data);
        },
        fail: function fail(err) {
          // console.log('Network getfriendsscore fail', err)
          callback(false, false);
        }
      });
    }
  }, {
    key: 'requestSettlement',
    value: function requestSettlement() {
      var score = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
      var verifyData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (!_session2.default.sessionId) {
        // console.log('Network requestSettlement abort for no sessionId')
        callback(false);
        return;
      }
      // var scoreInfo = [
      //   { type: 0, score: score },
      //   { type: 2, score: times }
      // ]
      var scoreInfo = {
        score: score,
        times: times,
        game_data: JSON.stringify(verifyData)
      };

      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1
        },
        // score_info: scoreInfo,
        action_data: (0, _encryption.encrypt)(scoreInfo, _session2.default.sessionId)
      };

      wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_settlement',
        method: 'POST',
        data: obj,
        success: function success(res) {
          if (res.statusCode !== 200) {
            // console.log('Network requestCreateGame not ok', res)
            callback(false);
            return;
          }
          if (res.data.base_resp.errcode === 0) {
            // console.log('Network request settlement success', res)
            callback(true);
          } else {
            // console.log('Network request settlement fail', res)
            callback(false);
          }
        },
        fail: function fail(res) {
          // console.log('Network request settlement fail', res)
          callback(false);
        }
      });
    }
  }, {
    key: 'requestCreateGame',
    value: function requestCreateGame() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

      if (_session2.default.serverConfig) {
        // 0是关，1是开  !0 true !1 false
        if (!_session2.default.serverConfig.audience_mode_switch) {
          // console.log('requestCreateGame server forbidden')
          callback(false, '当前围观人数过多，请稍后再试');
          return;
        }
      }

      if (!_session2.default.sessionId) {
        this.reGetSessionId('requestCreateGame', callback);
        // console.log('Network create game request sessionId')
      }

      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1
        }
      };

      wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_creategame',
        method: 'POST',
        data: obj,
        success: function success(res) {
          if (res.statusCode !== 200) {
            // console.log('Network requestCreateGame not ok', res)
            callback(false);
            return;
          }
          if (res.data.base_resp.errcode === 0) {
            // console.log('Network createGame success', res)
            callback(true, res);
          } else {
            // console.log('Network createGame fail', res)
            callback(false);
          }
        },
        fail: function fail(res) {
          // console.log('Network createGame fail', res)
          callback(false);
        }
      });

      // { 返回包示例
      //   data:{
      //     base_resp:{errcode},
      //     game_id:''
      //   }
      // }
    }
  }, {
    key: 'reGetSessionId',
    value: function reGetSessionId(name, cb) {
      var _this = this;

      // console.log('network reGetSessionId:', name)
      _storage2.default.clearSessionId();
      this.requestLogin(function (success) {
        if (success) {
          if (cb) {
            _this[name](cb);
          } else {
            _this[name]();
          }
        } else {
          if (cb) {
            cb(false);
          }
        }
      });
    }

    /**
    * 服务器发的配置存在内存和缓存里
    */

  }, {
    key: 'requestInit',
    value: function requestInit() {
      if (!_session2.default.sessionId) {
        // console.log('Network requestInit request sessionId')
        return;
        this.reGetSessionId('requestInit');
      }

      if (_session2.default.serverConfig) {
        var v = _session2.default.serverConfig.version;
        this.requestServerInit(v);
      } else {
        this.requestServerInit(0);
      }
    }
  }, {
    key: 'requestServerInit',
    value: function requestServerInit(version) {
      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1
        },
        version: version
      };

      wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_init',
        method: 'POST',
        data: obj,
        success: function success(res) {
          if (res.statusCode !== 200) {
            // console.log('Network requestInit not ok', res)
            return;
          }

          // 当sessionId过期的逻辑
          // if (res.data.base_resp.errcode === -5) {

          //   this.reGetSessionId('requestInit')
          //   return
          // }

          if (res.data.base_resp.errcode !== 0) {
            // console.log('Network requestInit not ok', res)
            return;
          }

          // console.log('Network requestInit success', res)
          if (res.data.version > _session2.default.serverConfig.version || !_session2.default.serverConfig.version) {
            _session2.default.setServerConfig(res.data);
            _storage2.default.saveServerConfig(res.data);
          }
        },
        fail: function fail(err) {
          // console.log('Network requestInit fail', err)
        }
      });
    }
  }, {
    key: 'getGroupScore',
    value: function getGroupScore() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

      if (!_session2.default.sessionId) {
        // console.log('Network getGroupScore not ok need sessionID')
        callback(false);
        return;
      }
      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1,
          group_info: {
            share_ticket: _session2.default.shareTicket
          }
        }
      };

      wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_getgrouprank',
        method: 'POST',
        data: obj,
        success: function success(res) {
          if (res.statusCode !== 200) {
            // console.log('Network getGroupScore not ok', res)
            callback(false);
            return;
          }

          // 当sessionId过期的逻辑
          // if (res.data.base_resp.errcode === -5) {

          //   this.reGetSessionId('getGroupScore', callback)
          //   return
          // }

          if (res.data.base_resp.errcode !== 0) {
            // console.log('Network getGroupScore not ok', res)
            callback(false);
            return;
          }
          // console.log('Network getGroupScore success', res)
          callback(true, res);
        },
        fail: function fail(err) {
          // console.log('Network getGroupScore fail', err)
          callback(false);
        }
      });
    }
  }, {
    key: 'createPK',
    value: function createPK(score) {
      return new Promise(function (resolve, reject) {
        if (!_session2.default.sessionId) {
          // console.log('Network getGroupScore not ok need sessionID')
          reject();
          return;
        }
        wx.showLoading();
        var obj = {
          base_req: {
            session_id: _session2.default.sessionId,
            fast: 1
          },
          score: score
        };

        wx.request({
          url: networkConfig.AJAX_URL + '/wxagame/wxagame_createpk',
          method: 'POST',
          data: obj,
          success: function success(res) {
            if (res.statusCode !== 200) {
              // console.log('Network getPKID not ok', res)
              reject();
              return;
            }

            // // 当sessionId过期的逻辑
            // if (res.data.base_resp.errcode === -5) {

            //   this.reGetSessionId('getGroupScore', callback)
            //   return
            // }

            if (res.data.base_resp.errcode !== 0) {
              // console.log('Network getPKID not ok', res)
              reject();
              return;
            }

            _session2.default.setPkId(res.data.pk_id);
            // console.log('Network getPKID success', res.data.pk_id, res)
            resolve();
          },
          fail: function fail(err) {
            // console.log('Network getPKID fail', err)
            reject();
          },
          complete: function complete() {
            wx.hideLoading();
          }
        });
      });
    }
  }, {
    key: 'getBattleData',
    value: function getBattleData() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      var pkId = arguments[1];

      if (!_session2.default.sessionId || !pkId) {
        // console.log('Network getBattleData not ok need sessionID pkId')
        callback(false);
        return;
      }

      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1
        },
        pk_id: pkId
      };

      if (_session2.default.shareTicket) {
        obj.base_req.group_info = {
          share_ticket: _session2.default.shareTicket
        };
      }

      // console.log('getBattleDatagetBattleDatagetBattleData', obj)
      wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_getpkinfo',
        method: 'POST',
        data: obj,
        success: function success(res) {
          if (res.statusCode !== 200) {
            // console.log('Network getBattleData not ok', res)
            callback(false);
            return;
          }

          // 当sessionId过期的逻辑
          // if (res.data.base_resp.errcode === -5) {

          //   this.reGetSessionId('getGroupScore', callback)
          //   return
          // }

          if (res.data.base_resp.errcode !== 0) {
            // console.log('Network getBattleData not ok', res)
            callback(false);
            return;
          }

          // console.log('Network getBattleData success', res)
          callback(true, res);
        },
        fail: function fail(err) {
          // console.log('Network getBattleData fail', err)
          callback(false);
        }
      });
    }
  }, {
    key: 'updatepkinfo',
    value: function updatepkinfo() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      var pkId = arguments[1];
      var score = arguments[2];

      if (!_session2.default.sessionId || !pkId) {
        // console.log('Network getBattleData not ok need sessionID pkId')
        callback(false);
        return;
      }

      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1
        },
        pk_id: pkId,
        score: score

        // console.log('updatepkinfoupdatepkinfoupdatepkinfo', obj)
      };wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_updatepkinfo',
        method: 'POST',
        data: obj,
        success: function success(res) {
          if (res.statusCode !== 200) {
            // console.log('Network updatepkinfo not ok', res)
            callback(false);
            return;
          }

          // // 当sessionId过期的逻辑
          // if (res.data.base_resp.errcode === -5) {

          //   this.reGetSessionId('getGroupScore', callback)
          //   return
          // }

          if (res.data.base_resp.errcode !== 0) {
            // console.log('Network updatepkinfo not ok', res)
            callback(false);
            return;
          }

          // console.log('Network updatepkinfo success', res)
          callback(true, res);
        },
        fail: function fail(err) {
          // console.log('Network updatepkinfo fail', err)
          callback(false);
        }
      });
    }
  }, {
    key: 'quitGame',
    value: function quitGame() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

      if (!_session2.default.gameId && !_session2.default.sessionId) {
        // console.log('Network quitGame not ok need sessionID gameId')
        callback(false);
        return;
      }

      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1
        },
        game_id: _session2.default.gameId
      };

      wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_quitgame',
        method: 'POST',
        data: obj,
        success: function success(res) {
          if (res.statusCode !== 200) {
            // console.log('Network updatepkinfo not ok', res)
            callback(false);
            return;
          }

          // 当sessionId过期的逻辑
          // if (res.data.base_resp.errcode === -5) {

          //   this.reGetSessionId('quitGame', callback)
          //   return
          // }

          if (res.data.base_resp.errcode !== 0) {
            // console.log('Network quitGame not ok', res)
            callback(false);
            return;
          }

          // console.log('Network quitGame success', res)
          callback(true, res);
        },
        fail: function fail(err) {
          // console.log('Network quitGame fail', err)
          callback(false);
        }
      });
    }
  }, {
    key: 'syncop',
    value: function syncop() {
      var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

      if (!_session2.default.gameId && !_session2.default.sessionId) {
        // console.log('Network quitGame not ok need sessionID gameId')
        callback(false);
        return;
      }
      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1
        },
        game_id: _session2.default.gameId
      };

      wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_syncop',
        method: 'POST',
        data: obj,
        success: function success(res) {
          if (res.statusCode !== 200) {
            // console.log('Network syncop not ok', res)
            cb(false);
            return;
          }

          if (res.data.base_resp.errcode !== 0) {
            // console.log('Network syncop not ok', res)
            cb(false);
            return;
          }

          // console.log('Network syncop success', res)
          cb(true, res);
        },
        fail: function fail(err) {
          cb(false);
          // console.log('Network syncop fail', err)
        }
      });
    }
  }, {
    key: 'sendReport',
    value: function sendReport() {
      var reportList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var clientInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!_session2.default.sessionId) {
        // console.log('sendReport need session ID')
        return;
      }

      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1,
          client_info: clientInfo
        },
        report_list: reportList
      };
      wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_bottlereport',
        method: 'POST',
        data: obj,
        success: function success(res) {
          // console.log('Network sendReport success', res)
        },
        fail: function fail() {
          // console.log('Network sendReport fail')
        }
      });
    }
  }, {
    key: 'badReport',
    value: function badReport(msg, stack) {
      var res = wx.getSystemInfoSync();
      var sessionId = _session2.default.sessionId || '';
      var msg = 'model:' + res.model + ',SDKVersion:' + res.SDKVersion + ',version:' + res.version + ',sessionId:' + sessionId + ',errmsg:' + msg + ',stack:' + stack;
      wx.request({
        url: 'https://badjs.weixinbridge.com/badjs',
        data: {
          id: 130,
          level: 4,
          msg: msg
        },
        success: function success(res) {
          // console.log('Network badjs', res)
        },
        fail: function fail(res) {
          // console.log('Network badjs', res)
        }
      });
    }
  }, {
    key: 'sendServerError',
    value: function sendServerError(key) {
      if (!_session2.default.sessionId) {
        // console.log('sendReport need session ID')
        return;
      }

      var obj = {
        base_req: {
          session_id: _session2.default.sessionId,
          fast: 1
        },
        id: 1,
        key: key
      };

      wx.request({
        url: networkConfig.AJAX_URL + '/wxagame/wxagame_jsreport',
        method: 'POST',
        data: obj,
        success: function success(res) {
          // console.log('Network sendServerError success', res)
        },
        fail: function fail() {
          // console.log('Network sendServerError fail')
        }
      });
    }
  }]);

  return Network;
}();

exports.default = Network;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TweenAnimation = exports.customAnimation = undefined;

var _tween = __webpack_require__(41);

var _tween2 = _interopRequireDefault(_tween);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var animationId = -1;
var killAnimationId = animationId - 1;

var customAnimation = exports.customAnimation = {};
customAnimation.to = function (obj, duration, options) {
    duration *= 1000;
    var delay = options.delay || 0;
    for (var name in options) {
        if (name === 'delay') {
            delay = options[name];
        } else if (name === 'onComplete') {} else if (name === 'ease') {} else {
            setTimeout(function (name) {
                return function () {
                    //console.log("name", name, obj[name], options[name], duration, delay, obj)
                    TweenAnimation(obj[name], options[name], duration, options.ease || 'Linear', function (value, complete) {
                        obj[name] = value;
                        if (complete) {
                            options.onComplete && options.onComplete();
                        }
                    });
                };
            }(name), delay * 1000);
        }
    }
};

// 对运动方法进行封装
var TweenAnimation = exports.TweenAnimation = function TweenAnimation(from, to, duration, easing, callback) {
    var selfAnimationId = ++animationId;
    var isUndefined = function isUndefined(obj) {
        return typeof obj == 'undefined';
    };
    var isFunction = function isFunction(obj) {
        return typeof obj == 'function';
    };
    var isNumber = function isNumber(obj) {
        return typeof obj == 'number';
    };
    var isString = function isString(obj) {
        return typeof obj == 'string';
    };

    // 转换成毫秒
    var toMillisecond = function toMillisecond(obj) {
        if (isNumber(obj)) {
            return obj;
        } else if (isString(obj)) {
            if (/\d+m?s$/.test(obj)) {
                if (/ms/.test(obj)) {
                    return 1 * obj.replace('ms', '');
                }
                return 1000 * obj.replace('s', '');
            } else if (/^\d+$/.test(obj)) {
                return +obj;
            }
        }
        return -1;
    };

    if (!isNumber(from) || !isNumber(to)) {
        if (window.console) {
            console.error('from和to两个参数必须且为数值');
        }
        return 0;
    }

    // 缓动算法
    var tween = _tween2.default;

    if (!tween) {
        if (window.console) {
            console.error('缓动算法函数缺失');
        }
        return 0;
    }

    // duration, easing, callback均为可选参数
    // 而且顺序可以任意
    var options = {
        duration: 300,
        easing: 'Linear',
        callback: function callback() {}
    };

    var setOptions = function setOptions(obj) {
        if (isFunction(obj)) {
            options.callback = obj;
        } else if (toMillisecond(obj) != -1) {
            options.duration = toMillisecond(obj);
        } else if (isString(obj)) {
            options.easing = obj;
        }
    };
    setOptions(duration);
    setOptions(easing);
    setOptions(callback);

    // requestAnimationFrame的兼容处理
    if (!window.requestAnimationFrame) {
        requestAnimationFrame = function requestAnimationFrame(fn) {
            setTimeout(fn, 17);
        };
    }

    // 算法需要的几个变量
    var start = -1;
    // during根据设置的总时间计算
    var during = Math.ceil(options.duration / 17);

    // 当前动画算法
    // 确保首字母大写
    options.easing = options.easing.slice(0, 1).toUpperCase() + options.easing.slice(1);
    var arrKeyTween = options.easing.split('.');
    var fnGetValue;

    if (arrKeyTween.length == 1) {
        fnGetValue = tween[arrKeyTween[0]];
    } else if (arrKeyTween.length == 2) {
        fnGetValue = tween[arrKeyTween[0]] && tween[arrKeyTween[0]][arrKeyTween[1]];
    }
    if (isFunction(fnGetValue) == false) {
        console.error('没有找到名为"' + options.easing + '"的动画算法');
        return;
    }

    var startTime = Date.now();
    var lastTime = Date.now();
    // 运动
    var step = function step() {
        var currentTime = Date.now();
        var interval = currentTime - lastTime;
        var fps = Math.ceil(1000 / interval);
        lastTime = currentTime;
        if (interval > 100) {
            requestAnimationFrame(step);
            return;
        }
        if (fps >= 30) {
            start++;
        } else {
            var _start = Math.floor((currentTime - startTime) / 17);
            start = _start > start ? _start : start + 1;
        }

        // 当前的运动位置
        var value = fnGetValue(start, from, to - from, during);

        // 如果还没有运动到位，继续
        if (start <= during && selfAnimationId > killAnimationId) {
            options.callback(value);
            requestAnimationFrame(step);
        } else if (start > during && selfAnimationId > killAnimationId) {
            // 动画结束，这里可以插入回调...
            options.callback(to, true);
        } else {}
    };
    // 开始执行动画
    step();
};

TweenAnimation.killAll = function () {
    killAnimationId = animationId;
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Storage = function () {
  function Storage() {
    _classCallCheck(this, Storage);
  }

  _createClass(Storage, null, [{
    key: 'getFriendsScore',
    value: function getFriendsScore() {
      try {
        var value = wx.getStorageSync('friends_score') || [];
        if (value && value.ts) {
          if (value.ts < Date.now()) {
            value = [];
          } else {
            value = value.data;
          }
        } else {
          value = [];
        }
        // console.log('Storage get getFriendsScore success', value)
        return value;
      } catch (e) {
        // console.log('Storage get getFriendsScore fail', e)
        return [];
      }
    }
  }, {
    key: 'saveFriendsScore',
    value: function saveFriendsScore(data) {
      wx.setStorage({
        key: 'friends_score',
        data: data,
        success: function success(res) {
          // console.log('Storage save friend score success', data)
        },
        fail: function fail(err) {
          // console.log('Storage save friend score fail', data)
        }
      });
    }
  }, {
    key: 'saveMyUserInfo',
    value: function saveMyUserInfo(myUserInfo) {
      wx.setStorage({
        key: 'my_user_info',
        data: myUserInfo,
        success: function success(res) {
          // console.log('Storage save my user info success', res)
        },
        fail: function fail(err) {
          // console.log('Storage save  my user info fail ', err)
        }
      });
    }
  }, {
    key: 'saveHeighestScore',
    value: function saveHeighestScore(data) {
      wx.setStorage({
        key: 'my_heighest_score',
        data: data,
        success: function success(res) {
          // console.log('Storage save my heighest score success', data, res)
        },
        fail: function fail(err) {
          // console.log('Storage save  my heighest score fail ', err)
        }
      });
    }
  }, {
    key: 'getHeighestScore',
    value: function getHeighestScore() {
      try {
        var value = wx.getStorageSync('my_heighest_score') || false;
        // console.log('Storage get Heighest Score success', value)
        return value;
      } catch (e) {
        // console.log('Storage get Heighest Score fail', e)
        return false;
      }
    }
  }, {
    key: 'getMyUserInfo',
    value: function getMyUserInfo() {
      try {
        var value = wx.getStorageSync('my_user_info') || false;
        // console.log('Storage get my user info success', value)
        return value;
      } catch (e) {
        // console.log('Storage get my user info fail', e)
        return false;
      }
    }
  }, {
    key: 'saveSessionId',
    value: function saveSessionId(sessionId) {
      wx.setStorage({
        key: 'session_id',
        data: sessionId,
        success: function success(res) {
          // console.log('Storage session ID success', res)
        },
        fail: function fail(err) {
          // console.log('Storage save session ID fail ', err)
        }
      });
    }
  }, {
    key: 'getSessionId',
    value: function getSessionId(callback) {
      // wx.getStorage({
      //   key: 'session_id',
      //   success: function (res) {
      //     console.log('Storage get session ID success', res)
      //     callback(res.data)
      //   },
      //   fail: function (err) {
      //     console.log('Storage get session ID fail', err)
      //     callback(false)
      //   }
      // })
      try {
        var value = wx.getStorageSync('session_id') || '';
        // console.log('Storage get sessionid success', value)
        return value;
      } catch (e) {
        // console.log('Storage get sessionid fail')
        return "";
      }
    }
  }, {
    key: 'clearSessionId',
    value: function clearSessionId() {
      wx.removeStorage({
        key: 'session_id',
        success: function success(res) {
          // console.log('Storage clear session_id success')
        },
        fail: function fail(res) {
          // console.log('Storage clear session_id fail')
        }
      });
    }
  }, {
    key: 'saveServerConfig',
    value: function saveServerConfig(data) {
      wx.setStorage({
        key: 'server_config',
        data: data,
        success: function success(res) {
          // console.log('Storage save ServerConfig success', res)
        },
        fail: function fail(err) {
          // console.log('Storage save ServerConfig fail ', err)
        }
      });
    }
  }, {
    key: 'getServerConfig',
    value: function getServerConfig() {
      try {
        var value = wx.getStorageSync('server_config') || 0;
        // console.log('Storage get getServerConfig success', value)
        return value;
      } catch (e) {
        // console.log('Storage get getServerConfig fail')
        return 0;
      }
    }
  }, {
    key: 'getFirstBlood',
    value: function getFirstBlood() {
      try {
        var value = wx.getStorageSync('first_blood') || 0;
        // console.log('Storage get first_blood success', value)
        return value;
      } catch (e) {
        // console.log('Storage get first_blood fail')
        return 0;
      }
    }
  }, {
    key: 'saveFirstBlood',
    value: function saveFirstBlood() {
      wx.setStorage({
        key: 'first_blood',
        data: 1,
        success: function success(res) {
          // console.log('Storage save first_blood success', res)
        },
        fail: function fail(err) {
          // console.log('Storage save first_blood fail', err)
        }
      });
    }
  }, {
    key: 'getHistoryTimes',
    value: function getHistoryTimes() {
      try {
        var value = wx.getStorageSync('history_Times2') || false;
        // console.log('Storage get history_Times success', value)
        return value;
      } catch (e) {
        // console.log('Storage get history_Times fail')
        return false;
      }
    }
  }, {
    key: 'saveHistoryTimes',
    value: function saveHistoryTimes(data) {
      wx.setStorage({
        key: 'history_Times2',
        data: data,
        success: function success(res) {
          // console.log('Storage save history_Times success', res)
        },
        fail: function fail(err) {
          // console.log('Storage save history_Times fail', err)
        }
      });
    }
  }, {
    key: 'saveActionData',
    value: function saveActionData(data) {
      wx.setStorage({
        key: 'action_data0',
        data: data,
        success: function success(res) {
          console.log('Storage save actionData0 success', res);
        },
        fail: function fail(err) {
          console.log('Storage save actionData0 fail', err);
        }
      });
    }
  }, {
    key: 'getActionData',
    value: function getActionData() {
      try {
        var value = wx.getStorageSync('action_data0') || false;
        // console.log('Storage get history_Times success', value)
        return value;
      } catch (e) {
        // console.log('Storage get history_Times fail')
        return false;
      }
    }
  }, {
    key: 'saveWeekBestScore',
    value: function saveWeekBestScore(data) {
      wx.setStorage({
        key: 'weeek_best_score0',
        data: data,
        success: function success(res) {
          // console.log('Storage save weeek_best_score0 success', res)
        },
        fail: function fail(err) {
          // console.log('Storage save weeek_best_score0 fail', err)
        }
      });
    }
  }, {
    key: 'getWeekBestScore',
    value: function getWeekBestScore() {
      try {
        var value = wx.getStorageSync('weeek_best_score0') || 0;
        if (value && value.ts) {
          if (value.ts < Date.now()) {
            value = 0;
          } else {
            value = value.data;
          }
        }
        console.log('Storage get weeek_best_score0 success', value);
        return value;
      } catch (e) {
        // console.log('Storage get history_Times fail')
        return 0;
      }
    }
  }]);

  return Storage;
}();

exports.default = Storage;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Session = function () {
  function Session() {
    _classCallCheck(this, Session);
  }

  _createClass(Session, null, [{
    key: 'init',
    value: function init() {
      this.sessionId = '';
      this.gameId = '';
      this.gameTicket = '';
      this.serverConfig = '';
      this.shareTicket = '';
      this.pkId = '';
      this.serverConfig = '';
    }
  }, {
    key: 'setLoginState',
    value: function setLoginState(sessionId) {
      this.sessionId = sessionId;
    }
  }, {
    key: 'setGameId',
    value: function setGameId(gameId) {
      this.gameId = gameId;
    }
  }, {
    key: 'setGameTicket',
    value: function setGameTicket(gameTicket) {
      this.gameTicket = gameTicket;
    }
  }, {
    key: 'setServerConfig',
    value: function setServerConfig(config) {
      this.serverConfig = config;
    }
  }, {
    key: 'setShareTicket',
    value: function setShareTicket(ticket) {
      this.shareTicket = ticket;
    }
  }, {
    key: 'setPkId',
    value: function setPkId(id) {
      this.pkId = id;
    }
  }, {
    key: 'clearPkId',
    value: function clearPkId() {
      this.pkId = '';
    }
  }, {
    key: 'clearGameId',
    value: function clearGameId() {
      this.gameId = '';
    }
  }, {
    key: 'clearShareTicket',
    value: function clearShareTicket() {
      this.ShareTicket = '';
    }
  }, {
    key: 'clearGameTicket',
    value: function clearGameTicket() {
      this.gameTicket = '';
    }
  }, {
    key: 'setServerConfig',
    value: function setServerConfig(config) {
      this.serverConfig = config;
    }
  }]);

  return Session;
}();

exports.default = Session;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shareGroupRank = shareGroupRank;
exports.shareBattle = shareBattle;
exports.shareObserve = shareObserve;
exports.pureShare = pureShare;

var _session = __webpack_require__(6);

var _session2 = _interopRequireDefault(_session);

var _storage = __webpack_require__(5);

var _storage2 = _interopRequireDefault(_storage);

var _shareCard = __webpack_require__(50);

var _shareCard2 = _interopRequireDefault(_shareCard);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var shareCard = new _shareCard2.default({});
function shareGroupRank() {
  var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

  wx.getNetworkType({
    success: function success(res) {
      if (res.networkType !== 'none') {
        wx.updateShareMenu({
          withShareTicket: true,
          success: function success() {
            wx.shareAppMessage({

              title: '群雄逐鹿，看看你第几',
              query: 'mode=groupShare',
              imageUrl: 'http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNQ0ia79enzYJBrAavqMRykpovYxSA9RRTwIjde6a68ZCczLMBBd8eSoOyTRyp2Codc5IObdeqZVFyw/0?wx_fmt=png',
              success: function success(res) {
                cb(true, 1);
                // let shareTicket = ''
                // if (res.shareTickets) {
                //   shareTicket = res.shareTickets[0]
                // }
                // // console.log('#####res', res)
                // wx.getShareInfo({
                //   shareTicket,
                //   success(res) {
                //     cb(true, 1)
                //     // console.log('###res', res)
                //   },
                //   fail(e) {
                //     wx.showModal({
                //       title: '提示',
                //       content: '分享至群聊才能查看群排行哦~',
                //       showCancel: false
                //     })
                //     cb(true, 0)
                //     // console.log('###res e', e)
                //   }
                // })
              },
              fail: function fail(err) {
                cb(false);
                // console.log('send invitation fail:', err)
              }
            });
          }
        });
      } else {
        cb(false);
        wx.showModal({
          title: '提示',
          content: '网络状态异常',
          showCancel: false
        });
      }
    }
  });
}

function shareBattle(pkId, score) {
  var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

  shareCard.getShareCard({
    score: score,
    type: 'shareBattle'
  }, function (canvas) {
    var path = '';
    try {
      path = canvas.toTempFilePathSync();
    } catch (e) {
      console.log('shareBattle: ', e);
    }
    if (!pkId) {
      return;
    }
    wx.updateShareMenu({
      withShareTicket: true,
      success: function success() {

        wx.shareAppMessage({
          title: '小试牛刀，不服来战',
          query: 'mode=battle&pkId=' + pkId,
          imageUrl: path,
          success: function success(res) {
            cb(true, 1);
            // let shareTicket = ''
            // if (res.shareTickets) {
            //   shareTicket = res.shareTickets[0]
            // }
            // wx.getShareInfo({
            //   shareTicket,
            //   success(res) {
            //     // console.log('shareBattle', res)
            //     cb(true, 1)
            //   },
            //   fail(e) {
            //     // console.log('shareBattle e', e)
            //     cb(true, 0)
            //   }
            // })
            console.log('mode=battle&pkId=' + pkId);
          },
          fail: function fail() {
            cb(false);
          }
        });
      },
      fail: function fail(err) {
        // console.log('shareBattle e', e)
        cb(false);
      }
    });
  });
}

function shareObserve() {
  var cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};

  var myUserInfo = _storage2.default.getMyUserInfo();
  if (!myUserInfo) {
    myUserInfo = {
      nickname: '',
      headimg: ''
    };
  }
  console.log('query: ', 'gameId=' + _session2.default.gameId + '&mode=observe&nickName=' + myUserInfo.nickname + '&headimg=' + myUserInfo.headimg);
  wx.updateShareMenu({
    withShareTicket: true,
    success: function success() {
      wx.shareAppMessage({
        title: '即刻起跳，速来围观',
        query: 'gameId=' + _session2.default.gameId + '&mode=observe&nickName=' + myUserInfo.nickname + '&headimg=' + myUserInfo.headimg,
        imageUrl: 'http://mmbiz.qpic.cn/mmbiz_png/icTdbqWNOwNQ0ia79enzYJBiaBtXsYrvBsYBdBdDtKE7y638J84JKPckcOtFMp4QunIWFGc7pibQLm13s9fKZ9ic9ew/0?wx_fmt=png',
        success: function success(res) {
          // console.log('send invitation success')
          cb(true, 1);
          // let shareTicket = ''
          // if (res.shareTickets) {
          //   shareTicket = res.shareTickets[0]
          // }
          // wx.getShareInfo({
          //   shareTicket,
          //   success(res) {
          //     cb(true, 1)
          //     // console.log('###res', res)
          //   },
          //   fail(e) {
          //     cb(true, 0)
          //     // console.log('###res e', e)
          //   }
          // })
        },
        fail: function fail(err) {
          // console.log('send invitation fail', err)
          cb(false);
        }
      });
    },
    fail: function fail() {
      cb(false);
    }
  });
}

function pureShare(type, score) {
  shareCard.getShareCard({ type: type, score: score }, function (canvas) {
    // console.log('???', canvas)
    var path = '';
    try {
      path = canvas.toTempFilePathSync();
    } catch (e) {
      console.log('pureShare: ', e);
    }
    // wx.updateShareMenu({
    // withShareTicket: true,
    // success() {
    var title = '';
    if (type == 'rank') {
      title = '跳遍天下，已无敌手';
    } else {
      // history week
      title = '不好意思，又破纪录了';
    }
    wx.shareAppMessage({
      title: title,
      // query: `gameId=${Session.gameId}&mode=observe&nickName=${myUserInfo.nickname}&headimg=${myUserInfo.headimg}`,
      imageUrl: path,
      success: function success(res) {
        // console.log('send invitation success')
        // // cb()
        // let shareTicket = ''
        // if (res.shareTickets) {
        //   shareTicket = res.shareTickets[0]
        // }
        // wx.getShareInfo({
        //   shareTicket,
        //   success(res) {
        //     cb(true, 1)
        //     // console.log('###res', res)
        //   },
        //   fail(e) {
        //     cb(true, 0)
        //     // console.log('###res e', e)
        //   }
        // })
      },
      fail: function fail(err) {
        //cb(false)
      }
    });
    // },
    // fail() {}
    // })
  });
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

var _config = __webpack_require__(2);

var _font = __webpack_require__(39);

var _font2 = _interopRequireDefault(_font);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Text = function () {
	function Text(text, options) {
		_classCallCheck(this, Text);

		this.material = new THREE.MeshBasicMaterial({ color: options.fillStyle || 0xffffff, transparent: true });
		if (options.opacity) this.material.opacity = options.opacity;
		this.options = options || {};
		this.obj = new THREE.Object3D();
		this.obj.name = 'text';
		if (options.chinese) {
			var chinese = new THREE.Mesh(new THREE.TextGeometry(text, { 'font': _font2.default, 'size': 1.0, 'height': 0.1 }), this.material);
			this.obj.add(chinese);
			if (options.textAlign == 'center') chinese.position.x = text.length * 1.1 / -2;
			// var chinese = new THREE.Mesh(new THREE.TextGeometry(text, { 'font': FONT, 'size': 1.0, 'height': 0.1 }), this.material);
			// this.obj.add(chinese);
			// if (options.textAlign == 'center') chinese.position.x = text.length * 1.1 / -2; 
		} else {
			this.scores = [];
			this.plus = new THREE.Mesh(new THREE.TextGeometry('+', { 'font': _font2.default, 'size': 3.0, 'height': 0.1 }), this.material);
			var amount = this.options.sumScore ? 5 : 2;
			for (var i = 0; i < 10; ++i) {
				var duplicateArr = [];
				var geometry = new THREE.TextGeometry(i, { 'font': _font2.default, 'size': 3.0, 'height': 0.1 });
				for (var j = 0; j < amount; ++j) {
					var score = new THREE.Mesh(geometry, this.material);
					score.using = false;
					duplicateArr.push(score);
				}
				this.scores.push(duplicateArr);
			}
			this.setScore(text);
		}
	}

	_createClass(Text, [{
		key: 'setScore',
		value: function setScore(score) {
			var perWidth = 2.5;
			score = score.toString();
			var lengthSum = score.length * perWidth;
			var amount = this.options.sumScore ? 5 : 2;
			var sum = this.options.textAlign == 'center' ? -lengthSum / 2 : 0;
			if (this.options.plusScore) {
				sum = -(lengthSum + perWidth) / 2;
				this.plus.position.x = sum;
				this.obj.add(this.plus);
				sum += perWidth;
			}
			for (var i = 0, len = this.scores.length; i < len; ++i) {
				for (var j = 0; j < amount; ++j) {
					if (this.scores[i][j].using) {
						this.obj.remove(this.scores[i][j]);
						this.scores[i][j].using = false;
					}
				}
			}
			for (var i = 0, len = score.length; i < len; ++i) {
				var scores = this.scores[score[i]];
				for (var j = 0; j < amount; ++j) {
					if (!scores[j].using) {
						scores[j].position.x = sum;
						scores[j].using = true;
						this.obj.add(scores[j]);
						break;
					}
				}
				sum += perWidth;
			}
		}
	}, {
		key: 'changeStyle',
		value: function changeStyle(obj) {
			Object.assign(this.options, obj);
			this.obj.updateMatrix();
		}
	}]);

	return Text;
}();

exports.default = Text;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var seed = void 0;

var setRandomSeed = function setRandomSeed(s) {
  seed = s;
};

var rand = function rand() {
  seed = (seed * 9301 + 49297) % 233280;
  return Math.floor(seed / 233280.0 * 100) / 100;
};

var random = function random() {
  if (arguments.length === 0) {
    return rand();
  } else if (arguments.length === 1) {
    var e = arguments[0];
    return Math.floor(rand() * e);
  } else {
    var s = arguments[0];
    var _e = arguments[1];
    return Math.floor(rand() * (_e - s)) + s;
  }
};
/**
 * 用法：random(a,b)随机产生一个a到b之间的整数
 * 
 */
exports.setRandomSeed = setRandomSeed;
exports.random = random;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _singleStartPage = __webpack_require__(54);

var _singleStartPage2 = _interopRequireDefault(_singleStartPage);

var _singleGamePage = __webpack_require__(53);

var _singleGamePage2 = _interopRequireDefault(_singleGamePage);

var _singleGameOverPage = __webpack_require__(52);

var _singleGameOverPage2 = _interopRequireDefault(_singleGameOverPage);

var _singleFriendRankPage = __webpack_require__(51);

var _singleFriendRankPage2 = _interopRequireDefault(_singleFriendRankPage);

var _shareApp = __webpack_require__(7);

var _network = __webpack_require__(3);

var _network2 = _interopRequireDefault(_network);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var singleCtrl = function () {
  function singleCtrl(game, modeCtrl) {
    _classCallCheck(this, singleCtrl);

    this.name = 'single';
    this.game = game;
    this.gameCtrl = this.game.gameCtrl;
    this.model = this.game.gameModel;
    this.view = this.game.gameView;
    this.modeCtrl = modeCtrl;
    this.netWorkCtrl = this.gameCtrl.netWorkCtrl;
    this.gameSocket = this.game.gameSocket;

    this.startPage = new _singleStartPage2.default(game);
    this.gamePage = new _singleGamePage2.default(game);
    this.gameOverPage = new _singleGameOverPage2.default(game);
    this.friendRankPage = new _singleFriendRankPage2.default(game);
    this.currentPage = null;
    this.lastPage = null;

    this.socketTimeout = null;
  }

  _createClass(singleCtrl, [{
    key: 'init',
    value: function init(options) {
      this.startPage.show();
      this.model.setStage(this.startPage.name);
      this.currentPage = this.startPage;
    }
  }, {
    key: 'clickStart',
    value: function clickStart() {
      this.hideCurrentPage();
      this.gamePage.show();
      this.game.replayGame();
      this.model.setStage(this.gamePage.name);
      this.currentPage = this.gamePage;
    }
  }, {
    key: 'showGameOverPage',
    value: function showGameOverPage() {
      this.hideCurrentPage();
      this.gameOverPage.show();

      // 清空上次留存的pkId
      this.model.clearPkId();
      this.model.setStage(this.gameOverPage.name);
      this.currentPage = this.gameOverPage;
    }
  }, {
    key: 'gameOverClickReplay',
    value: function gameOverClickReplay() {
      this.clickStart();
    }
  }, {
    key: 'showFriendRank',
    value: function showFriendRank() {
      this.lastPage = this.currentPage;
      this.hideCurrentPage();
      this.friendRankPage.show();
      this.model.setStage(this.friendRankPage.name);
      this.currentPage = this.friendRankPage;
    }
  }, {
    key: 'friendRankReturn',
    value: function friendRankReturn() {
      this.hideCurrentPage();
      this.lastPage.show();

      this.model.setStage(this.lastPage.name);
      this.currentPage = this.lastPage;
      // this.lastPage = null
    }
  }, {
    key: 'shareGroupRank',
    value: function shareGroupRank() {
      var _this = this;

      (0, _shareApp.shareGroupRank)(function (success, isGroup) {
        _this.gameCtrl.afterShareGroupRank(success, isGroup);
      });
    }
  }, {
    key: 'clickRank',
    value: function clickRank() {
      this.showFriendRank();
    }
  }, {
    key: 'shareBattleCard',
    value: function shareBattleCard() {
      var _this2 = this;

      var sessionId = this.model.getSessionId();
      var currentScore = this.model.currentScore;
      var pkId = this.model.getPkId();
      if (!sessionId) {
        this.view.showNoSession();
        return;
      }

      if (!pkId) {
        _network2.default.createPK(currentScore).then(function () {
          _this2.afterHavePkId();
        }, function () {
          _this2.getPKErr();
        }).catch(function (err) {
          return console.log(err);
        });
      } else {
        this.afterHavePkId();
      }
    }
  }, {
    key: 'afterHavePkId',
    value: function afterHavePkId() {
      var _this3 = this;

      var pkId = this.model.getPkId();
      var score = this.model.currentScore;

      (0, _shareApp.shareBattle)(pkId, score, function (success, isGroup) {
        _this3.gameCtrl.afterShareBattle(success, isGroup);
      });
    }
  }, {
    key: 'getPKErr',
    value: function getPKErr() {
      this.view.showGetPkIdFail();
    }
  }, {
    key: 'shareObservCard',
    value: function shareObservCard() {
      this.gamePage.hideLookersShare();
      this.model.setStage('loading');
      wx.showLoading();
      var sessionId = this.model.getSessionId();
      if (!sessionId) {
        this.netWorkCtrl.netWorkLogin(this.afterLogin.bind(this));
      } else {
        this.afterLogin(true);
      }
    }
  }, {
    key: 'afterLogin',
    value: function afterLogin(success) {
      var _this4 = this;

      if (success) {
        // 连接socket和请求gameId
        _network2.default.requestCreateGame(function (success, res) {
          if (success) {
            _this4.model.setGameId(res.data.game_id);
            _this4.model.setGameTicket(res.data.up_op_ticket);
            _this4.shareObservCardA();
          } else {
            _this4.shareObservCardFail(res);
          }
        });
      } else {
        this.shareObservCardFail();
      }
    }
  }, {
    key: 'shareObservCardFail',
    value: function shareObservCardFail(res) {

      // 提示wording弹窗
      this.view.showShareObserveCardFail(res);

      // 清理gameId，gameTicket
      this.model.clearGameId();
      this.model.clearGameTicket();

      // 切回stage loading -> game
      if (this.model.stage == 'loading') {
        this.model.setStage('game');
      }

      // 清除定时器
      this.clearSocketTimeout();

      // 关闭socket 回到游戏页面
      this.gameSocket.close();

      // 清除wx.showloading
      wx.hideLoading();
    }
  }, {
    key: 'shareObservCardA',
    value: function shareObservCardA() {
      this.socketTimeout = setTimeout(this.shareObservCardFail.bind(this), 5000);

      /**
       * 连接网络
       * socket连接上自动joingame，中间出错，直接调用分享失败,关闭socket
       */
      this.gameSocket.connectSocket();
    }
  }, {
    key: 'socketJoinSuccess',
    value: function socketJoinSuccess(success) {
      wx.hideLoading();
      if (success) {

        // 取消定时器
        this.clearSocketTimeout();
        this.shareObservCardB();
      } else {
        this.shareObservCardFail();
      }
    }
  }, {
    key: 'shareObservCardB',
    value: function shareObservCardB() {
      var _this5 = this;

      (0, _shareApp.shareObserve)(function (success, num) {
        if (!!success) {
          _this5.gameCtrl.afterShareObserveCard(num);
        }
        setTimeout(function () {
          // console.log('!!!!!shareObservCardB,stage', this.model.stage)
          if (_this5.model.stage == 'loading') {
            _this5.model.setStage('game');
          }
          _this5.modeCtrl.singleChangeToPlayer();
          _this5.currentPage = null;
        }, 50);
      });
    }
  }, {
    key: 'clearSocketTimeout',
    value: function clearSocketTimeout() {
      if (this.socketTimeout != null) {
        clearTimeout(this.socketTimeout);
        this.socketTimeout = null;
      }
    }
  }, {
    key: 'wxOnhide',
    value: function wxOnhide() {
      return;
    }
  }, {
    key: 'wxOnshow',
    value: function wxOnshow() {
      return;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.hideCurrentPage();
      this.currentPage = null;
      this.model.setStage('');
      // 清理gameId，gameTicket
      this.model.clearGameId();
      this.model.clearGameTicket();

      // 清除定时器
      this.clearSocketTimeout();

      this.game.resetScene();
    }
  }, {
    key: 'hideCurrentPage',
    value: function hideCurrentPage() {
      if (this.currentPage) {
        this.currentPage.hide();
      }
    }
  }]);

  return singleCtrl;
}();

exports.default = singleCtrl;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _scroll = __webpack_require__(57);

var _scroll2 = _interopRequireDefault(_scroll);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var UNDERSCROLL_TRACKING = 0.5;

var ScrollHandler = function () {
  function ScrollHandler(options) {
    _classCallCheck(this, ScrollHandler);

    options = options || {};

    // this._element = element; // element 是内部的列表
    this._options = options;

    this._itemSize = options.itemSize || 0;

    this._innerOffsetHeight = options.innerOffsetHeight || 0; // 内部列表高度
    this._outterOffsetHeight = options.outterOffsetHeight || 0; // 外部容器高度

    this._extent = this._innerOffsetHeight - this._outterOffsetHeight; // 可滚动的高度

    this._position = 0;
    this._scroll = new _scroll2.default(this._extent);
    this.updatePosition();
  }

  _createClass(ScrollHandler, [{
    key: 'onTouchStart',
    value: function onTouchStart() {
      this._startPosition = this._position;
      this._lastChangePos = this._startPosition;

      // Ensure that we don't jump discontinuously when applying the underscroll
      // tracking in onTouchMove if the view is currently outside of the valid
      // scroll constraints.
      if (this._startPosition > 0) this._startPosition /= UNDERSCROLL_TRACKING;else if (this._startPosition < -this._extent) this._startPosition = (this._startPosition + this._extent) / UNDERSCROLL_TRACKING - this._extent;

      if (this._animation) {
        this._animation.cancel();
        this._scrolling = false;
      }
      this.updatePosition();
    }
  }, {
    key: 'onTouchMove',
    value: function onTouchMove(dx, dy) {
      // 
      var pos = this._startPosition;
      pos += dy;
      if (pos > 0) pos *= UNDERSCROLL_TRACKING;else if (pos < -this._extent) pos = (pos + this._extent) * UNDERSCROLL_TRACKING - this._extent;
      this._position = pos;

      this.updatePosition();
    }
  }, {
    key: 'onTouchEnd',
    value: function onTouchEnd(dx, dy, velocity) {
      var that = this;

      this._scroll.set(this._position, velocity.y);

      this._scrolling = true;
      this._lastChangePos = this._position;

      this._animation = this.animation(this._scroll, function () {
        var now = Date.now();
        var t = (now - that._scroll._startTime) / 1000.0;
        var pos = that._scroll.x(t);
        // console.log('t: ', t, ' pos: ', pos);
        that._position = pos;
        // The translateZ is to help older WebKits not collapse this layer into a non-composited layer
        // since they're also slow at repaints.
        that.updatePosition();
      }, function done() {
        that._scrolling = false;
      });
    }
  }, {
    key: 'scrollTo',
    value: function scrollTo(pos) {
      if (this._animation) {
        this._animation.cancel();
        this._scrolling = false;
      }

      if (typeof pos === 'number') {
        this._position = -pos;
      }

      if (this._position < -this._extent) {
        this._position = -this._extent;
      } else if (this._position > 0) {
        this._position = 0;
      }
      this.updatePosition();
    }
  }, {
    key: 'updatePosition',
    value: function updatePosition() {
      this._options.updatePosition(this._position);
    }
  }, {
    key: 'animation',
    value: function animation(physicsModel, callback, doneFn) {

      function onFrame(handle, model, cb, doneFn) {
        if (handle && handle.cancelled) return;
        cb(model);
        var done = physicsModel.done();
        if (!done && !handle.cancelled) {
          handle.id = requestAnimationFrame(onFrame.bind(null, handle, model, cb, doneFn));
        }
        if (done && doneFn) {
          doneFn(model);
        }
      }
      function cancel(handle) {
        if (handle && handle.id) cancelAnimationFrame(handle.id);
        if (handle) handle.cancelled = true;
      }

      var handle = { id: 0, cancelled: false };
      onFrame(handle, physicsModel, callback, doneFn);

      return { cancel: cancel.bind(null, handle), model: physicsModel };
    }
  }]);

  return ScrollHandler;
}();

exports.default = ScrollHandler;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

var _config = __webpack_require__(2);

var _animation = __webpack_require__(4);

var _random = __webpack_require__(9);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var colors = {
	green: 0x619066,
	white: 0xeeeeee,
	lightGreen: 0x7ba980,
	gray: 0x9e9e9e,
	black: 0x6d6d6d,
	lightGray: 0xdbdbdb,
	lightBlack: 0xcbcbcb,
	brown: 0x676767,
	middleLightGreen: 0x774a379,
	middleLightGray: 0xbbbbbb,
	middleLightBlack: 0x888888
};

var biggerGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2 + 0.02, _config.BLOCK.height + 0.04, _config.BLOCK.radius * 2 + 0.02);
var staticGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, _config.BLOCK.height, _config.BLOCK.radius * 2);
var shadowGeometry = new THREE.PlaneGeometry(11, 11);
var stripeMaterial = new THREE.MeshBasicMaterial({ map: _config.loader.load('res/stripe.png') });
var customMaterial = _config.GAME.canShadow ? THREE.MeshLambertMaterial : THREE.MeshBasicMaterial;

var Block = function () {
	function Block(type, number) {
		var _this = this;

		_classCallCheck(this, Block);

		//this.radiusSegments = BLOCK.radiusSegments[Math.floor(Math.random() * BLOCK.radiusSegments.length)];
		//this.geometry = new THREE.CylinderGeometry(BLOCK.radius, BLOCK.radius, BLOCK.height, this.radiusSegments);	
		//this.colors = ['pink', 'cyan', 'yellowBrown', 'purple', 'orange'];
		//this.material = new THREE.MeshLambertMaterial({ color: COLORS[this.colors[Math.floor(5 * Math.random())]], shading: THREE.FlatShading });
		//this.obj = new THREE.Mesh(this.geometry, this.material);
		//this.obj.castShadow = true;
		this.radius = _config.BLOCK.radius;
		this.status = 'stop';
		this.scale = 1;
		this.type = 'green';
		this.types = ['green', 'black', 'gray'];
		this.radiusScale = 1;
		//this.obj.castShadow = true;
		//this.obj.receiveShadow = true;
		//if (this.radiusSegments === 4) this.obj.rotation.y = Math.PI / 4;
		//this.obj.scale.set(this.radiusScale, 1, this.radiusScale);
		this.obj = new THREE.Object3D();
		this.obj.name = 'block';
		this.body = new THREE.Object3D();
		if (type <= 8 || type == 27) {
			this.greenMaterial = new THREE.MeshLambertMaterial({ color: colors.green });
			this.whiteMaterial = new THREE.MeshLambertMaterial({ color: colors.white });
		}
		this.shadowWidth = 11;
		if (type == 2 || type == 7) {
			this.shadow = new THREE.Mesh(shadowGeometry, _config.desk_shadow);
			this.shadow.position.set(0, -_config.BLOCK.height / 2 - 0.001 * type, -4.5);
			this.shadow.scale.y = 1.2;
		} else if (type == 3 || type == 21 || type == 27 || type == 28 || type == 29 || type == 31) {
			this.shadow = new THREE.Mesh(shadowGeometry, _config.cylinder_shadow);
			this.shadow.position.set(-0.1, -_config.BLOCK.height / 2 - 0.001 * type, -2.8);
			this.shadow.scale.y = 1.4;
			this.shadow.scale.x = 1;
		} else {
			this.shadow = new THREE.Mesh(shadowGeometry, _config.shadow);
			this.shadow.position.set(-0.74, -_config.BLOCK.height / 2 - 0.001 * type, -2.73);
			this.shadow.scale.y = 1.4;
		}
		this.shadow.rotation.x = -Math.PI / 2;
		this.order = type;
		this.radiusSegments = 4;
		this.height = _config.BLOCK.height;
		this.canChange = true;
		if (type == 0) {
			var materials = [this.greenMaterial, this.whiteMaterial];
			var totalGeometry = new THREE.Geometry();
			var innerHeight = 3;
			var outerHeight = (_config.BLOCK.height - innerHeight) / 2;
			var outerGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, outerHeight, _config.BLOCK.radius * 2);
			this.geometry = outerGeometry;
			var innerGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, innerHeight, _config.BLOCK.radius * 2);
			this.merge(totalGeometry, outerGeometry, 0, [{ x: 0, y: -innerHeight / 2 - outerHeight / 2, z: 0 }, { x: 0, y: innerHeight / 2 + outerHeight / 2, z: 0 }]);
			this.merge(totalGeometry, innerGeometry, 1, [{ x: 0, y: 0, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 1) {
			var materials = [this.greenMaterial, this.whiteMaterial];
			var totalGeometry = new THREE.Geometry();
			var bottomHeight = _config.BLOCK.height / 5;
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, bottomHeight, _config.BLOCK.radius * 2);
			this.geometry = geometry;
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }, { x: 0, y: -2 * bottomHeight, z: 0 }, { x: 0, y: 2 * bottomHeight, z: 0 }]);
			this.merge(totalGeometry, geometry, 1, [{ x: 0, y: -bottomHeight, z: 0 }, { x: 0, y: bottomHeight, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 2) {
			var materials = [this.greenMaterial, this.whiteMaterial];
			var totalGeometry = new THREE.Geometry();
			this.radiusSegments = 50;
			var bottomHeight = 5;
			var topHeight = _config.BLOCK.height - bottomHeight;
			var bottomGeometry = new THREE.CylinderGeometry(_config.BLOCK.radius - 4, _config.BLOCK.radius - 2, bottomHeight, 50);
			var topGeometry = new THREE.CylinderGeometry(_config.BLOCK.radius, _config.BLOCK.radius, topHeight, 50);
			this.geometry = topGeometry;
			this.merge(totalGeometry, bottomGeometry, 1, [{ x: 0, y: -(_config.BLOCK.height - bottomHeight) / 2, z: 0 }]);
			this.merge(totalGeometry, topGeometry, 0, [{ x: 0, y: bottomHeight + topHeight / 2 - _config.BLOCK.height / 2, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 3) {
			this.radiusSegments = 50;
			this.middleLightGreenMaterial = new THREE.MeshLambertMaterial({ color: colors.middleLightGreen });
			var materials = [this.greenMaterial, this.whiteMaterial, this.middleLightGreenMaterial];
			var totalGeometry = new THREE.Geometry();
			var bottomHeight = 5;
			var topHeight = _config.BLOCK.height - bottomHeight;
			var bottomGeometry = new THREE.CylinderGeometry(_config.BLOCK.radius, _config.BLOCK.radius, bottomHeight, 50);
			var topGeometry = new THREE.CylinderGeometry(_config.BLOCK.radius, _config.BLOCK.radius, topHeight, 50);
			this.geometry = topGeometry;
			var ringGeometry = new THREE.RingGeometry(_config.BLOCK.radius * 0.6, _config.BLOCK.radius * 0.8, 30);
			ringGeometry.rotateX(-Math.PI / 2);
			this.merge(totalGeometry, bottomGeometry, 1, [{ x: 0, y: -(_config.BLOCK.height - bottomHeight) / 2, z: 0 }]);
			this.merge(totalGeometry, topGeometry, 0, [{ x: 0, y: bottomHeight + topHeight / 2 - _config.BLOCK.height / 2, z: 0 }]);
			this.merge(totalGeometry, ringGeometry, 2, [{ x: 0, y: _config.BLOCK.height / 2 + 0.01, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 4) {
			var materials = [this.greenMaterial, this.whiteMaterial];
			var totalGeometry = new THREE.Geometry();
			var geometry = staticGeometry;
			this.geometry = geometry;
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			var ringGeometry = new THREE.RingGeometry(1, 2, 30, 1);
			this.merge(totalGeometry, ringGeometry, 1, [{ x: 0, y: 0, z: _config.BLOCK.radius + 0.01 }]);
			ringGeometry.rotateY(-Math.PI / 2);
			this.merge(totalGeometry, ringGeometry, 1, [{ x: -_config.BLOCK.radius - 0.01, y: 0, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 5) {
			var materials = [this.greenMaterial, this.whiteMaterial];
			var totalGeometry = new THREE.Geometry();
			var innerHeight = 3;
			var outerHeight = (_config.BLOCK.height - innerHeight) / 2;
			var outerGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, outerHeight, _config.BLOCK.radius * 2);
			var innerGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, innerHeight, _config.BLOCK.radius * 2);
			this.merge(totalGeometry, outerGeometry, 0, [{ x: 0, y: -innerHeight / 2 - outerHeight / 2, z: 0 }, { x: 0, y: innerHeight / 2 + outerHeight / 2, z: 0 }]);
			this.merge(totalGeometry, innerGeometry, 1, [{ x: 0, y: 0, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 6) {
			var materials = [this.greenMaterial, this.whiteMaterial];
			var totalGeometry = new THREE.Geometry();
			var innerHeight = 3;
			var outerHeight = (_config.BLOCK.height - innerHeight) / 2;
			var outerGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, outerHeight, _config.BLOCK.radius * 2);
			var innerGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, innerHeight, _config.BLOCK.radius * 2);
			this.merge(totalGeometry, outerGeometry, 0, [{ x: 0, y: -innerHeight / 2 - outerHeight / 2, z: 0 }, { x: 0, y: innerHeight / 2 + outerHeight / 2, z: 0 }]);
			this.merge(totalGeometry, innerGeometry, 1, [{ x: 0, y: 0, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 7) {
			var materials = [this.greenMaterial, this.whiteMaterial];
			var totalGeometry = new THREE.Geometry();
			this.radiusSegments = 50;
			var bottomHeight = 5;
			var topHeight = _config.BLOCK.height - bottomHeight;
			var bottomGeometry = new THREE.CylinderGeometry(_config.BLOCK.radius - 4, _config.BLOCK.radius - 2, bottomHeight, 50);
			var topGeometry = new THREE.CylinderGeometry(_config.BLOCK.radius, _config.BLOCK.radius, topHeight, 50);
			this.geometry = topGeometry;
			this.merge(totalGeometry, bottomGeometry, 1, [{ x: 0, y: -(_config.BLOCK.height - bottomHeight) / 2, z: 0 }]);
			this.merge(totalGeometry, topGeometry, 0, [{ x: 0, y: bottomHeight + topHeight / 2 - _config.BLOCK.height / 2, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 8) {
			var materials = [this.greenMaterial, this.whiteMaterial];
			var totalGeometry = new THREE.Geometry();
			var bottomHeight = _config.BLOCK.height / 5;
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, bottomHeight, _config.BLOCK.radius * 2);
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }, { x: 0, y: -2 * bottomHeight, z: 0 }, { x: 0, y: 2 * bottomHeight, z: 0 }]);
			this.merge(totalGeometry, geometry, 1, [{ x: 0, y: -bottomHeight, z: 0 }, { x: 0, y: bottomHeight, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 9) {
			var pinkMaterial = new THREE.MeshLambertMaterial({ color: 0xed7c38 });
			var planeMaterial = new THREE.MeshBasicMaterial({
				map: _config.loader.load('res/game.png'),
				transparent: true
			});
			var materials = [pinkMaterial, planeMaterial];
			var totalGeometry = new THREE.Geometry();
			var geometry = staticGeometry;
			this.geometry = geometry;
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			this.merge(totalGeometry, new THREE.PlaneGeometry(5, 5), 1, [{ x: 0, y: 0.1, z: _config.BLOCK.radius + 0.01 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 10) {
			var yellowMaterial = new THREE.MeshLambertMaterial({ color: 0xfbe65e });
			var planeMaterial = new THREE.MeshBasicMaterial({
				map: _config.loader.load('res/emotion.png'),
				transparent: true
			});
			var materials = [yellowMaterial, planeMaterial];
			var totalGeometry = new THREE.Geometry();
			var geometry = staticGeometry;
			var faceGeometry = new THREE.CylinderGeometry(2, 2, 1, 50);
			var planeGeometry = new THREE.PlaneGeometry(1.5, 1.5);
			this.geometry = geometry;
			//var yellowLambertMaterial = new THREE.MeshLambertMaterial({ color: 0xfbe65e });
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			faceGeometry.rotateX(Math.PI / 2);
			this.merge(totalGeometry, faceGeometry, 0, [{ x: 0, y: 0, z: _config.BLOCK.radius + 0.51 }]);
			faceGeometry.rotateZ(Math.PI / 2);
			faceGeometry.rotateY(Math.PI / 2);
			this.merge(totalGeometry, faceGeometry, 0, [{ x: -_config.BLOCK.radius - 0.51, y: 0, z: 0 }]);
			this.merge(totalGeometry, planeGeometry, 1, [{ x: 0, y: 0, z: _config.BLOCK.radius + 1.02 }]);
			planeGeometry.rotateY(-Math.PI / 2);
			this.merge(totalGeometry, planeGeometry, 1, [{ x: -_config.BLOCK.radius - 1.02, y: 0, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 11) {
			var geometry = staticGeometry;
			var earGeometry = new THREE.BoxGeometry(3, 2, 4);
			this.geometry = geometry;
			var greenMaterial = new THREE.MeshLambertMaterial({ color: 0xb4e842 });
			var planeMaterial = new THREE.MeshBasicMaterial({
				map: _config.loader.load('res/green_face.png'),
				transparent: true
			});
			var planeGeometry = new THREE.PlaneGeometry(6, 3);
			var materials = [greenMaterial, planeMaterial];
			var totalGeometry = new THREE.Geometry();
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			this.merge(totalGeometry, planeGeometry, 1, [{ x: 0.5, y: -1, z: _config.BLOCK.radius + 0.01 }]);
			earGeometry.rotateZ(Math.PI / 5);
			this.merge(totalGeometry, earGeometry, 0, [{ x: -_config.BLOCK.radius - 1, y: 1, z: 2.5 }]);
			earGeometry.rotateZ(-2 * Math.PI / 5);
			this.merge(totalGeometry, earGeometry, 0, [{ x: _config.BLOCK.radius, y: 1, z: 2.5 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 12) {
			var geometry = staticGeometry;
			var earGeometry = new THREE.BoxGeometry(3, 2, 4);
			this.geometry = geometry;
			var greenMaterial = new THREE.MeshLambertMaterial({ color: 0xf2f2f2 });
			var planeMaterial = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/white_face.png')
			});
			var planeGeometry = new THREE.PlaneGeometry(6, 3);
			var materials = [greenMaterial, planeMaterial];
			var totalGeometry = new THREE.Geometry();
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			this.merge(totalGeometry, planeGeometry, 1, [{ x: 0.5, y: -1, z: _config.BLOCK.radius + 0.01 }]);
			earGeometry.rotateZ(Math.PI / 5);
			this.merge(totalGeometry, earGeometry, 0, [{ x: -_config.BLOCK.radius - 1, y: 1, z: 2.5 }]);
			earGeometry.rotateZ(-2 * Math.PI / 5);
			this.merge(totalGeometry, earGeometry, 0, [{ x: _config.BLOCK.radius, y: 1, z: 2.5 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 13) {
			var geometry = staticGeometry;
			this.geometry = geometry;
			var planeMaterial = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/money.png')
			});
			var planeGeometry = new THREE.PlaneGeometry(3, 3);
			var materials = [planeMaterial];
			var totalGeometry = new THREE.Geometry();
			this.mapUv(64, 64, geometry, 1, 2, 2, 4, 4);
			this.mapUv(64, 64, geometry, 2, 2, 2, 4, 4);
			this.mapUv(64, 64, geometry, 4, 2, 2, 4, 4);
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			this.merge(totalGeometry, planeGeometry, 0, [{ x: 0, y: 0, z: _config.BLOCK.radius + 0.01 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 14) {
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, this.height, _config.BLOCK.radius * 2);
			this.geometry = geometry;
			var material = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/tit.png')
			});
			this.mapUv(310, 310, geometry, 1, 0, 0, 200, 110);
			this.mapUv(310, 310, geometry, 2, 0, 110, 200, 310); //top
			this.mapUv(310, 310, geometry, 4, 200, 110, 310, 310); //right

			this.hitObj = new THREE.Mesh(geometry, material);

			// var materials = [material,  new THREE.ShadowMaterial({ transparent: true, color: 0x000000, opacity: 0.3, })];
			// var totalGeometry = new THREE.Geometry();
			// this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			// var planeGeometry = new THREE.PlaneGeometry(BLOCK.radius * 2, BLOCK.radius * 2);
			// planeGeometry.rotateX(-Math.PI / 2);
			// this.merge(totalGeometry, planeGeometry, 1, [{ x: 0, y: BLOCK.height / 2 + 0.1, z: 0 }]);
			// this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 15) {
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, this.height, _config.BLOCK.radius * 2);
			this.map = _config.loader.load('res/bag.png');
			var material = new THREE.MeshLambertMaterial({
				map: this.map
			});
			this.glowMap = _config.loader.load('res/glow_bag.png');
			this.hitObj = new THREE.Mesh(geometry, material);
		} else if (type == 16) {
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, this.height, _config.BLOCK.radius * 2);
			var material = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/dict.png')
			});
			this.mapUv(428, 428, geometry, 1, 0, 148, 280, 0);
			this.mapUv(428, 428, geometry, 2, 0, 148, 280, 428); //top
			this.mapUv(428, 428, geometry, 4, 280, 148, 428, 428); //right
			this.hitObj = new THREE.Mesh(geometry, material);
		} else if (type == 17) {
			this.height /= 3;
			var topMaterial = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/box_top.png')
			});
			var bottomMaterial = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/box_bottom.png')
			});
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, this.height, _config.BLOCK.radius * 2);
			this.geometry = geometry;
			var middleGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, this.height, _config.BLOCK.radius * 2);
			var materials = [topMaterial, bottomMaterial];
			var totalGeometry = new THREE.Geometry();
			this.mapUv(198, 198, geometry, 1, 0, 0, 148, 50);
			this.mapUv(198, 198, geometry, 2, 0, 50, 148, 198); //top
			this.mapUv(198, 198, geometry, 4, 148, 50, 198, 198); //right

			this.mapUv(444, 50, middleGeometry, 4, 148, 0, 296, 50, true);
			this.mapUv(444, 50, middleGeometry, 1, 0, 0, 148, 50);
			this.mapUv(444, 50, middleGeometry, 2, 0, 0, 1, 1); //top
			this.mapUv(444, 50, middleGeometry, 0, 296, 50, 444, 0);
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			this.merge(totalGeometry, middleGeometry, 1, [{ x: 0, y: -2 * this.height, z: 0 }]);

			var middleMaterial = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/box_middle.png')
			});
			this.middle = new THREE.Mesh(middleGeometry, middleMaterial);
			this.middle.position.y = -this.height;
			this.body.add(this.middle);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 18) {
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, this.height, _config.BLOCK.radius * 2);
			var material = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/express.png')
			});
			this.mapUv(428, 428, geometry, 1, 0, 0, 280, 148);
			this.mapUv(428, 428, geometry, 2, 0, 148, 280, 428); //top
			this.mapUv(428, 428, geometry, 4, 280, 148, 428, 428); //right
			this.hitObj = new THREE.Mesh(geometry, material);
		} else if (type == 19) {
			this.min = 0.9;
			this.height = _config.BLOCK.height / 21 * 4;
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, this.height + 0.1, _config.BLOCK.radius * 2);
			this.geometry = geometry;
			var material = new THREE.MeshLambertMaterial({
				color: 0xffffff,
				transparent: true,
				opacity: 0.3
			});
			var bottomGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2.05, _config.BLOCK.height / 21 * 17, _config.BLOCK.radius * 2.05);
			var bottomMaterial = new THREE.MeshBasicMaterial({
				map: _config.loader.load('res/sing.png')
			});
			var materials = [material, bottomMaterial];
			var totalGeometry = new THREE.Geometry();
			this.mapUv(416, 416, bottomGeometry, 1, 0, 0, 256, 160);
			this.mapUv(416, 416, bottomGeometry, 2, 0, 160, 256, 416); //top
			this.mapUv(416, 416, bottomGeometry, 4, 256, 160, 416, 416); //right
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			this.merge(totalGeometry, bottomGeometry, 1, [{ x: 0, y: -_config.BLOCK.height / 21 * 10.5, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
			this.record = new THREE.Object3D();

			this.record.add(new THREE.Mesh(new THREE.CylinderGeometry(_config.BLOCK.radius * 0.9, _config.BLOCK.radius * 0.9, 0.4, 50), new THREE.MeshBasicMaterial({ color: 0x2c2c2c })));
			var planeGeometry = new THREE.CircleGeometry(_config.BLOCK.radius * 0.9, 40);
			var planeMaterial = new THREE.MeshBasicMaterial({ map: _config.loader.load('res/record.png') });
			var plane = new THREE.Mesh(planeGeometry, planeMaterial);
			plane.rotation.x = -Math.PI / 2;
			plane.position.y = 0.26;
			this.record.add(plane);
			this.body.add(this.record);
			var planeGeometry = new THREE.PlaneGeometry(2, 2);
			this.musicIcon = new THREE.Mesh(planeGeometry, new THREE.MeshBasicMaterial({ map: _config.loader.load('res/music_icon.png'), transparent: true }));
			this.musicIcon.position.set(0, 0, 0);
			this.musicIcon.rotation.y = -Math.PI / 4;
			this.musicIcon.rotation.x = -Math.PI / 5;
			this.musicIcon.rotation.z = -Math.PI / 5;
			this.musicIcon.visible = false;
			this.secondMusicIcon = new THREE.Mesh(planeGeometry, new THREE.MeshBasicMaterial({ map: _config.loader.load('res/music_icon_two.png'), transparent: true }));
			this.secondMusicIcon.rotation.y = -Math.PI / 4;
			this.secondMusicIcon.rotation.x = -Math.PI / 5;
			this.secondMusicIcon.rotation.z = -Math.PI / 5;
			this.secondMusicIcon.visible = false;
			this.icons = [];
			this.icons.push(this.musicIcon, this.secondMusicIcon);
			for (var i = 0; i < 2; ++i) {
				this.body.add(this.icons[i]);
			}
		} else if (type == 20) {
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, this.height, _config.BLOCK.radius * 2 / 38 * 48);
			this.geometry = geometry;
			this.shadow.scale.set(1, 61 / 38, 48 / 38);
			//this.shadow.position.z += ;
			var material = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/disk.png')
			});
			var darkMaterial = new THREE.MeshBasicMaterial({ map: _config.loader.load('res/disk_dark.png'), transparent: true });
			var planeGeometry = new THREE.PlaneGeometry(3, 3);
			var materials = [darkMaterial, material];
			var totalGeometry = new THREE.Geometry();
			this.mapUv(236, 300, geometry, 1, 0, 250, 10, 260);
			this.mapUv(236, 300, geometry, 2, 0, 300, 236, 0); //top
			this.mapUv(236, 300, geometry, 4, 0, 250, 10, 260); //right
			this.merge(totalGeometry, geometry, 1, [{ x: 0, y: 0, z: 0 }]);
			this.merge(totalGeometry, planeGeometry, 0, [{ x: 3.5, y: 0.5, z: _config.BLOCK.radius / 38 * 48 + 0.01 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
			this.plane = new THREE.Mesh(planeGeometry, new THREE.MeshBasicMaterial({ map: _config.loader.load('res/disk_light.png'), transparent: true }));
			this.plane.position.set(3.5, 0.5, _config.BLOCK.radius / 38 * 48 + 0.03);
			this.plane.updateMatrix();
			this.plane.matrixAutoUpdate = false;
			this.body.add(this.plane);
			this.timer = setInterval(function () {
				_this.plane.visible = !_this.plane.visible;
			}, 1000);
		} else if (type == 21) {
			this.radiusSegments = 50;
			this.min = 0.8;
			this.height = _config.BLOCK.height / 21 * 4;
			var geometry = new THREE.CylinderGeometry(_config.BLOCK.radius * 0.7, _config.BLOCK.radius * 0.8, this.height, 50);
			this.geometry = geometry;
			var planeGeometry = new THREE.CircleGeometry(_config.BLOCK.radius * 0.7, 50);
			var bottomGeometry = new THREE.CylinderGeometry(_config.BLOCK.radius * 0.7, _config.BLOCK.radius * 0.5, _config.BLOCK.height / 21 * 17, 50);
			var material = new THREE.MeshBasicMaterial({ color: 0x4d4d4d });
			var planeMaterial = new THREE.MeshLambertMaterial({ map: _config.loader.load('res/westore_desk.png') });
			var bottomMaterial = new THREE.MeshBasicMaterial({ map: _config.loader.load('res/westore.png') });
			this.shadow.scale.set(0.55, 0.9, 0.7);
			var materials = [material, bottomMaterial, planeMaterial];
			var totalGeometry = new THREE.Geometry();
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			bottomGeometry.rotateY(2.3);
			this.merge(totalGeometry, bottomGeometry, 1, [{ x: 0, y: -_config.BLOCK.height / 21 * 10.5, z: 0 }]);
			planeGeometry.rotateX(-Math.PI / 2);
			planeGeometry.rotateY(-0.7);
			this.merge(totalGeometry, planeGeometry, 2, [{ x: 0, y: this.height / 2 + 0.01, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 22) {
			this.height = _config.BLOCK.height / 21 * 6;
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2.1, this.height, _config.BLOCK.radius * 2.1);
			this.geometry = geometry;
			var material = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/gift.png')
			});
			var bottomGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, _config.BLOCK.height / 21 * 15, _config.BLOCK.radius * 2);
			var bottomMaterial = new THREE.MeshLambertMaterial({
				color: 0xb193f5
			});
			this.mapUv(300, 370, geometry, 1, 0, 0, 300, 70);
			this.mapUv(300, 370, geometry, 2, 0, 70, 300, 370); //top
			this.mapUv(300, 370, geometry, 4, 0, 0, 300, 70, true); //right
			var materials = [material, bottomMaterial];
			var totalGeometry = new THREE.Geometry();
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			this.merge(totalGeometry, bottomGeometry, 1, [{ x: 0, y: -_config.BLOCK.height / 21 * 10.5, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 23) {
			this.height = _config.BLOCK.height / 21 * 5;
			var geometry = new THREE.Geometry();
			var deskGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, this.height, _config.BLOCK.radius * 2 / 38 * 40);
			geometry.merge(deskGeometry);
			this.shadow.scale.set(1, 48 / 38, 48 / 38);
			var legGeometry = new THREE.BoxGeometry(1.5, 3.5, 1.5);
			legGeometry.rotateZ(-0.3);
			legGeometry.vertices[7].y -= 0.4;
			legGeometry.vertices[6].y -= 0.4;
			legGeometry.translate(-4, -3, -3.5);
			geometry.merge(legGeometry);
			legGeometry.vertices[6].y += 0.5;
			legGeometry.translate(0, 0, 7);
			legGeometry.rotateX(-0.2);
			geometry.merge(legGeometry);
			legGeometry.vertices[7].y += 0.4;
			legGeometry.translate(5, -1, 0);
			legGeometry.rotateZ(0.4);
			geometry.merge(legGeometry);
			var material = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/stool.png')
			});
			this.hitObj = new THREE.Mesh(geometry, material);
			this.shadow = new THREE.Mesh(new THREE.PlaneGeometry(this.shadowWidth, this.shadowWidth), new THREE.MeshBasicMaterial({ map: _config.loader.load('res/stool_shadow.png'), transparent: true, alphaTest: 0.01 }));
			this.shadow.position.set(-0.76, -_config.BLOCK.height / 2 - 0.001 * type, -3.6);
			this.shadow.scale.y = 1.4;
			this.shadow.scale.x = 0.9;
			this.shadow.rotation.x = -Math.PI / 2;
		} else if (type == 24) {
			this.height = _config.BLOCK.height / 21 * 6;
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2 / 38 * 45, this.height, _config.BLOCK.radius * 2 / 38 * 45);
			this.geometry = geometry;
			var bottomGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2 / 38 * 40, _config.BLOCK.height / 21 * 15, _config.BLOCK.radius * 2 / 38 * 40);
			this.shadow.scale.set(40 / 38, 1.4, 1);
			var material = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/store_top.png')
			});
			var bottomMaterial = new THREE.MeshBasicMaterial({
				map: _config.loader.load('res/store_bottom.png'),
				transparent: true
			});
			var planeMaterial = new THREE.MeshBasicMaterial({ map: _config.loader.load('res/indoor.png'), transparent: true });
			var materials = [material, bottomMaterial, planeMaterial];
			var planeGeometry = new THREE.PlaneGeometry(3.1, 3.1);
			var totalGeometry = new THREE.Geometry();
			this.mapUv(340, 340, geometry, 1, 0, 0, 280, 60);
			this.mapUv(340, 340, geometry, 2, 0, 60, 280, 340); //top
			this.mapUv(340, 340, geometry, 4, 280, 60, 340, 340); //right
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			this.mapUv(434, 164, bottomGeometry, 1, 0, 0, 217, 164);
			this.mapUv(434, 164, bottomGeometry, 4, 217, 0, 434, 164, true); //right
			this.merge(totalGeometry, bottomGeometry, 1, [{ x: 0, y: -_config.BLOCK.height / 21 * 10.5, z: 0 }]);
			planeGeometry.rotateY(-Math.PI / 2);
			this.merge(totalGeometry, planeGeometry, 2, [{ x: -_config.BLOCK.radius / 38 * 40 - 0.01, y: -3.3, z: -2.5 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
			var doorGeometry = new THREE.PlaneGeometry(1.55, 3.1);
			this.door = new THREE.Mesh(doorGeometry, new THREE.MeshBasicMaterial({ map: _config.loader.load('res/door.png'), transparent: true }));
			this.door.rotation.y = -Math.PI / 2;
			this.door.position.set(-_config.BLOCK.radius / 38 * 40 - 0.02, -3.3, -3.3);
			this.body.add(this.door);
			this.secondDoor = new THREE.Mesh(doorGeometry, new THREE.MeshBasicMaterial({ map: _config.loader.load('res/second_door.png'), transparent: true }));
			this.secondDoor.rotation.y = -Math.PI / 2;
			this.secondDoor.position.set(-_config.BLOCK.radius / 38 * 40 - 0.02, -3.3, -1.7);
			this.body.add(this.secondDoor);
			// this.shadow.position.x += 0.6;
			// this.shadow.position.z += 1;
		} else if (type == 25) {
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, this.height, _config.BLOCK.radius * 2);
			this.geometry = geometry;
			var material = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/clock.png')
			});
			this.mapUv(320, 200, geometry, 1, 0, 0, 5, 5);
			this.mapUv(320, 200, geometry, 2, 0, 0, 5, 5); //top
			this.mapUv(320, 200, geometry, 4, 0, 200, 320, 0, true); //right
			var buttonMaterial = stripeMaterial;
			var buttonGeometry = new THREE.CylinderGeometry(1, 1, 1, 30);
			var materials = [material, buttonMaterial];
			var totalGeometry = new THREE.Geometry();
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			buttonGeometry.rotateZ(Math.PI / 2);
			this.merge(totalGeometry, buttonGeometry, 1, [{ x: -_config.BLOCK.radius - 0.5, y: 0, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
			this.plane = new THREE.Mesh(new THREE.PlaneGeometry(3, 3), new THREE.MeshBasicMaterial({ map: _config.loader.load('res/point.png'), transparent: true }));
			this.plane.position.set(0, 0, _config.BLOCK.radius + 0.04);
			this.body.add(this.plane);
			this.timer = setInterval(function () {
				_this.plane.visible = !_this.plane.visible;
			}, 1000);
			this.numbers = [];
			var numberGeometry = new THREE.PlaneGeometry(3, 3);
			for (var i = 0; i < 10; ++i) {
				var clockNumberMaterial = new THREE.MeshBasicMaterial({ map: _config.loader.load('res/' + i + '.png'), alphaTest: 0.5 });
				var arr = [];
				for (var j = 0; j < 4; ++j) {
					var time = new THREE.Mesh(numberGeometry, clockNumberMaterial);
					time.position.z = _config.BLOCK.radius + 0.01;
					time.visible = false;
					arr.push(time);
					this.body.add(time);
				}
				this.numbers.push(arr);
			}
			var date = new Date();
			var hour = ('0' + date.getHours()).slice(-2);
			var minute = ('0' + date.getMinutes()).slice(-2);
			this.numbers[hour[0]][0].position.x = -3.2 * this.radiusScale;
			this.numbers[hour[0]][0].visible = true;
			this.numbers[hour[1]][1].position.x = -1.3 * this.radiusScale;
			this.numbers[hour[1]][1].visible = true;
			this.numbers[minute[0]][2].position.x = 1.3 * this.radiusScale;
			this.numbers[minute[0]][2].visible = true;
			this.numbers[minute[1]][3].position.x = 3.2 * this.radiusScale;
			this.numbers[minute[1]][3].visible = true;
		} else if (type == 26) {
			var geometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, this.height, _config.BLOCK.radius * 2);
			var material = new THREE.MeshLambertMaterial({
				map: _config.loader.load('res/well.png')
			});
			this.mapUv(280, 428, geometry, 1, 0, 0, 280, 148);
			this.mapUv(280, 428, geometry, 2, 0, 148, 280, 428); //top
			this.mapUv(280, 428, geometry, 4, 0, 0, 280, 148, true); //right
			this.hitObj = new THREE.Mesh(geometry, material);
		} else if (type == 27) {
			this.radiusSegments = 50;
			var geometry = new THREE.CylinderGeometry(_config.BLOCK.radius * 2 / 38 * 25, _config.BLOCK.radius * 2 / 38 * 25, this.height, 50);
			this.geometry = geometry;
			this.shadow.scale.set(50 / 38, 50 / 38, 50 / 38);
			var material = new THREE.MeshBasicMaterial({
				map: _config.loader.load('res/golf_bottom.png')
			});
			var planeGeometry = new THREE.CircleGeometry(_config.BLOCK.radius * 2 / 38 * 25 + 0.01, 30);
			var planeMaterial = new customMaterial({ map: _config.loader.load('res/golf_top.png') });
			var totalGeometry = new THREE.Geometry();
			var materials = [material, planeMaterial];
			geometry.rotateY(3);
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			planeGeometry.rotateX(-Math.PI / 2);
			planeGeometry.rotateY(-0.7);
			this.merge(totalGeometry, planeGeometry, 1, [{ x: 0, y: this.height / 2 + 0.01, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
			this.sphere = new THREE.Mesh(new THREE.SphereGeometry(0.6, 10, 10), this.whiteMaterial);
			this.sphere.position.set(-8, -1, -1.5);
			this.obj.add(this.sphere);
		} else if (type == 28) {
			this.radiusSegments = 50;
			var geometry = new THREE.CylinderGeometry(_config.BLOCK.radius * 2 / 38 * 15, _config.BLOCK.radius * 2 / 38 * 15, this.height, 50);
			this.geometry = geometry;
			this.shadow.scale.set(30 / 38, 30 / 38, 30 / 38);
			var material = new THREE.MeshBasicMaterial({
				map: _config.loader.load('res/paper_bottom.png')
			});
			var planeGeometry = new THREE.CircleGeometry(_config.BLOCK.radius * 2 / 38 * 15 + 0.01, 30);
			var planeMaterial = new customMaterial({ map: _config.loader.load('res/paper_top.png') });
			var totalGeometry = new THREE.Geometry();
			var materials = [material, planeMaterial];
			geometry.rotateY(4);
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			planeGeometry.rotateX(-Math.PI / 2);
			planeGeometry.rotateY(-0.7);
			this.merge(totalGeometry, planeGeometry, 1, [{ x: 0, y: this.height / 2 + 0.01, z: 0 }]);
			this.shadow.scale.y = 1.1;
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
		} else if (type == 29) {
			this.radiusSegments = 50;
			this.min = 0.8;
			this.height = _config.BLOCK.height / 21 * 4;
			var geometry = new THREE.CylinderGeometry(_config.BLOCK.radius * 0.4, _config.BLOCK.radius * 0.4, this.height, 50);
			this.geometry = geometry;
			var material = stripeMaterial;
			var planeGeometry = new THREE.CircleGeometry(_config.BLOCK.radius * 0.4, 50);
			var planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
			var middleGeometry = new THREE.CylinderGeometry(_config.BLOCK.radius * 0.4, _config.BLOCK.radius * 0.5, _config.BLOCK.height / 21 * 1, 50);
			var bottomGeometry = new THREE.CylinderGeometry(_config.BLOCK.radius * 0.5, _config.BLOCK.radius * 0.5, _config.BLOCK.height / 21 * 16, 50);
			var bottomMaterial = new THREE.MeshBasicMaterial({ map: _config.loader.load('res/medicine.png') });
			var totalGeometry = new THREE.Geometry();
			var materials = [material, planeMaterial, bottomMaterial];
			this.merge(totalGeometry, geometry, 0, [{ x: 0, y: 0, z: 0 }]);
			planeGeometry.rotateX(-Math.PI / 2);
			this.merge(totalGeometry, planeGeometry, 1, [{ x: 0, y: this.height / 2 + 0.01, z: 0 }]);
			this.merge(totalGeometry, middleGeometry, 1, [{ x: 0, y: -_config.BLOCK.height / 21 * 2.5, z: 0 }]);
			bottomGeometry.rotateY(2.3);
			this.merge(totalGeometry, bottomGeometry, 2, [{ x: 0, y: -_config.BLOCK.height / 21 * 11, z: 0 }]);
			this.hitObj = new THREE.Mesh(totalGeometry, materials);
			this.shadow.scale.set(0.55, 0.9, 0.7);

			// } else if (type == 30) {
			// 	this.canChange = false;
			// 	this.height = 0;
			// 	this.blackMaterial = new THREE.MeshLambertMaterial({ color: 0x4d4d4d, side: THREE.DoubleSide });
			// 	var radius = BLOCK.height;
			// 	var width = radius * 2;
			// 	this.radiusSegments = 4;
			// 	var body = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, width, 32, 1, false, 0, Math.PI), new THREE.MeshLambertMaterial({ color: 0x679ae4 }));
			// 	body.rotation.z = -Math.PI / 2;
			// 	this.body.add(body);
			// 	this.hitObj = new THREE.Mesh(new THREE.BoxGeometry(width, 0.01, radius * 2), new THREE.MeshLambertMaterial({ color: 0x679ae2 }));
			// 	//desk.position.z = radius;
			// 	//desk.rotation.x = -Math.PI / 2;
			// 	var small = new THREE.Mesh(new THREE.CylinderGeometry(radius / 3, radius / 3, 0.5, 32, 1, false, 0, Math.PI), new THREE.MeshLambertMaterial({ color: 0xffd67e }));
			// 	small.rotation.z = -Math.PI / 2;
			// 	small.position.x = -width / 2 - 0.25;
			// 	small.position.y -= 1;
			// 	this.body.add(small);
			// 	var smallDesk = new THREE.Mesh(new THREE.PlaneGeometry(0.5, radius * 2 / 3), new THREE.MeshLambertMaterial({ color: 0xffd67e }));
			// 	smallDesk.rotation.x = -Math.PI / 2;
			// 	smallDesk.position.x = -width / 2 - 0.25;
			// 	smallDesk.position.y -= 1;
			// 	this.body.add(smallDesk);
			// } else if (type == 31) {
			// 	this.height = 0;
			// 	this.radiusSegments = 50;
			// 	var radius = BLOCK.radius;
			// 	var width = BLOCK.width;
			// 	this.hitObj = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, 0.5, 50),  new THREE.MeshLambertMaterial({ color: 0xffd67e }));
			// 	this.hitObj.receiveShadow = true;
			// 	this.body.add(this.hitObj);
			// 	var redSphere = new THREE.Mesh(new THREE.CylinderGeometry( radius + 0.5, radius + 1, 1, 50), new THREE.MeshLambertMaterial({ color: 0xdd5858 }));
			// 	redSphere.position.y = -1;
			// 	this.body.add(redSphere);
			// 	var middle = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 2, 50), new THREE.MeshLambertMaterial({ color: 0x4d4d4d }));
			// 	middle.position.y = -3.5;
			// 	this.body.add(middle);
			// 	this.bottomSphere = this.hitObj.clone();
			// 	this.bottomSphere.scale.set(0.7, 0.7, 0.7);
			// 	this.bottomSphere.position.y = -6;
			// 	this.body.add(this.bottomSphere);
			// 	var body = new THREE.Mesh(new THREE.SphereGeometry(3, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshLambertMaterial({ color: 0x4d4d4d }));
			// 	body.rotation.x = Math.PI;
			// 	body.position.y = -6;
			// 	this.body.position.y = BLOCK.height / 2 - 0.5;
			// 	this.body.add(body);
		} else if (type == -1) {
			var color = [0xee6060, 0xe4965e, 0xefbf57, 0x8ab34e, 0x71b4c4, 0x637cbd, 0xa461d4];
			var geometry = biggerGeometry;
			var material = new THREE.MeshLambertMaterial({ color: color[number], transparent: true });
			this.hitObj = new THREE.Mesh(geometry, material);
			var grayGeometry = new THREE.BoxGeometry(_config.BLOCK.radius * 2, _config.BLOCK.height, _config.BLOCK.radius * 2);
			this.mapUv(100, 88, grayGeometry, 2, 0, 0, 5, 5);
			var gray = new THREE.Mesh(grayGeometry, _config.grayMaterial);
			if (number == 0) gray.receiveShadow = true;
			this.body.add(gray);
			var planeGeometry = new THREE.PlaneGeometry(4, 8);
			var x1, y1, x2, y2;
			x1 = 64 * (number % 4);
			x2 = x1 + 64;
			y1 = parseInt(number / 4) * 128;
			y2 = y1 + 128;
			this.mapUv(256, 256, planeGeometry, 0, x1, y2, x2, y1);
			var plane = new THREE.Mesh(planeGeometry, _config.numberMaterial);
			plane.rotation.x = -Math.PI / 2;
			plane.rotation.z = -Math.PI / 2;
			plane.position.y = _config.BLOCK.height / 2 + 0.05;
			this.body.add(plane);
			this.obj.scale.set(0.7, 1, 0.7);
		}
		// else if (type == 26) {
		// 	this.radiusSegments = 50;
		// 	this.canChange = false;
		// 	this.height = BLOCK.height / 21 * 4;
		// 	var geometry = new THREE.CylinderGeometry(BLOCK.radius * 2 / 38 * 6.5, BLOCK.radius * 2 / 38 * 6.5, this.height, 50, 50);
		// 	var material = new THREE.MeshLambertMaterial({
		// 	 	color: 0xea8d9a
		// 	});
		// 	this.hitObj = new THREE.Mesh(geometry, material);
		// 	var middle = new THREE.Mesh(new THREE.CylinderGeometry(BLOCK.radius * 2 / 38 * 7, BLOCK.radius * 2 / 38 * 7, BLOCK.height / 21 * 22, 50, 50), new THREE.MeshLambertMaterial({ map: loader.load('res/pencil_middle.png') }));
		// 	var bottom = new THREE.Mesh(new THREE.CylinderGeometry(BLOCK.radius * 2 / 38 * 7, 0.01, BLOCK.height / 21 * 14, 50, 50), new THREE.MeshLambertMaterial({ map: loader.load('res/pencil_bottom.png') }));
		// 	this.shadow.scale.set(14 / 38, 14 / 38, 14 / 38);
		// 	this.shadow.position.z += 1.9;
		// 	middle.rotation.y = 0.9;
		// 	middle.position.y = -BLOCK.height / 21 * 13;
		// 	bottom.position.y =  -BLOCK.height / 21 * 31;
		// 	this.body.add(middle);
		// 	this.body.add(bottom);
		// 	var planeGeometry = new THREE.CircleGeometry(BLOCK.radius * 2 / 38 * 7 + 0.02, 50);
		// 	var planeMaterial = new THREE.MeshLambertMaterial({ color: 0xf9d929 });
		// 	var plane = new THREE.Mesh(planeGeometry, planeMaterial);
		// 	plane.rotation.x = -Math.PI / 2;
		// 	plane.rotation.z = -0.7;
		// 	plane.position.y = -this.height / 2 + 0.01;
		// 	this.body.add(plane);
		// }
		this.shadow.initZ = this.shadow.position.z;
		this.hitObj.receiveShadow = true;
		this.hitObj.name = 'hitObj';
		this.body.add(this.hitObj);
		this.hitObj.matrixAutoUpdate = false;
		this.shadow.initScale = this.shadow.scale.y;
		this.body.position.y = _config.BLOCK.height / 2 - this.height / 2;
		this.obj.add(this.shadow);
		this.obj.add(this.body);
	}

	_createClass(Block, [{
		key: 'merge',
		value: function merge(totalGeometry, geometry, index, positions) {
			for (var i = 0, len = geometry.faces.length; i < len; ++i) {
				geometry.faces[i].materialIndex = 0;
			}
			var mesh = new THREE.Mesh(geometry);
			for (var i = 0, len = positions.length; i < len; ++i) {
				mesh.position.set(positions[i].x, positions[i].y, positions[i].z);
				mesh.updateMatrix();
				totalGeometry.merge(mesh.geometry, mesh.matrix, index);
			}
		}
	}, {
		key: 'mapUv',
		value: function mapUv(textureWidth, textureHeight, geometry, faceIdx, x1, y1, x2, y2, flag) {
			var tileUvW = 1 / textureWidth;
			var tileUvH = 1 / textureHeight;
			if (geometry.faces[faceIdx] instanceof THREE.Face3) {
				var UVs = geometry.faceVertexUvs[0][faceIdx * 2];
				if (faceIdx == 4 && !flag) {
					UVs[0].x = x1 * tileUvW;UVs[0].y = y1 * tileUvH;
					UVs[2].x = x1 * tileUvW;UVs[2].y = y2 * tileUvH;
					UVs[1].x = x2 * tileUvW;UVs[1].y = y1 * tileUvH;
				} else {
					UVs[0].x = x1 * tileUvW;UVs[0].y = y1 * tileUvH;
					UVs[1].x = x1 * tileUvW;UVs[1].y = y2 * tileUvH;
					UVs[2].x = x2 * tileUvW;UVs[2].y = y1 * tileUvH;
				}
				var UVs = geometry.faceVertexUvs[0][faceIdx * 2 + 1];
				if (faceIdx == 4 && !flag) {
					UVs[2].x = x1 * tileUvW;UVs[2].y = y2 * tileUvH;
					UVs[1].x = x2 * tileUvW;UVs[1].y = y2 * tileUvH;
					UVs[0].x = x2 * tileUvW;UVs[0].y = y1 * tileUvH;
				} else {
					UVs[0].x = x1 * tileUvW;UVs[0].y = y2 * tileUvH;
					UVs[1].x = x2 * tileUvW;UVs[1].y = y2 * tileUvH;
					UVs[2].x = x2 * tileUvW;UVs[2].y = y1 * tileUvH;
				}
			}
		}
	}, {
		key: 'getBox',
		value: function getBox() {
			if (this.boundingBox) return this.boundingBox;
			this.boundingBox = new THREE.Box3().setFromObject(this.body);
			return this.boundingBox;
		}
	}, {
		key: 'glow',
		value: function glow() {
			this.hitObj.material.map = this.glowMap;
		}
	}, {
		key: 'openDoor',
		value: function openDoor() {
			_animation.customAnimation.to(this.door.position, 1, { z: -4.5 });
			_animation.customAnimation.to(this.secondDoor.position, 1, { z: -0.5 });
		}
	}, {
		key: 'closeDoor',
		value: function closeDoor() {
			_animation.customAnimation.to(this.door.position, 1, { z: -3.3 });
			_animation.customAnimation.to(this.secondDoor.position, 1, { z: -1.7 });
		}
	}, {
		key: 'rotateBox',
		value: function rotateBox() {
			_animation.customAnimation.to(this.middle.rotation, 0.5, { y: -Math.PI / 2 });
		}
	}, {
		key: 'playMusic',
		value: function playMusic() {
			var _this2 = this;

			for (var i = 0; i < 2; ++i) {
				setTimeout(function (icon) {
					return function () {
						icon.visible = true;
						icon.position.set(0, 0, 0);
						icon.material.opacity = 1;
						_animation.customAnimation.to(icon.position, 2, { x: 5 * (1 - 2 * Math.random()), y: 15, z: 5 * (1 - 2 * Math.random()) });
						// customAnimation.to(this.icons[i].position, 3, { y: 15,  delay: i * 1 });
						// customAnimation.to(this.icons[i].position, 3, { z: 10 * (1 - 2 * Math.random()),  delay: i * 1 });
						_animation.customAnimation.to(icon.material, 2, { opacity: 0 });
					};
				}(this.icons[i]), i * 1000);
			}
			this.musicTimer = setTimeout(function () {
				_this2.playMusic();
			}, 2500);
		}
	}, {
		key: 'stopMusic',
		value: function stopMusic() {
			if (this.musicTimer) {
				clearTimeout(this.musicTimer);
				this.musicTimer = null;
			}
		}
	}, {
		key: 'change',
		value: function change(radius, t, radiusScale) {
			if (!this.canChange) return;
			if (this.order >= 9) {
				var min = this.order >= 13 ? 0.7 : 0.6;
				this.radiusScale = radiusScale || Math.max((0, _random.random)() * (_config.BLOCK.maxRadiusScale - _config.BLOCK.minRadiusScale) + _config.BLOCK.minRadiusScale, this.min || min);
				this.radiusScale = +this.radiusScale.toFixed(2);
				this.radius = radius || this.radiusScale * _config.BLOCK.radius;
				this.radius = +this.radius.toFixed(2);
				this.obj.scale.set(this.radiusScale, 1, this.radiusScale);
				if (this.order == 27) {
					this.sphere.scale.set(1 / this.radiusScale, 1, 1 / this.radiusScale);
					this.sphere.updateMatrix();
				}
				//this.plane.scale.z = this.radiusScale;
				return;
			}
			this.radiusScale = radiusScale || (0, _random.random)() * (_config.BLOCK.maxRadiusScale - _config.BLOCK.minRadiusScale) + _config.BLOCK.minRadiusScale;
			this.radiusScale = +this.radiusScale.toFixed(2);
			this.radius = radius || this.radiusScale * _config.BLOCK.radius;
			this.radius = +this.radius.toFixed(2);
			this.obj.scale.set(this.radiusScale, 1, this.radiusScale);
			this.changeColor(t);
		}
	}, {
		key: 'changeColor',
		value: function changeColor(t) {
			var type = t || this.types[Math.floor(Math.random() * 3)];
			if (this.type != type) {
				this.type = type;
				if (type == 'green') {
					this.greenMaterial.color.setHex(colors.green);
					this.whiteMaterial.color.setHex(colors.white);
					if (this.middleLightGreenMaterial) {
						this.middleLightGreenMaterial.color.setHex(colors.middleLightGreen);
					}
				} else if (type == 'gray') {
					this.greenMaterial.color.setHex(colors.white);
					this.whiteMaterial.color.setHex(colors.gray);
					if (this.middleLightGreenMaterial) {
						this.middleLightGreenMaterial.color.setHex(colors.middleLightGray);
					}
				} else if (type == 'black') {
					this.greenMaterial.color.setHex(colors.black);
					this.whiteMaterial.color.setHex(colors.lightBlack);
					if (this.middleLightGreenMaterial) {
						this.middleLightGreenMaterial.color.setHex(colors.middleLightBlack);
					}
				}
			}
		}
	}, {
		key: 'getVertices',
		value: function getVertices() {
			var _this3 = this;

			//this.hitObj.updateMatrixWorld();
			var vertices = [];
			var geometry = this.geometry || this.hitObj.geometry;
			if (this.radiusSegments === 4) {
				[0, 1, 4, 5].forEach(function (index) {
					var vertice = geometry.vertices[index].clone().applyMatrix4(_this3.hitObj.matrixWorld);
					vertices.push([vertice.x, vertice.z]);
				});
			} else {
				for (var i = 0; i < this.radiusSegments; ++i) {
					var vertice = geometry.vertices[i].clone().applyMatrix4(this.hitObj.matrixWorld);
					vertices.push([vertice.x, vertice.z]);
				}
			}
			return vertices;
		}
	}, {
		key: 'shrink',
		value: function shrink() {
			this.status = 'shrink';
		}
	}, {
		key: '_shrink',
		value: function _shrink() {
			//if (this.obj.position.y <= -BLOCK.floatHeight + 25) {
			this.scale -= _config.BLOCK.reduction;
			this.scale = Math.max(_config.BLOCK.minScale, this.scale);
			if (this.scale <= _config.BLOCK.minScale) {
				this.status = 'stop';
				return;
			}
			this.body.scale.y = this.scale;
			this.shadow.scale.y -= _config.BLOCK.reduction / 2;
			this.shadow.position.z += _config.BLOCK.reduction / 4 * this.shadowWidth;
			var distance = _config.BLOCK.reduction / 2 * _config.BLOCK.height * (_config.BLOCK.height - this.height / 2) / _config.BLOCK.height * 2;
			this.body.position.y -= distance;
			//}
			//this.obj.position.y -=  BLOCK.moveDownVelocity;
		}
	}, {
		key: 'showup',
		value: function showup(i) {
			var shadowZ = this.shadow.position.z;
			this.body.position.set(0, 20, 0);
			this.shadow.position.z = -15;
			this.obj.visible = true;
			if (i == 3 || i == 4 || i == 6) {
				this.obj.position.set((i == 6 ? 5 : 3) * 7.5, 0, (i == 3 || i == 6 ? -1 : 1) * 3.8);
			} else if (i == 5) {
				this.obj.position.set(4 * 7.5, 0, 0);
			} else {
				this.obj.position.set(i * 7.5, 0, 0);
			}
			//TweenMax.to(this.obj.position, 0.5, { ease: Bounce.easeOut, y: 0 });
			(0, _animation.TweenAnimation)(this.body.position.y, _config.BLOCK.height / 2 - this.height / 2, 500, 'Bounce.easeOut', function (value, complete) {
				this.body.position.y = value;
			}.bind(this));
			(0, _animation.TweenAnimation)(this.shadow.position.z, shadowZ, 500, 'Bounce.easeOut', function (value, complete) {
				this.shadow.position.z = value;
			}.bind(this));
		}
	}, {
		key: 'hideGlow',
		value: function hideGlow() {
			this.hitObj.material.map = this.map;
		}
	}, {
		key: 'popup',
		value: function popup() {
			//this.status = 'popup';
			if (this.order == 15) {
				this.hideGlow();
			} else if (this.order == 25) {
				for (var i = 0; i < 10; ++i) {
					for (var j = 0; j < 4; ++j) {
						this.numbers[i][j].visible = false;
					}
				}
				var date = new Date();
				var hour = ('0' + date.getHours()).slice(-2);
				var minute = ('0' + date.getMinutes()).slice(-2);
				this.numbers[hour[0]][0].position.x = -3.1 * this.radiusScale;
				this.numbers[hour[0]][0].visible = true;
				this.numbers[hour[1]][1].position.x = -1.2 * this.radiusScale;
				this.numbers[hour[1]][1].visible = true;
				this.numbers[minute[0]][2].position.x = 1.2 * this.radiusScale;
				this.numbers[minute[0]][2].visible = true;
				this.numbers[minute[1]][3].position.x = 3.1 * this.radiusScale;
				this.numbers[minute[1]][3].visible = true;
			} else if (this.order == 17) {
				this.middle.rotation.y = 0;
			}
			var shadowZ = this.shadow.position.z;
			this.body.position.y = 20;
			this.shadow.position.z = -15;
			this.obj.visible = true;
			this.boundingBox = null;
			//TweenMax.to(this.obj.position, 0.5, { ease: Bounce.easeOut, y: 0 });
			// TweenAnimation(this.body.position.y, BLOCK.height / 2 - this.height / 2, 500, 'Bounce.easeOut', function(value, complete) {
			// 	this.body.position.y = value
			// }.bind(this))
			// TweenAnimation(this.shadow.position.z, shadowZ, 500, 'Bounce.easeOut', function(value, complete) {
			// 	this.shadow.position.z = value
			// }.bind(this))
			_animation.customAnimation.to(this.body.position, 0.5, { y: _config.BLOCK.height / 2 - this.height / 2, ease: 'Bounce.easeOut' });
			_animation.customAnimation.to(this.shadow.position, 0.5, { z: shadowZ, ease: 'Bounce.easeOut' });
		}
	}, {
		key: 'reset',
		value: function reset() {
			this.status = 'stop';
			this.scale = 1;
			this.obj.scale.y = 1;
			this.body.scale.y = 1;
			this.obj.position.y = 0;
			this.body.position.y = _config.BLOCK.height / 2 - this.height / 2;
			this.shadow.scale.y = this.shadow.initScale;
			this.shadow.position.z = this.shadow.initZ;
			this.boundingBox = null;
		}
	}, {
		key: 'rebound',
		value: function rebound() {
			this.status = 'stop';
			this.scale = 1;
			_animation.customAnimation.to(this.body.scale, 0.5, { ease: 'Elastic.easeOut', y: 1 });
			_animation.customAnimation.to(this.body.position, 0.5, { ease: 'Elastic.easeOut', y: _config.BLOCK.height / 2 - this.height / 2 });

			_animation.customAnimation.to(this.shadow.scale, 0.5, { ease: 'Elastic.easeOut', y: this.shadow.initScale });
			_animation.customAnimation.to(this.shadow.position, 0.5, { ease: 'Elastic.easeOut', z: this.shadow.initZ });
		}
	}, {
		key: 'update',
		value: function update() {
			if (this.order == 19) {
				this.record.rotation.y += 0.01;
			}
			if (this.status === 'stop') return;
			if (this.status === 'shrink') {
				this._shrink();
			} else if (this.status === 'popup') {
				//this._popup();
			}
		}
	}]);

	return Block;
}();

exports.default = Block;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

var _animation = __webpack_require__(4);

var _config = __webpack_require__(2);

var _text = __webpack_require__(8);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Bottle = function () {
	function Bottle() {
		_classCallCheck(this, Bottle);

		this.obj = new THREE.Object3D();
		this.obj.name = 'bottle';
		this.trail = null;

		this.bottle = new THREE.Object3D();
		var basicMaterial = new THREE.MeshBasicMaterial({ map: _config.loader.load('res/head.png') });

		var headRadius = 2.1 * 0.45;
		this.human = new THREE.Object3D();
		this.head = new THREE.Mesh(new THREE.SphereGeometry(headRadius, 20, 20), basicMaterial);
		// this.head.rotation.y = 3.4;
		// this.head.rotation.x = -1;
		// window.hhh = this.head;
		this.head.castShadow = true;
		this.bottom = new THREE.Mesh(new THREE.CylinderGeometry(0.88 * headRadius, 1.27 * headRadius, 2.68 * headRadius, 20), new THREE.MeshBasicMaterial({ map: _config.loader.load('res/bottom.png') }));
		this.bottom.rotation.y = 4.7;
		this.bottom.castShadow = true;
		var middleGeometry = new THREE.CylinderGeometry(headRadius, 0.88 * headRadius, 1.2 * headRadius, 20);
		var middleMaterial = new THREE.MeshBasicMaterial({ map: _config.loader.load('res/top.png') });
		var materials = [middleMaterial, basicMaterial];
		var totalGeometry = new THREE.Geometry();
		middleGeometry.rotateY(4.7);
		this.merge(totalGeometry, middleGeometry, 0, [{ x: 0, y: this.bottom.position.y + 1.94 * headRadius, z: 0 }]);
		var topGeometry = new THREE.SphereGeometry(headRadius, 20, 20);
		topGeometry.scale(1, 0.54, 1);
		this.merge(totalGeometry, topGeometry, 1, [{ x: 0, y: this.bottom.position.y + 2.54 * headRadius, z: 0 }]);
		this.middle = new THREE.Mesh(totalGeometry, materials);
		this.middle.castShadow = true;
		// this.top.rotation.y = 3.4;
		// this.top.rotation.x = -1;
		this.body = new THREE.Object3D();
		this.body.add(this.bottom);
		this.body.add(this.middle);
		this.human.add(this.body);
		this.head.position.y = 4.725;
		this.human.add(this.head);
		//this.human.scale.set(0.45, 0.45, 0.45)
		this.bottle.add(this.human);

		this.bottle.position.y = _config.BOTTLE.bodyHeight / 2 - 0.25;

		this.obj.add(this.bottle);

		// 状态量
		this.status = 'stop';
		this.scale = 1;
		this.double = 1;
		this.velocity = {};
		this.flyingTime = 0;
		this.direction = 'straight';
		this.jumpStatus = 'init';

		// 粒子
		this.particles = [];
		var whiteParticleMaterial = new THREE.MeshBasicMaterial({ map: _config.loader.load('res/white.png'), alphaTest: 0.5 });
		var greenParticleMaterial = new THREE.MeshBasicMaterial({ map: _config.loader.load('res/green.png'), alphaTest: 0.5 });
		var particleGeometry = new THREE.PlaneGeometry(1, 1);
		for (var i = 0; i < 15; ++i) {
			var particle = new THREE.Mesh(particleGeometry, whiteParticleMaterial);
			particle.rotation.y = -Math.PI / 4;
			particle.rotation.x = -Math.PI / 5;
			particle.rotation.z = -Math.PI / 5;
			this.particles.push(particle);
			this.obj.add(particle);
		}
		for (var i = 0; i < 5; ++i) {
			var particle = new THREE.Mesh(particleGeometry, greenParticleMaterial);
			particle.rotation.y = -Math.PI / 4;
			particle.rotation.x = -Math.PI / 5;
			particle.rotation.z = -Math.PI / 5;
			this.particles.push(particle);
			this.obj.add(particle);
		}
		this.scoreText = new _text2.default('0', { fillStyle: 0x252525, textAlign: 'center', plusScore: true });
		this.scoreText.obj.visible = false;
		this.scoreText.obj.rotation.y = -Math.PI / 4;
		this.scoreText.obj.scale.set(0.5, 0.5, 0.5);
		this.obj.add(this.scoreText.obj);
	}

	_createClass(Bottle, [{
		key: 'merge',
		value: function merge(totalGeometry, geometry, index, positions) {
			for (var i = 0, len = geometry.faces.length; i < len; ++i) {
				geometry.faces[i].materialIndex = 0;
			}
			var mesh = new THREE.Mesh(geometry);
			for (var i = 0, len = positions.length; i < len; ++i) {
				mesh.position.set(positions[i].x, positions[i].y, positions[i].z);
				mesh.updateMatrix();
				totalGeometry.merge(mesh.geometry, mesh.matrix, index);
			}
		}
	}, {
		key: 'showAddScore',
		value: function showAddScore(score, double, quick, keepDouble) {
			if (keepDouble) {
				this.scoreText.setScore(score.toString());
			} else {
				if (double) {
					if (this.double === 1) this.double = 2;else this.double += 2;
				} else {
					this.double = 1;
				}
				if (quick && this.double <= 2) {
					this.double *= 2;
				}
				this.double = Math.min(32, this.double);
				score = score * this.double;

				this.scoreText.setScore(score.toString());
				/*if (this.direction === 'left') {
    	addScore.rotation.y = -Math.PI / 2;
    }*/
			}
			this.scoreText.obj.visible = true;
			this.scoreText.obj.position.y = 3;
			this.scoreText.material.opacity = 1;
			(0, _animation.TweenAnimation)(this.scoreText.obj.position.y, _config.BOTTLE.bodyHeight + 6, 700, function (value) {
				this.scoreText.obj.position.y = value;
			}.bind(this));
			(0, _animation.TweenAnimation)(this.scoreText.material.opacity, 0, 700, function (value, complete) {
				this.scoreText.material.opacity = value;
				if (complete) {
					this.scoreText.obj.visible = false;
				}
			}.bind(this));
		}
	}, {
		key: 'changeScorePos',
		value: function changeScorePos(z) {
			this.scoreText.obj.position.z = z;
		}
	}, {
		key: 'resetParticles',
		value: function resetParticles() {
			if (this.gatherTimer) clearTimeout(this.gatherTimer);
			this.gatherTimer = null;
			for (var i = 0, len = this.particles.length; i < len; ++i) {
				this.particles[i].gathering = false;
				this.particles[i].visible = false;
				this.particles[i].scattering = false;
			}
		}
	}, {
		key: 'scatterParticles',
		value: function scatterParticles() {
			for (var i = 0; i < 10; ++i) {
				this.particles[i].scattering = true;
				this.particles[i].gathering = false;
				this._scatterParticles(this.particles[i]);
			}
		}
	}, {
		key: '_scatterParticles',
		value: function _scatterParticles(particle) {
			var that = this;
			var minDistance = _config.BOTTLE.bodyWidth / 2;
			var maxDistance = 2;
			var x = (minDistance + Math.random() * (maxDistance - minDistance)) * (1 - 2 * Math.random());
			var z = (minDistance + Math.random() * (maxDistance - minDistance)) * (1 - 2 * Math.random());
			particle.scale.set(1, 1, 1);
			particle.visible = false;
			particle.position.x = x;
			particle.position.y = -0.5;
			particle.position.z = z;
			setTimeout(function (particle) {
				return function () {
					if (!particle.scattering) return;
					particle.visible = true;
					var duration = 0.3 + Math.random() * 0.2;
					//TweenMax.to(particle.rotation, duration, { x: Math.random() * 12, y: Math.random() * 12 });
					_animation.customAnimation.to(particle.scale, duration, { x: 0.2, y: 0.2, z: 0.2 });
					_animation.customAnimation.to(particle.position, duration, {
						x: 2 * x, y: 2.5 * Math.random() + 2, z: 2 * z, onComplete: function onComplete() {
							particle.scattering = false;
							particle.visible = false;
						}
					});
				};
			}(particle), 0);
		}
	}, {
		key: 'gatherParticles',
		value: function gatherParticles() {
			var _this = this;

			for (var i = 10; i < 20; ++i) {
				this.particles[i].gathering = true;
				this.particles[i].scattering = false;
				this._gatherParticles(this.particles[i]);
			}
			this.gatherTimer = setTimeout(function () {
				for (var i = 0; i < 10; ++i) {
					_this.particles[i].gathering = true;
					_this.particles[i].scattering = false;
					_this._gatherParticles(_this.particles[i]);
				}
			}, 500 + 1000 * Math.random());
		}
	}, {
		key: '_gatherParticles',
		value: function _gatherParticles(particle) {
			var that = this;
			var minDistance = 1;
			var maxDistance = 8;
			particle.scale.set(1, 1, 1);
			particle.visible = false;
			var x = Math.random() > 0.5 ? 1 : -1;
			var z = Math.random() > 0.5 ? 1 : -1;
			particle.position.x = (minDistance + Math.random() * (maxDistance - minDistance)) * x;
			particle.position.y = minDistance + Math.random() * (maxDistance - minDistance);
			particle.position.z = (minDistance + Math.random() * (maxDistance - minDistance)) * z;
			setTimeout(function (particle) {
				return function () {
					if (!particle.gathering) return;
					particle.visible = true;
					var duration = 0.5 + Math.random() * 0.4;
					//TweenMax.to(particle.rotation, duration, { x: Math.random() * 12, y: Math.random() * 12 });
					(0, _animation.TweenAnimation)(particle.scale.x, 0.8 + Math.random(), duration * 1000, function (value) {
						particle.scale.x = value;
					});
					(0, _animation.TweenAnimation)(particle.scale.y, 0.8 + Math.random(), duration * 1000, function (value) {
						particle.scale.y = value;
					});
					(0, _animation.TweenAnimation)(particle.scale.z, 0.8 + Math.random(), duration * 1000, function (value) {
						particle.scale.z = value;
					});

					(0, _animation.TweenAnimation)(particle.position.x, Math.random() * x, duration * 1000, function (value) {
						particle.position.x = value;
					});
					(0, _animation.TweenAnimation)(particle.position.y, Math.random() * 2.5, duration * 1000, function (value) {
						particle.position.y = value;
					});
					(0, _animation.TweenAnimation)(particle.position.z, Math.random() * z, duration * 1000, function (value, complete) {
						particle.position.z = value;
						if (complete && particle.gathering) {
							that._gatherParticles(particle);
						}
					});
				};
			}(particle), Math.random() * 500);
		}
	}, {
		key: 'update',
		value: function update(tickTime) {
			if (this.status == 'stop') {
				return;
			}
			if (this.status == 'prepare') {
				this._prepare();
			} else if (this.status == 'jump') {
				this._jump(tickTime);
			} else if (this.status == 'turn') {
				this.turn();
			}
		}
	}, {
		key: 'lookAt',
		value: function lookAt(direction, targetPosition) {
			if (direction !== this.direction) {
				if (direction === 'straight') {
					this.turnAngle = -(Math.PI / 2);
					this.angle = 0;
				} else {
					this.turnAngle = Math.PI / 2;
					this.angle = Math.PI / 2;
				}
				this.direction = direction;
				//this.status = 'turn';
			}

			// targetPosition.y = (BOTTLE.bodyHeight + BLOCK.height) / 2
			// this.status = 'turn';
			// this.direction = direction;
			// this.angle = targetPosition.clone().sub(this.obj.position.clone()).angleTo(new THREE.Vector3(1, 0, 0));
			// if (this.obj.position.z < targetPosition.z) this.angle *= -1;
			// this.turnAngle = this.angle - this.obj.rotation.y;
		}
	}, {
		key: 'turn',
		value: function turn() {
			var angle = this.turnAngle > 0 ? 0.2 : -0.2;
			this.bottle.rotation.y += angle;
			this.turnAngle -= angle;
			if (this.turnAngle >= -0.2 && this.turnAngle <= 0.2) {
				this.bottle.rotation.y = this.angle;
				this.status = 'stop';
			}
		}
	}, {
		key: 'fall',
		value: function fall() {
			var _this2 = this;

			this.stop();
			setTimeout(function () {
				_this2.status = 'fall';
				(0, _animation.TweenAnimation)(_this2.obj.position.y, -_config.BLOCK.height / 2 - 0.3, 400, function (value) {
					this.obj.position.y = value;
				}.bind(_this2));
			}, 0);
		}
	}, {
		key: 'forerake',
		value: function forerake() {
			var _this3 = this;

			this.stop();
			this.status = 'forerake';
			setTimeout(function () {
				if (_this3.direction === 'straight') {
					(0, _animation.TweenAnimation)(_this3.obj.rotation.z, -Math.PI / 2, 1000, function (value) {
						this.obj.rotation.z = value;
					}.bind(_this3));

					//TweenMax.to(this.obj.position, 0.3, { x: this.obj.position.x + BOTTLE.bodyWidth });
				} else {
					(0, _animation.TweenAnimation)(_this3.obj.rotation.x, -Math.PI / 2, 1000, function (value) {
						this.obj.rotation.x = value;
					}.bind(_this3));
					//TweenMax.to(this.obj.position, 0.3, { z: this.obj.position.z - BOTTLE.bodyWidth });
				}
				// TweenAnimation(this.obj.position.y, this.obj.position.y - 0.5, 500, function(value) {
				// 	this.obj.position.y = value;
				// }.bind(this));
				setTimeout(function () {
					if (_this3.status == 'suspend') {
						_this3.status = 'stop';return;
					}
					(0, _animation.TweenAnimation)(_this3.obj.position.y, -_config.BLOCK.height / 2 + 1.2, 400, function (value, complete) {
						this.obj.position.y = value;
						if (complete) this.status = 'stop';
					}.bind(_this3));
					_animation.customAnimation.to(_this3.head.position, 0.2, { x: -1.125 });
					_animation.customAnimation.to(_this3.head.position, 0.2, { x: 0, delay: 0.2 });
				}, 200);
			}, 200);
		}
	}, {
		key: 'hypsokinesis',
		value: function hypsokinesis() {
			var _this4 = this;

			this.stop();
			this.status = 'hypsokinesis';
			setTimeout(function () {
				if (_this4.direction === 'straight') {
					(0, _animation.TweenAnimation)(_this4.obj.rotation.z, Math.PI / 2, 800, function (value) {
						this.obj.rotation.z = value;
					}.bind(_this4));
				} else {
					(0, _animation.TweenAnimation)(_this4.obj.rotation.x, Math.PI / 2, 800, function (value) {
						this.obj.rotation.x = value;
					}.bind(_this4));
				}
				setTimeout(function () {
					if (_this4.status == 'suspend') {
						_this4.status = 'stop';return;
					}
					(0, _animation.TweenAnimation)(_this4.obj.position.y, -_config.BLOCK.height / 2 + 1.2, 400, function (value, complete) {
						this.obj.position.y = value;
						if (complete) this.status = 'stop';
					}.bind(_this4));
					_animation.customAnimation.to(_this4.head.position, 0.2, { x: 1.125 });
					_animation.customAnimation.to(_this4.head.position, 0.2, { x: 0, delay: 0.2 });
				}, 350);
			}, 200);
		}
	}, {
		key: '_jump',
		value: function _jump(tickTime) {
			var translateV = new THREE.Vector3(0, 0, 0);
			translateV.z = this.velocity.vz * tickTime;
			translateV.y = this.velocity.vy * tickTime - _config.GAME.gravity / 2 * tickTime * tickTime - _config.GAME.gravity * this.flyingTime * tickTime;
			this.flyingTime += tickTime;
			this.obj.translateY(translateV.y);
			this.obj.translateOnAxis(this.axis, translateV.z);

			// if (this.jumpStatus == 'init' && this.flyingTime > 0.05) {
			// 	this.jumpStatus = 'rotate1';
			// }
			// if (this.jumpStatus == 'still' && this.flyingTime - this.stillStartTime > 0.05) {
			// 	this.jumpStatus = 'rotate2';
			// }
			// if (this.jumpStatus == 'rotate1') {
			// 	this.bottle.rotateZ(Math.PI / 4);
			// }
			// if (this.jumpStatus == 'rotate2') {
			// 	this.bottle.rotateZ(Math.PI / 8);
			// }
			// if (this.jumpStatus == 'rotate1' && this.bottle.rotation.z <= 0) {
			// 	this.jumpStatus = 'still';
			// 	this.stillStartTime = this.flyingTime;
			// }
			// if (this.jumpStatus == 'rotate2' && this.bottle.rotation.z >= 0) {
			// 	this.jumpStatus = 'stop';
			// 	this.bottle.rotation.z = 0;
			// }
		}
	}, {
		key: 'squeeze',
		value: function squeeze() {
			this.obj.position.y = _config.BLOCK.height / 2;
			_animation.customAnimation.to(this.body.scale, 0.15, { y: 0.9, x: 1.07, z: 1.07 });
			_animation.customAnimation.to(this.body.scale, 0.15, { y: 1, x: 1, z: 1, delay: 0.15 });
			_animation.customAnimation.to(this.head.position, 0.15, { y: 4.725, delay: 0.15 });
		}
	}, {
		key: 'stop',
		value: function stop() {
			this.status = 'stop';
			this.flyingTime = 0;
			this.scale = 1;
			this.velocity = {};
			this.jumpStatus = 'init';
		}
	}, {
		key: 'suspend',
		value: function suspend() {
			this.status = 'suspend';
			_animation.TweenAnimation.killAll();
		}
	}, {
		key: 'rotate',
		value: function rotate() {
			_animation.TweenAnimation.killAll();
			if (this.direction === 'straight') {
				(0, _animation.TweenAnimation)(this.obj.rotation.z, 0, 300, function (value) {
					this.obj.rotation.z = value;
				}.bind(this));
				var offset;
				if (this.status.indexOf('forerake') >= 0) {
					offset = 2;
				} else {
					offset = -2;
				}
				(0, _animation.TweenAnimation)(this.obj.position.x, this.obj.position.x + offset, 300, function (value) {
					this.obj.position.x = value;
				}.bind(this));
			} else {
				(0, _animation.TweenAnimation)(this.obj.rotation.x, 0, 300, function (value) {
					this.obj.rotation.x = value;
				}.bind(this));
				if (this.status.indexOf('forerake') >= 0) {
					offset = -2;
				} else {
					offset = 2;
				}
				(0, _animation.TweenAnimation)(this.obj.position.z, this.obj.position.z + offset, 300, function (value) {
					this.obj.position.z = value;
				}.bind(this));
			}
			(0, _animation.TweenAnimation)(this.head.position.x, 0, 100, function (value) {
				this.head.position.x = value;
			}.bind(this));
			(0, _animation.TweenAnimation)(this.obj.position.y, -_config.BLOCK.height / 2, 300, function (value, complete) {
				this.obj.position.y = value;
				if (complete) this.status = 'stop';
			}.bind(this));
			this.status = 'rotate';
		}
	}, {
		key: '_prepare',
		value: function _prepare() {

			this.scale -= _config.BOTTLE.reduction;
			this.scale = Math.max(_config.BOTTLE.minScale, this.scale);
			if (this.scale <= _config.BOTTLE.minScale) {
				return;
			}
			// this.bottle.scale.y = this.scale;
			// this.bottle.scale.x += 0.007;
			// this.bottle.scale.z += 0.007;
			this.body.scale.y = this.scale;
			this.body.scale.x += 0.007;
			this.body.scale.z += 0.007;
			this.head.position.y -= 0.018;
			var distance = 0.027;
			this.obj.position.y -= _config.BLOCK.reduction / 2 * _config.BLOCK.height / 2 + distance;
			//if (this.obj.position.y <= BLOCK.height / 2 + BOTTLE.bodyHeight / 2 - (1 - this.scale) * BOTTLE.bodyHeight / 2) return;
			//this.obj.position.y -= distance + BLOCK.moveDownVelocity;
			// this.obj.position.y -= BLOCK.moveDownVelocity;
			//this.obj.position.y -= distance;
		}
	}, {
		key: 'prepare',
		value: function prepare() {
			this.status = 'prepare';
			this.gatherParticles();
		}
	}, {
		key: 'jump',
		value: function jump(axis) {
			this.resetParticles();
			this.status = 'jump';
			this.axis = axis;
			_animation.customAnimation.to(this.body.scale, 0.25, { x: 1, y: 1, z: 1 });
			this.head.position.y = 4.725;
			this.scale = 1;

			/**
    * 注释掉体操旋转
    */

			// if (this.direction === 'straight') {
			// 	TweenMax.to(this.bottle.rotation, 0.1, { ease: Power1.easeIn, z: this.bottle.rotation.z - Math.PI });
			// 	TweenMax.to(this.bottle.rotation, 0.2, { z: this.bottle.rotation.z - 2 * Math.PI, delay: 0.15 });
			// } else {
			// 	TweenMax.to(this.bottle.rotation, 0.1, { ease: Power1.easeIn, x: this.bottle.rotation.x - Math.PI });
			// 	TweenMax.to(this.bottle.rotation, 0.2, { x: this.bottle.rotation.x - 2 * Math.PI, delay: 0.15 });
			// }

			// if (this.direction === 'straight') {
			// 	TweenMax.to(this.timer.rotation, 0.3, { ease: Power1.easeIn, z: this.timer.rotation.z - Math.PI, onComplete: () =>{
			// 		this.timer.rotation.z = this.timer.rotation.x = 0;
			// 	}});
			// 	//TweenMax.to(this.bottle.rotation, 0.2, { z: this.bottle.rotation.z + 2 * Math.PI, delay: 0.15 });
			// } else {
			// 	TweenMax.to(this.timer.rotation, 0.3, { ease: Power1.easeIn, x: this.timer.rotation.x - Math.PI, onComplete: () => {
			// 		this.timer.rotation.z = this.timer.rotation.x = 0;
			// 	} });
			// 	//TweenMax.to(this.bottle.rotation, 0.2, { x: this.bottle.rotation.x + 2 * Math.PI, delay: 0.15 });
			// }

			// if (this.direction === 'straight') {
			// 	TweenMax.to(this.body.rotation, 1, { ease: Power1.easeIn, z: this.body.rotation.z  + Math.PI });
			// 	TweenMax.to(this.body.rotation, 0.2, { z: this.body.rotation.z + 2 * Math.PI, delay: 0.15 });
			// } else {
			// 	TweenMax.to(this.body.rotation, 0.1, { ease: Power1.easeIn, x: this.body.rotation.x + Math.PI });
			// 	TweenMax.to(this.body.rotation, 0.2, { x: this.body.rotation.x + 2 * Math.PI, delay: 0.15 });
			// }
			// TweenMax.to(this.head.position, 0.1, { z: this.head.position.z  - 1, delay: 0.15 });
			// TweenMax.to(this.head.position, 0.1, { z: this.head.position.z, y: this.head.position.y, delay: 0.25 });


			var scale = Math.min(Math.max(this.velocity.vz / 35, 1.2), 1.4);
			this.human.rotation.z = this.human.rotation.x = 0;
			if (this.direction === 'straight') {
				_animation.customAnimation.to(this.human.rotation, 0.14, { z: this.human.rotation.z - Math.PI });
				_animation.customAnimation.to(this.human.rotation, 0.18, { z: this.human.rotation.z - 2 * Math.PI, delay: 0.14 });
				_animation.customAnimation.to(this.head.position, 0.1, { y: this.head.position.y + 0.9 * scale, x: this.head.position.x + 0.45 * scale });
				_animation.customAnimation.to(this.head.position, 0.1, { y: this.head.position.y - 0.9 * scale, x: this.head.position.x - 0.45 * scale, delay: 0.1 });
				_animation.customAnimation.to(this.head.position, 0.15, { y: 4.725, x: 0, delay: 0.25 });
				// TweenMax.to(this.head.position, 0.1, { z: this.head.position.z , delay: 0.3 });
				_animation.customAnimation.to(this.body.scale, 0.1, { y: Math.max(scale, 1), x: Math.max(Math.min(1 / scale, 1), 0.7), z: Math.max(Math.min(1 / scale, 1), 0.7) });
				_animation.customAnimation.to(this.body.scale, 0.1, { y: Math.min(0.9 / scale, 0.7), x: Math.max(scale, 1.2), z: Math.max(scale, 1.2), delay: 0.1 });
				_animation.customAnimation.to(this.body.scale, 0.3, { y: 1, x: 1, z: 1, delay: 0.2 });
			} else {
				_animation.customAnimation.to(this.human.rotation, 0.14, { x: this.human.rotation.x - Math.PI });
				_animation.customAnimation.to(this.human.rotation, 0.18, { x: this.human.rotation.x - 2 * Math.PI, delay: 0.14 });

				_animation.customAnimation.to(this.head.position, 0.1, { y: this.head.position.y + 0.9 * scale, z: this.head.position.z - 0.45 * scale });
				_animation.customAnimation.to(this.head.position, 0.1, { z: this.head.position.z + 0.45 * scale, y: this.head.position.y - 0.9 * scale, delay: 0.1 });
				_animation.customAnimation.to(this.head.position, 0.15, { y: 4.725, z: 0, delay: 0.25 });
				// TweenMax.to(this.head.position, 0.1, { z: this.head.position.z , delay: 0.3 });
				_animation.customAnimation.to(this.body.scale, 0.05, { y: Math.max(scale, 1), x: Math.max(Math.min(1 / scale, 1), 0.7), z: Math.max(Math.min(1 / scale, 1), 0.7) });
				_animation.customAnimation.to(this.body.scale, 0.05, { y: Math.min(0.9 / scale, 0.7), x: Math.max(scale, 1.2), z: Math.max(scale, 1.2), delay: 0.1 });
				_animation.customAnimation.to(this.body.scale, 0.2, { y: 1, x: 1, z: 1, delay: 0.2 });
			}

			//TweenMax.to(this.bottle.rotation, 1, { z: 2 * Math.PI, delay: 2 });
		}
	}, {
		key: 'showup',
		value: function showup() {
			this.status = 'showup';
			this.obj.position.y = 25;
			this.human.rotation.x = this.human.rotation.z = 0;
			(0, _animation.TweenAnimation)(this.obj.position.y, _config.BLOCK.height / 2, 500, 'Bounce.easeOut', function (value, complete) {
				this.obj.position.y = value;
				if (complete) {
					this.status = 'stop';
				}
			}.bind(this));

			/*    TweenMax.to(this.obj.position, 0.5, { ease: Bounce.easeOut, y: (BLOCK.height) / 2 , onComplete: () => { */
			// this.status = 'stop';
			/* }}); */
		}
	}, {
		key: 'stopPrepare',
		value: function stopPrepare() {
			this.obj.position.y = _config.BLOCK.height / 2;
			this.stop();
			this.body.scale.set(1, 1, 1);
			this.head.position.y = 4.725;
			this.head.position.x = 0;
			this.resetParticles();
		}
	}, {
		key: 'getBox',
		value: function getBox() {
			return [new THREE.Box3().setFromObject(this.head), new THREE.Box3().setFromObject(this.middle), new THREE.Box3().setFromObject(this.bottom)];
		}
	}, {
		key: 'reset',
		value: function reset() {
			this.stop();
			this.obj.position.y = _config.BLOCK.height / 2;
			this.obj.position.x = this.obj.position.z = 0;
			this.obj.rotation.z = 0;
			this.obj.rotation.y = 0;
			this.obj.rotation.x = 0;
			this.bottle.rotation.y = 0;
			this.bottle.rotation.z = 0;
			this.bottle.rotation.x = 0;
			if (this.body && this.head) {
				this.body.scale.set(1, 1, 1);
				this.body.rotation.z = 0;
				this.body.rotation.x = 0;
				this.head.position.y = 4.725;
				this.head.position.x = 0;
				this.human.rotation.z = this.human.rotation.x = 0;
			}
			this.direction = 'straight';
			this.jumpStatus = 'init';
			this.double = 1;
			this.resetParticles();
			this.scoreText.obj.visible = false;
		}
	}]);

	return Bottle;
}();

exports.default = Bottle;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var InstuctionCtrl = function () {
  function InstuctionCtrl(game) {
    _classCallCheck(this, InstuctionCtrl);

    this.game = game;
    this.commandList = [];

    this.isRunning = false;
    this.icTimeout = null;
    this.cmdHandler = function () {
      // console.log('InstuctionCtrl receive No handler')
    };

    this.gameId = 0;

    this.seq = 0;
  }

  _createClass(InstuctionCtrl, [{
    key: "onReceiveCommand",
    value: function onReceiveCommand(data, seq) {
      // console.log('seq', seq)
      if (this.gameId != this.game.gameCtrl.modeCtrl.observeCtrl.gameId) {
        // console.log('矫正gameId')
        this.gameId = this.game.gameCtrl.modeCtrl.observeCtrl.gameId;
        this.seq = seq - 1;
      }

      // 正常情况下 deltaNum = 1
      var deltaNum = seq - this.seq;

      if (deltaNum != 1) {
        var word;
        if (deltaNum > 1) {
          // 掉帧
          word = 0;
        }
        if (deltaNum < 1) {
          // 帧乱
          word = 1;
        }
        this.game.sendServerError(word);
        this.game.socketFirstSync = true;
      }

      this.seq = seq;
      this.commandList.push(data);
      this.checkRunningState();
    }
  }, {
    key: "checkRunningState",
    value: function checkRunningState() {
      if (!this.isRunning) {
        this.runCommand();
      }
    }
  }, {
    key: "runCommand",
    value: function runCommand() {
      var cmd = this.commandList.pop();
      // 这个地方一定要在cmdHandler前面，否则会引起循环调用的坑
      this.isRunning = true;
      this.cmdHandler(cmd);
    }
  }, {
    key: "bindCmdHandler",
    value: function bindCmdHandler(func) {
      this.cmdHandler = func;
    }
  }, {
    key: "onCmdComplete",
    value: function onCmdComplete() {
      if (this.commandList.length) {
        this.runCommand();
      } else {
        this.isRunning = false;
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.commandList = [];
      this.gameId = 0;
      this.seq = 0;
      if (this.icTimeout) {
        clearTimeout(this.icTimeout);
      }
      this.icTimeout = null;
      this.isRunning = false;
    }
  }]);

  return InstuctionCtrl;
}();

exports.default = InstuctionCtrl;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _queryCtrl = __webpack_require__(38);

var _queryCtrl2 = _interopRequireDefault(_queryCtrl);

var _modeCtrl = __webpack_require__(34);

var _modeCtrl2 = _interopRequireDefault(_modeCtrl);

var _networkCtrl = __webpack_require__(35);

var _networkCtrl2 = _interopRequireDefault(_networkCtrl);

var _animation = __webpack_require__(4);

var _config = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GameCtrl = function () {
  function GameCtrl(game) {
    _classCallCheck(this, GameCtrl);

    this.game = game;
  }

  _createClass(GameCtrl, [{
    key: 'init',
    value: function init() {
      this.gameView = this.game.gameView;
      this.queryCtrl = new _queryCtrl2.default(this.game);
      this.netWorkCtrl = new _networkCtrl2.default(this.game);
      this.modeCtrl = new _modeCtrl2.default(this.game);
      this.model = this.game.gameModel;

      this.reporter = this.game.reporter;
      this.historyTimes = this.game.historyTimes;
      this.viewer = this.game.viewer;
    }
  }, {
    key: 'firstInitGame',
    value: function firstInitGame(options) {
      this.queryCtrl.identifyMode(options);
      this.modeCtrl.initFirstPage(options);
    }
  }, {
    key: 'identifyModeErr',
    value: function identifyModeErr(wording) {
      this.gameView.showIdentifyModeErr(wording);
    }
  }, {
    key: 'onLoginSuccess',
    value: function onLoginSuccess() {
      this.reporter.setTimer(_config.REPORTERTIMEOUT);
    }

    // 首页：开始游戏

  }, {
    key: 'clickStart',
    value: function clickStart() {
      this.modeCtrl.clickStart();
    }

    // 首页：点击排行

  }, {
    key: 'showFriendRank',
    value: function showFriendRank() {
      this.modeCtrl.showFriendRank();
    }

    // 结算页：点击排行

  }, {
    key: 'clickRank',
    value: function clickRank() {
      this.modeCtrl.clickRank();
    }
  }, {
    key: 'gameOver',
    value: function gameOver(score) {
      this.model.setScore(score);
      if (this.model.mode != 'observe') {
        var highestScore = this.model.getHighestScore();
        var weekBestScore = this.model.weekBestScore;

        // 加一局玩过的次数
        this.historyTimes.addOne();
        var gameTimes = this.historyTimes.getTimes();

        this.reporter.playGameReport(score, highestScore, gameTimes);
        //console.log("wtf", JSON.stringify(this.game.actionList), JSON.stringify(this.game.musicList), this.game.randomSeed,  JSON.stringify(this.game.touchList));
        // !!! 这里因为调用的都是同一个接口，为了节省服务器资源，最高分跟回合次数耦合在一起了
        if (weekBestScore < score) {
          // 如果产生了最高分
          // !!! 这里上传了最高分和历史回合次数
          var verifyData = {
            seed: this.game.randomSeed,
            action: this.game.actionList,
            musicList: this.game.musicList,
            touchList: this.game.touchList,
            version: 1
          };
          this.historyTimes.upLoadHistoryTimes(score, verifyData);
          // this.model.weekBestScore = score
          // if (highestScore < score) {
          //   this.model.saveHeighestScore(score)
          // }
        } else {

          // 检查是否需要上传次数
          this.historyTimes.checkUp();
        }

        // 更新排行榜分数
        this.netWorkCtrl.upDateFriendsScoreList();
      }

      if (this.mode == 'player') {
        this.reporter.playAudienceReport();
      }

      if (this.mode == 'battle') {
        this.reporter.playPKReport(score);
      }
    }
  }, {
    key: 'gameOverShowPage',
    value: function gameOverShowPage() {
      this.modeCtrl.showGameOverPage();
      if (this.model.mode != 'observe') {
        if (this.model.currentScore >= this.model.weekBestScore) {
          this.model.weekBestScore = this.model.currentScore;
          this.model.saveWeekBestScore(this.model.currentScore);
          if (this.model.currentScore > this.model.getHighestScore()) {
            var verifyData = {
              seed: this.game.randomSeed,
              action: this.game.actionList
            };
            this.model.saveHeighestScore(this.model.currentScore, verifyData);
          }
        }
      }
    }

    // 结算页面：重新玩

  }, {
    key: 'clickReplay',
    value: function clickReplay() {
      this.reporter.playAudienceReportStart();
      this.modeCtrl.gameOverClickReplay();
    }

    // 好友排行：返回上一页

  }, {
    key: 'friendRankReturn',
    value: function friendRankReturn() {
      this.modeCtrl.friendRankReturn();
    }
  }, {
    key: 'netWorkLogin',
    value: function netWorkLogin() {
      this.netWorkCtrl.netWorkLogin();
    }

    // 好友排行页面：群分享

  }, {
    key: 'shareGroupRank',
    value: function shareGroupRank() {
      this.modeCtrl.shareGroupRank();
    }
  }, {
    key: 'afterShareGroupRank',
    value: function afterShareGroupRank(success, isGroup) {
      // console.log(success, isGroup)
      this.reporter.shareGroupReport(isGroup);
    }

    // 结算页面：

  }, {
    key: 'shareBattleCard',
    value: function shareBattleCard() {
      this.modeCtrl.shareBattleCard();
    }
  }, {
    key: 'afterShareBattle',
    value: function afterShareBattle(success, isGroup) {
      // console.log(success, isGroup)
      if (success) {
        this.reporter.sharePKReport(isGroup);
      }
    }
  }, {
    key: 'groupPlayGame',
    value: function groupPlayGame() {
      this.modeCtrl.groupPlayGame();
    }

    // 加入挑战模式事件

  }, {
    key: 'loginBattle',
    value: function loginBattle(isGroup) {
      // console.log('loginBattle', isGroup)
      this.reporter.joinPKReport(isGroup);
      this.reporter.playPKReportStart(isGroup);
    }

    // 获取PK的信息之后触发事件

  }, {
    key: 'showPkPage',
    value: function showPkPage(ownerScore) {
      // console.log('showPkPage', ownerScore)
      this.reporter.playPKScore(ownerScore);
    }

    // 挑战页面：点击挑战

  }, {
    key: 'onBattlePlay',
    value: function onBattlePlay(pk) {
      this.modeCtrl.battlePlay(pk);
    }
  }, {
    key: 'battleToSingle',
    value: function battleToSingle() {
      this.reporter.resetPKReport();
    }

    // 事件

  }, {
    key: 'shareObservCard',
    value: function shareObservCard() {
      this.modeCtrl.shareObservCard();
    }
  }, {
    key: 'socketJoinSuccess',
    value: function socketJoinSuccess(success) {
      this.modeCtrl.socketJoinSuccess(success);
      if (this.model.mode == 'observe') {
        if (success) {
          this.game.socketFirstSync = true;
          this.reporter.joinAudienceReportStart();
        }
      } else {
        this.reporter.joinAudienceReport();
      }

      if (this.model.mode == 'player') {
        this.reporter.playAudienceReportStart();
      }
    }

    // 分享卡片之后

  }, {
    key: 'afterShareObserveCard',
    value: function afterShareObserveCard(isGroup) {
      this.reporter.shareAudienceReport(isGroup);
    }
  }, {
    key: 'showPlayerGG',
    value: function showPlayerGG(data) {
      this.modeCtrl.showPlayerGG(data);
    }
  }, {
    key: 'showPlayerWaiting',
    value: function showPlayerWaiting() {
      this.modeCtrl.showPlayerWaiting();
    }
  }, {
    key: 'onPlayerOut',
    value: function onPlayerOut() {
      this.modeCtrl.onPlayerOut();
    }
  }, {
    key: 'onViewerStart',
    value: function onViewerStart() {
      this.game.audioManager.scale_intro.stop();
      if (this.game.deadTimeout) {
        clearTimeout(this.game.deadTimeout);
        this.game.deadTimeout = null;
      }
      this.game.pendingReset = false;
      // TweenAnimation.killAll();
      this.modeCtrl.onViewerStart();
      this.reporter.joinAudienceReport();
    }
  }, {
    key: 'wxOnShow',
    value: function wxOnShow(options) {
      var _this = this;

      this.netWorkCtrl.requestServerInit();
      this.reporter.setTimer(_config.REPORTERTIMEOUT);
      setTimeout(function () {

        // 根据传进来的mode参数判断，如果有mode说明需要更换场景
        if (!!options.query && options.query.hasOwnProperty('mode')) {
          _this.modeCtrl.reInitFirstPage(options);
        } else if (_this.model.mode != 'single' && _this.model.mode != 'player' && _this.model.mode != 'battle') {
          // 进来没有参数onshow，单人，围观，挑战，有可能在分享时候回来
          _this.modeCtrl.changeMode('singleCtrl');
        }
      }, 300);
    }
  }, {
    key: 'wxOnhide',
    value: function wxOnhide() {
      this.reporter.quitReport();
      if (this.model.mode == 'observe') {
        this.reporter.joinAudienceReport();
      }

      // 清除定时器，1、服务器下发配置的定时器，2、上报的定时器
      this.netWorkCtrl.clearServerInit();
      this.reporter.clearTimer();

      this.modeCtrl.wxOnhide();
    }
  }, {
    key: 'onReplayGame',
    value: function onReplayGame() {
      var mode = this.model.mode;
      if (mode != 'observe') {
        this.reporter.playGameReportStart();
      }
    }
  }, {
    key: 'onPeopleCome',
    value: function onPeopleCome(data) {
      if (data.audience_cmd == 0) {

        // 来人了
        this.viewer.peopleCome(data);
        this.reporter.playAudienceReportMaxPeople(this.viewer.num);
      } else if (data.audience_cmd == 1) {

        // 人走了
        this.viewer.peopleOut(data);
      }
    }
  }, {
    key: 'onServerConfigForbid',
    value: function onServerConfigForbid() {}
  }, {
    key: 'onSocketCloseErr',
    value: function onSocketCloseErr() {
      this.gameView.showSocketCloseErr();
      this.modeCtrl.changeMode('singleCtrl');
    }
  }]);

  return GameCtrl;
}();

exports.default = GameCtrl;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _storage = __webpack_require__(5);

var _storage2 = _interopRequireDefault(_storage);

var _session = __webpack_require__(6);

var _session2 = _interopRequireDefault(_session);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GameModel = function () {
  function GameModel(game) {
    _classCallCheck(this, GameModel);

    this.game = game;
    this.mode = '';
    this.stage = '';
    this.is_from_wn = 0;
    this.firstBlood = false;
    this.currentScore = 0;
    this.highestScore = 0;
    this.observeInfo = {};
    this.friendsScore = [];
    this.weekBestScore = 0;
    this.startTime = Math.floor(Date.now() / 1000);
  }

  _createClass(GameModel, [{
    key: 'setMode',
    value: function setMode(mode) {
      this.mode = mode;
      this.game.mode = mode;
    }
  }, {
    key: 'setStage',
    value: function setStage(stage) {
      this.stage = stage;
      this.game.stage = stage;
    }
  }, {
    key: 'init',
    value: function init() {
      _session2.default.init();

      var fb = _storage2.default.getFirstBlood();
      if (!fb) {
        this.setFirstBlood(true);
        _storage2.default.saveFirstBlood();
      }

      this.highestScore = _storage2.default.getHeighestScore() || 0;
      _session2.default.setServerConfig(_storage2.default.getServerConfig());

      this.weekBestScore = _storage2.default.getWeekBestScore() || 0;
      this.friendsScore = _storage2.default.getFriendsScore();
    }
  }, {
    key: 'getServerConfig',
    value: function getServerConfig() {
      return _session2.default.serverConfig;
    }
  }, {
    key: 'setIsFromWn',
    value: function setIsFromWn(number) {
      this.is_from_wn = number;
      this.game.is_from_wn = number;
    }
  }, {
    key: 'setFirstBlood',
    value: function setFirstBlood(bool) {
      this.firstBlood = bool;
      this.game.firstBlood = bool;
    }
  }, {
    key: 'getMode',
    value: function getMode() {
      return this.mode;
    }
  }, {
    key: 'setScore',
    value: function setScore(score) {
      this.currentScore = score;
      // if (score > this.highestScore) {
      //   this.saveHeighestScore(score)
      // }
    }
  }, {
    key: 'saveHeighestScore',
    value: function saveHeighestScore(score) {
      var verifyData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      if (verifyData) {
        var expire = this.getNextSunday();
        var vData = {
          ts: expire,
          data: verifyData
        };
      } else {
        var vData = '';
      }

      _storage2.default.saveHeighestScore(score);
      _storage2.default.saveActionData(vData);
      this.highestScore = score;
    }
  }, {
    key: 'saveWeekBestScore',
    value: function saveWeekBestScore() {
      var score = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var data = {
        ts: this.getNextSunday(),
        data: score
      };
      _storage2.default.saveWeekBestScore(data);
    }
  }, {
    key: 'getActionData',
    value: function getActionData() {
      return _storage2.default.getActionData();
    }
  }, {
    key: 'getHighestScore',
    value: function getHighestScore() {
      return this.highestScore;
    }
  }, {
    key: 'saveFriendsScore',
    value: function saveFriendsScore(data) {
      this.friendsScore = data;
      var formatData = {
        ts: this.getNextSunday(),
        data: data
      };
      _storage2.default.saveFriendsScore(formatData);
    }
  }, {
    key: 'getSessionId',
    value: function getSessionId() {
      return _session2.default.sessionId;
    }
  }, {
    key: 'getPkId',
    value: function getPkId() {
      return _session2.default.pkId;
    }
  }, {
    key: 'clearPkId',
    value: function clearPkId() {
      _session2.default.clearPkId();
    }
  }, {
    key: 'setShareTicket',
    value: function setShareTicket(rawData) {
      _session2.default.setShareTicket(rawData);
    }
  }, {
    key: 'getShareTicket',
    value: function getShareTicket() {
      return _session2.default.shareTicket;
    }
  }, {
    key: 'clearShareTicket',
    value: function clearShareTicket() {
      _session2.default.clearShareTicket();
    }
  }, {
    key: 'setGameId',
    value: function setGameId(id) {
      _session2.default.setGameId(id);
    }
  }, {
    key: 'setGameTicket',
    value: function setGameTicket(ticket) {
      _session2.default.setGameTicket(ticket);
    }
  }, {
    key: 'clearGameId',
    value: function clearGameId() {
      _session2.default.clearGameId();
    }
  }, {
    key: 'clearGameTicket',
    value: function clearGameTicket() {
      _session2.default.clearGameTicket();
    }
  }, {
    key: 'setObserveInfo',
    value: function setObserveInfo(opt) {
      this.observeInfo.headimg = opt.headimg;
      this.observeInfo.nickName = opt.nickName;
    }
  }, {
    key: 'clearObserveInfo',
    value: function clearObserveInfo() {
      this.observeInfo.headimg = null;
      this.observeInfo.nickName = null;
    }
  }, {
    key: 'getNextSunday',
    value: function getNextSunday() {
      var now = new Date();
      var day = now.getDay();
      now.setHours(0, 0, 0, 0);
      var expire = now.valueOf() + (8 - day) % 7 * 24 * 60 * 60 * 1000;
      return expire;
    }
  }]);

  return GameModel;
}();

exports.default = GameModel;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GameView = function () {
  function GameView(game) {
    _classCallCheck(this, GameView);

    this.game = game;
  }

  _createClass(GameView, [{
    key: 'init',
    value: function init() {}
  }, {
    key: 'showIdentifyModeErr',
    value: function showIdentifyModeErr(wording) {
      this.showModal(wording);
    }
  }, {
    key: 'showNoSession',
    value: function showNoSession() {
      this.showModal();
    }
  }, {
    key: 'showGetPkIdFail',
    value: function showGetPkIdFail() {
      this.showModal();
    }
  }, {
    key: 'showGroupShareFail',
    value: function showGroupShareFail() {
      var wording = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '网络异常,点击确定回到游戏';

      this.showModal(wording);
    }
  }, {
    key: 'showGoToBattleFail',
    value: function showGoToBattleFail() {
      this.showModal();
    }
  }, {
    key: 'showUploadPkScoreFail',
    value: function showUploadPkScoreFail() {
      this.showModal('数据上传失败');
    }
  }, {
    key: 'showShareObserveCardFail',
    value: function showShareObserveCardFail(res) {
      this.showModal(res);
    }
  }, {
    key: 'showObserveStateFail',
    value: function showObserveStateFail() {
      this.showModal('服务器异常');
    }
  }, {
    key: 'showModal',
    value: function showModal() {
      var wording = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '网络异常,点击确定回到游戏';

      wx.showModal({
        title: '提示',
        content: wording,
        showCancel: false
      });
    }
  }, {
    key: 'showServeConfigForbiddenObserveMode',
    value: function showServeConfigForbiddenObserveMode() {
      this.showModal('当前围观人数过多，请稍后再试');
    }
  }, {
    key: 'showServeConfigForbiddenGroupShare',
    value: function showServeConfigForbiddenGroupShare() {
      this.showModal('查看群排行人数过多，请稍后再试');
    }
  }, {
    key: 'showSocketCloseErr',
    value: function showSocketCloseErr() {
      // this.showModal('网络连接异常，点击确定回到游戏')
    }
  }, {
    key: 'showSyncopErr',
    value: function showSyncopErr() {
      return;
    }
  }]);

  return GameView;
}();

exports.default = GameView;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

var _config = __webpack_require__(2);

var _animation = __webpack_require__(4);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HEIGHT = window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth;
var WIDTH = window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth;

var Ground = function () {
	function Ground() {
		_classCallCheck(this, Ground);

		/*var vertexShader = [
      'varying vec3 vWorldPosition;',
      'void main()',
      '{',
      '  vec4 worldPosition = modelMatrix * vec4(position, 1.0);',
      '  worldPosition = worldPosition.xyz;',
      '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
      '}'
    ].join('\n');
  	var fragmentShader = [    
      'uniform vec3 topColor;',
      'uniform vec3 bottomColor;',
      'uniform float offset;',
      'uniform float exponent;',
  	    'varying vec3 vWorldPosition;',
      'void main()',
      '{',
      '  float h = normalize(vWorldPosition + offset).y;',
      '  gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);',
      '}'
    ].join('\n')
  	var uniforms = {
  	topColor: { type: "c", value: new THREE.Color(0x0077ff) },
  	bottomColor: { type: "c", value: new THREE.Color(0xffffff) },
  	offset: { type: "f", value: 400 },
  	exponent: {type: "f", value: 0.6 }
  }*/
		this.obj = new THREE.Object3D();
		this.obj.name = 'ground';
		var geometry = new THREE.PlaneGeometry(WIDTH / HEIGHT * _config.FRUSTUMSIZE, _config.FRUSTUMSIZE);
		this.materials = [];
		var colors = [['rgba(215, 219, 230, 1)', 'rgba(188, 190, 199, 1)'], ['rgba(255, 231, 220, 1)', 'rgba(255, 196, 204, 1)'], ['rgba(255, 224, 163, 1)', 'rgba(255, 202, 126, 1)'], ['rgba(255, 248, 185, 1)', 'rgba(255, 245, 139, 1)'], ['rgba(218, 244, 255, 1)', 'rgba(207, 233, 210, 1)'], ['rgba(219, 235, 255, 1)', 'rgba(185, 213, 235, 1)'], ['rgba(216, 218, 255, 1)', 'rgba(165, 176, 232, 1)'], ['rgba(207, 207, 207, 1)', 'rgba(199, 196, 201, 1)']];
		var that = this;
		for (var i = 0; i < 7; ++i) {
			var texture = new THREE.Texture(that.generateLaserBodyCanvas(colors[i][0], colors[i][1]));
			texture.needsUpdate = true;
			var material = new THREE.MeshBasicMaterial({
				map: texture,
				opacity: 1,
				transparent: true
			});
			that.materials.push(material);
			var ground = new THREE.Mesh(geometry, material);
			ground.position.z = -(i + 1) * 0.1;
			ground.name = i;
			ground.updateMatrix();
			ground.matrixAutoUpdate = false;
			that.obj.add(ground);
			//if ( i >= 1) ground.visible = false;

		}
		for (var i = 1; i < 7; ++i) {
			this.obj.children[i].visible = false;
		}
		this.current = 0;
		//this.obj.receiveShadow = true;
		//this.obj.rotation.x = -Math.PI / 2 ;
		//this.obj.rotation.z = -Math.PI / 3 ;
		//this.obj.matrixAutoUpdate = false;
	}

	_createClass(Ground, [{
		key: 'generateLaserBodyCanvas',
		value: function generateLaserBodyCanvas(colorStart, colorStop) {
			// init canvas
			// set gradient
			var canvas = document.createElement('canvas');
			var context = canvas.getContext('2d');
			canvas.width = 64;
			canvas.height = 64;
			context.clearRect(0, 0, canvas.width, canvas.height);
			var gradient = context.createLinearGradient(0, 0, 0, canvas.height);
			//gradient.addColorStop( 0.3, 'rgba(40, 40, 40, 1)' );
			//gradient.addColorStop( 0.5, 'rgba(255, 255, 255, 1)' );
			//gradient.addColorStop( 0.7, 'rgba(40, 40, 40, 1)' );
			gradient.addColorStop(0, colorStart);
			gradient.addColorStop(1, colorStop);
			// fill the rectangle
			context.fillStyle = gradient;
			context.fillRect(0, 0, canvas.width, canvas.height);
			// return the just built canvas 

			return canvas;
		}
	}, {
		key: 'changeColor',
		value: function changeColor() {
			var _this = this;

			var next = this.current + 1 > 6 ? 0 : this.current + 1;
			var current = this.current;
			_animation.customAnimation.to(this.materials[this.current], 5, { opacity: 0, onComplete: function onComplete() {
					_this.obj.children[current].visible = false;
				} });
			this.obj.children[next].visible = true;
			_animation.customAnimation.to(this.materials[next], 4, { opacity: 1 });
			this.current = next;
		}
	}]);

	return Ground;
}();

exports.default = Ground;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _network = __webpack_require__(3);

var _network2 = _interopRequireDefault(_network);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var reporter = function () {
  function reporter() {
    _classCallCheck(this, reporter);

    this.timeOut = null;
    this.reportList = [];
    this.pkState = {
      isGroup: 0,
      score: 0
    };
    this.singleState = 0;
    this.observeState = {
      startTime: 0,
      success: 0
    };
    this.playerState = {
      startTime: 0,
      maxAudience: 0
    };
    this.gameStartTime = 0;

    try {
      var res = wx.getSystemInfoSync();
      this.clientInfo = {
        platform: res.platform,
        brand: res.brand,
        model: res.model,
        system: res.system
      };
    } catch (error) {
      console.log(error);
    }
  }

  _createClass(reporter, [{
    key: 'getTime',
    value: function getTime() {
      var time = Date.now();
      time = Math.floor(time / 1000);
      return time;
    }

    // EnterReport:     //进入小程序
    // ts            //uint32，秒级日志时间戳
    // type          //uint32，填0
    // scene         //uint32, 小程序进入场景

  }, {
    key: 'enterReport',
    value: function enterReport(scene) {
      this.gameStartTime = this.getTime();
      if (!scene) {
        // console.log('enterReport need scene')
        return;
      }
      var data = {
        ts: this.getTime(),
        type: 0,
        scene: scene
      };
      this.reportList.push(data);
    }

    // QuitReport:     //退出小程序
    // ts            //uint32，秒级日志时间戳
    // type          //uint32，填1

  }, {
    key: 'quitReport',
    value: function quitReport() {
      if (!this.gameStartTime) {
        return;
      }
      var data = {
        ts: this.getTime(),
        type: 1,
        duration: this.getTime() - this.gameStartTime
      };
      this.reportList.push(data);
    }

    // PlayGameReport:  //游戏局内上报
    // ts            //uint32，秒级日志时间戳
    // type          //uint32，填2
    // score         //uint32, 当局分数
    // best_score    //uint32, 历史最高分（包括当局）
    // break_record  //uint32, 当局是否打破记录
    // duration      //uint32，秒级游戏时长
    // times         //unit32，次数

  }, {
    key: 'playGameReport',
    value: function playGameReport(score, bestScore, times) {
      if (!this.singleState) {
        return;
      }
      var data = {
        ts: this.getTime(),
        type: 2,
        score: score,
        best_score: bestScore,
        break_record: score > bestScore ? 1 : 0,
        duration: this.getTime() - this.singleState,
        times: times
      };
      this.reportList.push(data);
      this.singleState = 0;
    }
  }, {
    key: 'playGameReportStart',
    value: function playGameReportStart() {
      this.singleState = this.getTime();
    }

    // ShareAudienceReport:   //分享围观上报
    // ts            //uint32，秒级日志时间戳
    // type          //uint32，填3
    // is_group      //uint32，是否分享到群聊，单聊：0，群聊：1

  }, {
    key: 'shareAudienceReport',
    value: function shareAudienceReport(isGroup) {
      var data = {
        ts: this.getTime(),
        type: 3,
        is_group: isGroup
      };
      this.reportList.push(data);
    }

    // PlayAudienceReport:    //围观中玩游戏,以局为单位
    // ts            //uint32，秒级日志时间戳
    // type          //uint32，填4
    // duration      //uint32，在围观中玩游戏持续时长，秒级
    // max_audience  //uint32，累计围观观众人数

  }, {
    key: 'playAudienceReport',
    value: function playAudienceReport() {
      if (!this.playerState.startTime) {
        return;
      }
      var data = {
        ts: this.getTime(),
        type: 4,
        duration: this.getTime() - this.playerState.startTime,
        max_audience: this.playerState.maxAudience
      };
      this.reportList.push(data);
      this.playerState.startTime = 0;
      this.playerState.maxAudience = 0;
    }

    // 新增上报，每次游戏开始都加一条
    // type 10

  }, {
    key: 'playAudienceReportStart',
    value: function playAudienceReportStart() {
      this.playerState.startTime = this.getTime();
      var data = {
        ts: this.getTime(),
        type: 10
      };
      this.reportList.push(data);
    }
  }, {
    key: 'playAudienceReportMaxPeople',
    value: function playAudienceReportMaxPeople(n) {
      if (this.playerState.maxAudience < n) {

        this.playerState.maxAudience = n;
      }
    }

    // JoinAudienceReport:    //观众进入围观
    // ts            //uint32，秒级日志时间戳
    // type          //uint32，填5
    // duration      //uint32，围观时长
    // join_audience_success //uint32，是否成功看到玩家玩游戏，0：没看到；1：看到
    // 出口，再来一句，join失败

  }, {
    key: 'joinAudienceReport',
    value: function joinAudienceReport() {
      var time = this.observeState.startTime == 0 ? 0 : this.getTime() - this.observeState.startTime;
      var data = {
        ts: this.getTime(),
        type: 5,
        duration: time,
        join_audience_success: this.observeState.success
      };
      this.reportList.push(data);
      this.observeState.startTime = 0;
      this.observeState.success = 0;
    }

    // 入口joinSuccess

  }, {
    key: 'joinAudienceReportStart',
    value: function joinAudienceReportStart() {
      this.observeState.startTime = this.getTime();
      this.observeState.success = 1;
    }

    // ShareRankReport:       //分享排行榜
    // ts            //uint32，秒级日志时间戳
    // type          //uint32，填6
    // is_group      //uint32，是否分享到群聊，单聊：0，群聊：1

  }, {
    key: 'shareGroupReport',
    value: function shareGroupReport(isGroup) {
      var data = {
        ts: this.getTime(),
        type: 6,
        is_group: isGroup
      };
      this.reportList.push(data);
    }

    // SharePKReport：        //分享PK
    // ts            //uint32，秒级日志时间戳
    // type          //uint32，填7
    // is_group      //uint32，是否分享到群聊，单聊：0，群聊：1

  }, {
    key: 'sharePKReport',
    value: function sharePKReport(isGroup) {
      var data = {
        ts: this.getTime(),
        type: 7,
        is_group: isGroup
      };
      this.reportList.push(data);
    }

    // JoinPKReport:          //点击卡片进入PK页面
    // ts            //uint32，秒级日志时间戳
    // type          //uint32，填8
    // is_group      //uint32，是否分享到群聊，单聊：0，群聊：1

  }, {
    key: 'joinPKReport',
    value: function joinPKReport(isGroup) {
      var data = {
        ts: this.getTime(),
        type: 8,
        is_group: isGroup
      };
      this.reportList.push(data);
    }

    // PlayPKReport：
    // ts            //uint32，秒级日志时间戳
    // type          //uint32，填9
    // is_group      //uint32，是否来自群聊，单聊：0，群聊：1
    // result        //uint32，0：挑战失败；1：平局；3：挑战成功

  }, {
    key: 'playPKReport',
    value: function playPKReport(currentScore) {
      var result = 0;
      if (currentScore == this.pkState.score) {
        result = 1;
      }
      if (currentScore > this.pkState.score) {
        result = 3;
      }
      var data = {
        ts: this.getTime(),
        type: 9,
        is_group: this.pkState.isGroup,
        result: result
      };
      this.reportList.push(data);
    }
  }, {
    key: 'playPKReportStart',
    value: function playPKReportStart(isGroup) {
      this.pkState.isGroup = isGroup;
    }
  }, {
    key: 'playPKScore',
    value: function playPKScore(score) {
      this.pkState.score = score;
    }
  }, {
    key: 'resetPKReport',
    value: function resetPKReport() {
      this.pkState.isGroup = 0;
      this.pkState.score = 0;
    }
  }, {
    key: 'sendReport',
    value: function sendReport() {
      //console.log(this.reportList)
      // return
      if (this.reportList.length) {
        _network2.default.sendReport(this.reportList, this.clientInfo);
        this.reportList = [];
      }
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timeOut) {
        clearInterval(this.timeOut);
      }
    }
  }, {
    key: 'setTimer',
    value: function setTimer(REPORTERTIMEOUT) {
      this.timeOut = setInterval(this.sendReport.bind(this), REPORTERTIMEOUT);
    }
  }]);

  return reporter;
}();

exports.default = reporter;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _session = __webpack_require__(6);

var _session2 = _interopRequireDefault(_session);

var _network = __webpack_require__(3);

var _network2 = _interopRequireDefault(_network);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GameSocket = function () {
  function GameSocket(game) {
    var _this = this;

    _classCallCheck(this, GameSocket);

    this.alive = false;
    this.noErr = false;
    // this.joinGame = false
    this.game = game;

    this.handlers = {};
    this.handleSocketErr = '';
    // 用来清除心跳，防止发送过多心跳
    this.heartBeat = [];

    /**
     * 命令池,数据格式
     * cmdPool = {
     *  'gameId': {
     *    n:当前帧序号
     *    arr:[]序号指令池
     *  }
     * }
     */
    this.cmdPool = {};

    wx.onSocketOpen(function (res) {
      // console.log('Socket open', res)
      _this.joinGame();
    });

    wx.onSocketClose(function (res) {
      if (_this.game.mode == 'player' && !_this.noErr) {
        _network2.default.quitGame();
        _this.game.gameCtrl.onSocketCloseErr();
      }
      if (_this.game.mode == 'observe' && !_this.noErr) {
        _this.game.gameCtrl.onSocketCloseErr();
      }
      _this.alive = false;
      // console.log('Socket close', res)
    });

    wx.onSocketError(function (res) {
      // console.log('Socket connect fail', res)

      // 错误处理
      // if (typeof this.handleSocketErr == 'function') {
      //   this.handleSocketErr()
      // }
    });

    wx.onSocketMessage(function (res) {
      // console.log('Socket receive message1', res)
      // wx.hideLoading()

      // 清空心跳队列
      _this.cleanHeartBeat();

      var data;
      try {
        data = JSON.parse(res.data);
      } catch (error) {
        // console.log('onSocketMessage err: ', error, 'socket will be close')
        _this.game.handleWxOnError({
          message: 'socket receive wrong msg JSON.parse(res.data) error',
          stack: ''
        });
        wx.closeSocket();
        return;
      }

      // 发送帧的确认帧
      if (data.cmd === 106) {
        _this.handleACK(data);
      }

      // 加入游戏响应 
      if (data.cmd === 101) {
        _this.handleJoinGame(data);
      }

      if (data.cmd === 104) {
        // console.log('receive heart beat')
      }

      if (data.cmd === 108) {
        _this.handlePeopleCome(data);
      }

      if (data.cmd === 102) {
        _this.receiveCommand(data);
      }

      // 围观模式下
      if (data.cmd == 109) {
        _this.close();
      }

      // 主播退出直播了
      if (data.cmd == 107) {
        _this.handlePlayerOut();
      }

      _this.heartBeat.push(setTimeout(_this.sendHeartBeat.bind(_this), 5000));
      // this.heartBeat.push(setTimeout(this.sendHeartBeat.bind(this), 1000))
    });
  }

  _createClass(GameSocket, [{
    key: 'cleanHeartBeat',
    value: function cleanHeartBeat() {
      if (this.heartBeat.length) {
        while (this.heartBeat.length) {
          var heartBeat = this.heartBeat.pop();
          clearTimeout(heartBeat);
        }
      }
    }
  }, {
    key: 'handleSocketOpen',
    value: function handleSocketOpen() {
      this.joinGame();
      this.alive = true;
    }
  }, {
    key: 'connectSocket',
    value: function connectSocket() {
      var _this2 = this;

      this.alive = true;
      wx.connectSocket({
        // url: 'ws://mptest.weixin.qq.com/game/',
        url: 'wss://wxagame.weixin.qq.com',
        fail: function fail() {
          _this2.alive = false;
          // this.handleConnectSocketFail()
        }
      });
    }

    // handleConnectSocketFail() {
    //   this.alive = false
    //   if (this.game.mode == 'player') {
    //     this.game.shareObservCardFail()
    //   }
    //   if (this.game.mode == 'observe') {
    //     this.handleSocketErr(true)
    //   }
    // }

  }, {
    key: 'addHandler',
    value: function addHandler(cmd, cb) {
      if (!this.handlers[cmd]) {
        this.handlers[cmd] = [cb];
      } else {
        this.handlers[cmd].push(cb);
      }
    }

    // 发送指令

  }, {
    key: 'sendCommand',
    value: function sendCommand(cmdSequence, data) {
      var gameId = _session2.default.gameId;
      var gameTicket = _session2.default.gameTicket;
      if (!gameId || !gameTicket || !cmdSequence) {
        return;
      }
      if (typeof gameId !== 'string') {
        console.warn('Socket send cmd need gameId');
        return;
      }

      var obj = {
        cmd: 102,
        i: gameId,
        n: cmdSequence,
        k: gameTicket,
        o: [JSON.stringify(data)]
        // const obj = {
        //   cmd: 102,
        //   i: gameId,
        //   k: gameTicket,
        //   o: []
        // }
        // console.log('send Message', JSON.stringify(obj))
      };wx.sendSocketMessage({
        data: JSON.stringify(obj)
      });
    }
  }, {
    key: 'sendNullCommand',
    value: function sendNullCommand() {
      var gameId = _session2.default.gameId;
      var gameTicket = _session2.default.gameTicket;
      if (!gameId || !gameTicket) {
        return;
      }
      if (typeof gameId !== 'string') {
        console.warn('Socket send cmd need gameId');
        return;
      }

      var obj = {
        cmd: 102,
        i: gameId,
        k: gameTicket,
        o: []
        // console.log('send heartBeat Message', JSON.stringify(obj))
      };wx.sendSocketMessage({
        data: JSON.stringify(obj)
      });
    }
  }, {
    key: 'getCommand',
    value: function getCommand(gameId) {}
  }, {
    key: 'onPeopleCome',
    value: function onPeopleCome(cb) {
      this.peopleCome = cb;
    }
  }, {
    key: 'onReciveCommand',
    value: function onReciveCommand(cb) {
      this.observerMessage = cb;
    }
  }, {
    key: 'onJoinSuccess',
    value: function onJoinSuccess(cb) {
      this.joinSuccess = cb;
    }
  }, {
    key: 'onPlayerOut',
    value: function onPlayerOut(cb) {
      this.playerOutHandler = cb;
    }

    // 接收到指令

  }, {
    key: 'receiveCommand',
    value: function receiveCommand(res) {
      // console.log('receiveCommand',res)
      if (typeof this.observerMessage !== 'function') {
        return;
      }
      if (!res.o) {
        return;
      }
      if (!res.o[0]) {
        return;
      }
      if (!res.o[0].o) {
        return;
      }
      this.observerMessage(res.n, JSON.parse(res.o[0].o));
      return;
    }
  }, {
    key: 'handlePeopleCome',
    value: function handlePeopleCome(res) {
      if (typeof this.peopleCome !== 'function') {
        return;
      }
      this.peopleCome(res);
      return;
    }

    // 接收到指令确认帧

  }, {
    key: 'receiveACK',
    value: function receiveACK() {}

    // 加入游戏
    /**
     *  observe : handleConnectSocketfail => handleSocketFucked
     */

  }, {
    key: 'joinGame',
    value: function joinGame() {
      // console.log('Socket open success')
      var gameId = _session2.default.gameId;
      if (!_session2.default.sessionId || !gameId) {
        // console.log('Socket join game fail')
        // this.handleConnectSocketFail()
        return;
      }
      var obj = {
        cmd: 101,
        game_id: gameId,
        fast: 1,
        session_id: _session2.default.sessionId
      };

      wx.sendSocketMessage({
        data: JSON.stringify(obj)
      });
      // console.log('Socket join game', obj)
    }
  }, {
    key: 'handleACK',
    value: function handleACK(data) {
      if (this.handlers['ack']) {
        this.handlers['ack'].forEach(function (cb) {
          cb(data);
        });
      }
    }
  }, {
    key: 'handleJoinGame',
    value: function handleJoinGame(data) {
      // console.log(data)
      if (this.game.mode == 'observe') {
        switch (data.ret) {
          // 成功
          case 0:
            this.joinSuccess(true);
            break;
          // 不活跃
          case 2:
            this.joinSuccess(true);
            break;
          default:
            this.joinSuccess(false);
            break;
        }
      } else {
        if (data.ret != 0) {
          this.joinSuccess(false);
        } else {
          this.joinSuccess(true);
        }
      }

      // if (this.game.mode == 'player') {
      //   if (data.ret != 0) {
      //     this.close()
      //     this.handleConnectSocketFail()
      //   } else {
      //     this.joinSuccess()
      //   }
      // }
    }
  }, {
    key: 'sendHeartBeat',
    value: function sendHeartBeat() {
      if (this.game.mode == 'player') {
        this.sendNullCommand();
      } else {

        var obj = {
          cmd: 104
        };
        wx.sendSocketMessage({
          data: JSON.stringify(obj)
        });
      }
    }

    // reset() {
    //   this.handlers = {}
    //   this.heartBeat = []
    //   this.cmdPool = {}
    // }

  }, {
    key: 'quitObserve',
    value: function quitObserve() {
      if (!this.alive) {
        return;
      }
      // console.log('quitObservequitObserve')
      var obj = {
        cmd: 109,
        fast: 1,
        game_id: _session2.default.gameId,
        session_id: _session2.default.sessionId
        // console.log(obj)
      };wx.sendSocketMessage({
        data: JSON.stringify(obj)
      });
    }
  }, {
    key: 'close',
    value: function close() {
      var _this3 = this;

      if (!this.alive) {
        return;
      }

      this.alive = false;
      this.noErr = true;
      // console.log('emmit close')
      wx.closeSocket();

      _session2.default.clearShareTicket();
      _session2.default.clearGameId();

      setTimeout(function () {
        _this3.reset();
      }, 1000);
    }
  }, {
    key: 'onSocketErr',
    value: function onSocketErr(cb) {
      this.handleSocketErr = cb;
    }
  }, {
    key: 'reset',
    value: function reset() {
      this.alive = false;
      this.noErr = false;
    }
  }, {
    key: 'handlePlayerOut',
    value: function handlePlayerOut() {
      if (typeof this.playerOutHandler == 'function') {
        this.playerOutHandler();
      }
    }
  }]);

  return GameSocket;
}();

exports.default = GameSocket;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

var _config = __webpack_require__(2);

var _animation = __webpack_require__(4);

var _storage = __webpack_require__(5);

var _storage2 = _interopRequireDefault(_storage);

var _scrollHandler = __webpack_require__(11);

var _scrollHandler2 = _interopRequireDefault(_scrollHandler);

var _report = __webpack_require__(55);

var _report2 = _interopRequireDefault(_report);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Dpr = window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio; // 当前屏幕的Dpr， i7p 设置3 会挂
var W = window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth; // CSS像素
var H = window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth; // CSS像素
var HEIGHT = H * Dpr; // 设备像素
var WIDTH = W * Dpr; // 设备像素
var planList = ['btn', 'bg', 'list1', 'list2'];
var CANVASTYPE = { // 当前绘制的2D场景
	'friendRank': 0, // 好友排行榜
	'groupRank': 1,
	'gameOver': 2,
	'start': 3,
	'pk': 4,
	'lookers': 5,
	'gameOverNew': 6, //结算页显示新手引导
	'gameOverHighest': 7, // 结算页达到排行榜最高 / 历史最高
	'beginner': 8 //新手引导页
};
var frustumSizeHeight = _config.FRUSTUMSIZE; // 动画的尺寸单位坐标高度
var frustumSizeWidth = WIDTH / HEIGHT * frustumSizeHeight; // 动画的尺寸单位坐标高度

var DEBUG = false;
var showDebugImg = false;

var ListLineHeight = 60;

var family = wx.loadFont('res/num.ttf');

var Rank = function () {
	function Rank(options) {
		_classCallCheck(this, Rank);

		this.texture = {};
		this.material = {};
		this.geometry = {};
		this.obj = {};
		this.canvas = {};
		this.context = {};
		this._touchInfo = { trackingID: -1, maxDy: 0, maxDx: 0 };
		this.options = Object.assign({}, {}, options);
		this.imgid = {
			'btn': 0,
			'bg': 0,
			'list1': 0,
			'list2': 0
		};

		// 相关回调
		// --- 好友排行榜：
		this.options.onGroupShare = options.onGroupShare; // 群分享的时候的回调
		this.options.friendRankReturn = options.friendRankReturn; // 好友排行榜返回上一层， 点击右上角X的回调

		// --- 群排行榜
		this.options.groupPlayGame = options.groupPlayGame; // 我也来玩一局的回调

		// --- 结算页：
		this.options.onClickRank = options.onClickRank; // 点击排行榜的回调
		this.options.onClickReplay = options.onClickReplay; // 点击在玩一局的回调, 排行榜再晚一局的回调
		this.options.onClickShare = options.onClickShare; // 点击分享挑战的回调
		this.options.onClickPureShare = options.onClickPureShare; // 纯分享，用户点击将打开首页

		// --- 首页：
		this.options.onClickStart = options.onClickStart; // 点击开始游戏回调
		this.options.onShowFriendRank = options.onShowFriendRank; // 点击排行榜的回调

		// --- 挑战页：
		this.options.onBattlePlay = options.onBattlePlay; // 玩一局， pk 表示当前分数是pk的， '' 表示当前只是自己玩一局

		// --- 围观页：
		this.options.onLookersStart = options.onLookersStart; // 围观页面，开启新的一局


		// 裁剪区域的大小 - 好友/群排行榜
		this.p0 = new THREE.Vector3(0, 0, 9);
		this.p1 = new THREE.Vector3(-frustumSizeWidth * (0.5 - this._cx(30) / WIDTH), (0.5 - this._cy(143) / HEIGHT) * frustumSizeHeight, 9);
		this.p2 = new THREE.Vector3(frustumSizeWidth * (0.5 - this._cx(30) / WIDTH), frustumSizeHeight * (0.5 - this._cy(143) / HEIGHT), 9);
		this.p3 = new THREE.Vector3(frustumSizeWidth * (0.5 - this._cx(30) / WIDTH), -frustumSizeHeight * (0.5 - this._cy(144) / HEIGHT), 9);
		this.p4 = new THREE.Vector3(-frustumSizeWidth * (0.5 - this._cx(30) / WIDTH), -frustumSizeHeight * (0.5 - this._cy(144) / HEIGHT), 9);

		// 裁剪区域大小 - 挑战
		this.p5 = new THREE.Vector3(-frustumSizeWidth * (0.5 - this._cx(30) / WIDTH), (0.5 - this._cy(205) / HEIGHT) * frustumSizeHeight, 9);
		this.p6 = new THREE.Vector3(frustumSizeWidth * (0.5 - this._cx(30) / WIDTH), frustumSizeHeight * (0.5 - this._cy(205) / HEIGHT), 9);
		this.p7 = new THREE.Vector3(frustumSizeWidth * (0.5 - this._cx(30) / WIDTH), -frustumSizeHeight * (0.5 - this._cy(104) / HEIGHT), 9);
		this.p8 = new THREE.Vector3(-frustumSizeWidth * (0.5 - this._cx(30) / WIDTH), -frustumSizeHeight * (0.5 - this._cy(104) / HEIGHT), 9);

		// DEBUG 的时候多加一层
		if (DEBUG) {
			planList = ['sample', 'btn', 'bg', 'list1', 'list2'];
		}

		// 接口测试：
		// --- 新手指引
		// this.showBeginnerPage();
		// --- 排行榜:
		// this.showFriendRankList(); // 显示好友排行榜 
		// this.showGroupRankList(); // 显示群排行 
		// --- 结算页：
		// this.showGameOverPage({
		//  	score : 0, // 当局分数
		//  	highest_score : 1078, // 历史最高分
		//  	start_time : 2511922923, // 起始时间的秒级时间戳
		//  	week_best_score : 0, // 本周最高分
		//  	game_cnt : 5
		// });

		// --- 首页：
		// this.showStartPage(); 
		// --- 挑战页：
		// this.showPkPage({
		// 	data : {
		// 		organizerInfo : { // 擂主
		// 			headimg : '', // 擂主的头像
		// 			nickname : '游戏小子11111111111111111111111', // 擂主的名字
		// 			score_info : [{
		// 				score : 912 // 擂主的分数
		// 			}],
		// 			left_time : 10, // 创建时间的秒级时间戳
		// 			is_self : 0, // 0 - 不是当前用户，1- 是当前用户
		// 		},
		// 		pkListInfo : [{ // 挑战记录， 不包含当前用户的成绩
		// 			headimg : '', 
		// 			nickname : 'bbbbbbbbbbbbbbbbbb',
		// 			score_info : [{
		// 				score : 4567
		// 			}],
		// 			is_self : 0, // 0 - 不是当前用户，1- 是当前用户
		// 		},{
		// 			headimg : '',
		// 			nickname : 'vvv',
		// 			score_info : [{
		// 				score : 233
		// 			}],
		// 			is_self : 0, // 0 - 不是当前用户，1- 是当前用户
		// 		},{
		// 			headimg : '',
		// 			nickname : 'vvv',
		// 			score_info : [{
		// 				score : 233
		// 			}],
		// 			is_self : 0, // 0 - 不是当前用户，1- 是当前用户
		// 		},{
		// 			headimg : '',
		// 			nickname : 'vvv',
		// 			score_info : [{
		// 				score : 233
		// 			}],
		// 			is_self : 0, // 0 - 不是当前用户，1- 是当前用户
		// 		}],
		// 		gg_score : 1032 // 任何num 都是合法的， 如果没有结算，则传个 undefined 过来
		// 	}
		// })
		// --- 围观页面  按钮居中/背景换成切片/头像白色描边/ 正在玩的分数间距拉大
		// this.showLookersPage({
		// 	headimg : '',
		// 	nickname : 'bbbb',
		// 	type : 'out', // in - 正在玩, gg - 结算, out - 退出    
		// 	score : 666
		// }); // 围观者的游戏中的画面
		// 隐藏这个界面：
		// this.hide2D()
	}

	// ----------------- show/hide 方法 -----------------


	_createClass(Rank, [{
		key: 'showFriendRankList',
		value: function showFriendRankList(opt) {
			this.hide2D();
			this.showState = true;
			opt = opt || {};
			this.canvasType = CANVASTYPE['friendRank']; // 当前绘制的2D场景
			this.myUserInfo = _storage2.default.getMyUserInfo() || {}; // 更新用户信息
			this.myUserInfo.week_best_score = opt.week_best_score || 0;
			this._createPlane();
			this._updateClip();
			this._drawRankListBg(); // 背景绘制
			this.renderRankList(_storage2.default.getFriendsScore());
		}
	}, {
		key: 'showGroupRankList',
		value: function showGroupRankList(list, myUserInfo) {
			this.hide2D();
			this.showState = true;
			this.canvasType = CANVASTYPE['groupRank'];
			this.myUserInfo = myUserInfo || {
				headimg: '',
				nickname: '',
				week_best_score: 0,
				grade: 1
			};
			this._createPlane();
			this._updateClip();
			this.renderRankList(list);
			this._drawRankListBg(); // 背景绘制
		}
	}, {
		key: 'showGameOverPage',
		value: function showGameOverPage(opt) {
			this.hide2D();
			// Report.frameReport('xxxxx', 60);
			this.showState = true;
			/*opt = {
    	score : 1100, // 当局分数
    	highest_score : 90, // 历史最高分
    	start_time : 2511922923, // 起始时间的秒级时间戳
    	week_best_score : 0, // 本周最高分
    	game_cnt : 5
   }*/
			opt = opt || {};
			this.opt = opt || this.opt;

			this._createPlane();

			// 找出那个排行 - 
			this.myUserInfo = _storage2.default.getMyUserInfo() || { headimg: '', nickname: '', week_best_score: 0, score_info: [{ score: 0 }] // 更新用户信息
			};this.myUserInfo.last_week_best_score = opt.week_best_score;
			this.myUserInfo.week_best_score = Math.max(opt.week_best_score, opt.score) || 0;
			var friendRankList = _storage2.default.getFriendsScore() || [];
			friendRankList.push(this.myUserInfo); // 把自己的最高分放进去
			var rank_list = this._rerank(friendRankList);
			this.sotedRankList = rank_list;
			// console.log('vicky 拿到的结算页的数据： ')
			// console.log(opt)
			// console.log(this.myUserInfo)
			// console.log(friendRankList)
			this.myidx = rank_list.findIndex(this._findSelfIndex.bind(this)) + 1; // 找到自己的index

			// 超越了多少人
			if (opt.score >= opt.highest_score || opt.score >= this.myUserInfo.last_week_best_score) {
				// 达到历史最高分 或者 本周最高分， 计算 超越的人数
				var userInfo = _storage2.default.getMyUserInfo() || { headimg: '', nickname: '', week_best_score: 0, score_info: [{ score: 0 }] };
				userInfo.week_best_score = opt.score;
				var friendRank1 = _storage2.default.getFriendsScore() || [];
				this.changlleList = [];
				for (var j = 0; j < friendRank1.length; j++) {
					if (friendRank1[j].week_best_score < opt.score && friendRank1[j].week_best_score > this.myUserInfo.last_week_best_score) {
						// 显示新超越的人数， 
						this.changlleList.push(friendRank1[j]);
					}
				}
			}
			// console.log(' 超越好友数：', this.changlleList)
			// 新手指引，走普通结算
			/*if(opt.score < 5 && opt.game_cnt < 5){
   	this.canvasType = CANVASTYPE['gameOver']
   	this._drawGameOver();
   } else */if (opt.score > opt.highest_score) {
				// 历史最高分
				this.canvasType = CANVASTYPE['gameOverHighest'];
				this.opt.type = 'history';
				this.opt.msg = '历史最高分';
				this._drawGameOverHighest(this.opt, 'history');
			} else if (rank_list.length > 1 && opt.score >= rank_list[0].week_best_score) {
				// 达到排行榜冠军
				this.canvasType = CANVASTYPE['gameOverHighest'];
				this.opt.type = 'rank';
				this._drawGameOverHighest(this.opt, 'rank');
			} else if (opt.score > this.myUserInfo.last_week_best_score) {
				// 本周最高分
				this.canvasType = CANVASTYPE['gameOverHighest'];
				this.opt.type = 'history';
				this.opt.msg = '本周最高分';
				this._drawGameOverHighest(this.opt, 'history');
			} else {
				// 普通结算
				this.canvasType = CANVASTYPE['gameOver'];
				this._drawGameOver();
			}
		}
	}, {
		key: 'showStartPage',
		value: function showStartPage(opt) {
			this.hide2D();
			if (DEBUG) return;
			this.showState = true;
			this.canvasType = CANVASTYPE['start'];
			this._createPlane();
			this._drawStart(opt);
		}
	}, {
		key: 'showPkPage',
		value: function showPkPage(opt) {
			this.hide2D();
			// console.log('vicky 拿到的pk数据')
			// console.log(opt)
			this.showState = true;
			opt = opt || {};
			this.data = opt.data;
			this.canvasType = CANVASTYPE['pk'];
			this._createPlane();
			this._updateClip();
			this.myidx = this.data.pkListInfo.findIndex(this._findPartner) + 1;
			this.myUserInfo = this.data.pkListInfo[this.myidx - 1] || _storage2.default.getMyUserInfo();
			this.renderRankList(this.data.pkListInfo);
			this._drawPKListBg();
		}
	}, {
		key: 'showLookersPage',
		value: function showLookersPage(opt) {
			this.hide2D();
			this.showState = true;
			this.canvasType = CANVASTYPE['lookers'];
			this._createPlane();
			this._drawLookers(opt);
		}
	}, {
		key: 'showBeginnerPage',
		value: function showBeginnerPage() {
			this.hide2D();
			this.showState = true;
			this.canvasType = CANVASTYPE['beginner'];
			this._createPlane();
			this._drawBeginner();
		}
	}, {
		key: 'hide2D',
		value: function hide2D() {
			if (DEBUG) return;
			this.showState = false;
			for (var i = 0; i < planList.length; i++) {
				if (!this.obj[planList[i]]) continue;
				this.obj[planList[i]].visible = false;
				this.options.camera.remove(this.obj[planList[i]]);
			}
		}
	}, {
		key: 'hide2DGradually',
		value: function hide2DGradually() {
			if (DEBUG) return;
			var that = this;
			for (var i = 0; i < planList.length; i++) {
				if (!this.obj[planList[i]]) continue;
				_animation.customAnimation.to(this.material[planList[i]], 1, { opacity: 0, onComplete: function (i) {
						return function () {
							that.material[planList[i]].opacity = 1;
							that.obj[planList[i]].visible = false;
							that.showState = false;
							that.options.camera.remove(that.obj[planList[i]]);
						};
					}(i) });
			}
		}

		// ----------------- 滑动事件处理 -----------------

	}, {
		key: '_findDelta',
		value: function _findDelta(e) {
			var touchInfo = this._touchInfo;
			var touches = e.touches[0] || e.changedTouches[0];
			if (touches) return { x: touches.pageX - touchInfo.x, y: touches.pageY - touchInfo.y };
			return null;
		}
	}, {
		key: 'doTouchStartEvent',
		value: function doTouchStartEvent(e) {
			if (!this.showState) return;
			var pageX = e.changedTouches[0].pageX;
			var pageY = e.changedTouches[0].pageY;
			this.startX = pageX;
			this.startY = pageY;
			if (this.canvasType == CANVASTYPE['friendRank'] || this.canvasType == CANVASTYPE['groupRank'] || this.canvasType == CANVASTYPE['pk']) {
				var touchInfo = this._touchInfo;
				var listener = this.scrollHandler;
				if (!listener) return;

				touchInfo.trackingID = 'touch';
				touchInfo.x = e.touches[0].pageX;
				touchInfo.y = e.touches[0].pageY;

				touchInfo.maxDx = 0;
				touchInfo.maxDy = 0;
				touchInfo.historyX = [0];
				touchInfo.historyY = [0];
				touchInfo.historyTime = [+new Date()];
				touchInfo.listener = listener;

				if (listener.onTouchStart) {
					listener.onTouchStart();
				}
			} else if (this.canvasType == CANVASTYPE['gameOver']) {
				pageX = this._cxp(pageX);
				pageY = this._cyp(pageY);
				if ((!this.noplay_time || this.noplay_time < 0) && pageX > 117 && pageX < 297 && pageY > 540 && pageY < 660) {
					// console.log('click replay');
					this._drawGameOverBtnClick();
				}
			} else if (this.canvasType == CANVASTYPE['start']) {
				pageX = this._cxp(pageX);
				pageY = this._cyp(pageY);
				if (pageX > 100 && pageX < 320 && pageY > 515 && pageY < 645) {
					this._drawStartClick();
				}
			}
		}
	}, {
		key: 'doTouchMoveEvent',
		value: function doTouchMoveEvent(e) {
			if (!this.showState) return;
			if (this.canvasType == CANVASTYPE['friendRank'] || this.canvasType == CANVASTYPE['groupRank'] || this.canvasType == CANVASTYPE['pk']) {
				var touchInfo = this._touchInfo;
				if (touchInfo.trackingID == -1) return;
				e.preventDefault();
				var delta = this._findDelta(e);
				if (!delta) return;
				touchInfo.maxDy = Math.max(touchInfo.maxDy, Math.abs(delta.y));
				touchInfo.maxDx = Math.max(touchInfo.maxDx, Math.abs(delta.x));

				// This is all for our crummy velocity computation method. We really
				// should do least squares or anything at all better than just taking
				// the difference between two random samples.
				var timeStamp = +new Date();
				touchInfo.historyX.push(delta.x);
				touchInfo.historyY.push(delta.y);
				touchInfo.historyTime.push(timeStamp);
				while (touchInfo.historyTime.length > 10) {
					touchInfo.historyTime.shift();
					touchInfo.historyX.shift();
					touchInfo.historyY.shift();
				}
				if (touchInfo.listener && touchInfo.listener.onTouchMove) touchInfo.listener.onTouchMove(delta.x, delta.y, timeStamp);
			}
		}
	}, {
		key: 'doTouchEndEvent',
		value: function doTouchEndEvent(e) {
			if (!this.showState) return;
			// 触摸返回按钮
			var pageX = e.changedTouches[0].pageX;
			var pageY = e.changedTouches[0].pageY;
			var isClick = true;
			if ((this.canvasType == CANVASTYPE['friendRank'] || this.canvasType == CANVASTYPE['groupRank'] || this.canvasType == CANVASTYPE['pk'] || this.canvasType == CANVASTYPE['gameOver']) && (Math.abs(pageX - this.startX) > 5 || Math.abs(pageY - this.startY) > 5)) {
				// 不认为是一次 click
				isClick = false;
			}
			pageX = this._cxp(pageX);
			pageY = this._cyp(pageY);

			if (isClick) {
				if (this.canvasType == CANVASTYPE['groupRank']) {
					if (pageX > 134 && pageX < 283 && pageY > 640 && pageY < 727) {
						this.hide2D();
						!!this.options.groupPlayGame && this.options.groupPlayGame();
						return;
					}
				}
				if (this.canvasType == CANVASTYPE['friendRank']) {
					if (pageX > 120 && pageX < 300 && pageY > 640 && pageY < 720) {
						// console.log('查看群排行');
						!!this.options.onGroupShare && this.options.onGroupShare();
						return;
					} else if (pageX > 330 && pageX < 408 && pageY > 100 && pageY < 200) {
						if (!!this.opt) {
							this.hide2D();
							this.showState = true;
							this.canvasType = CANVASTYPE['gameOver'];
							this._drawGameOver();
						} else {
							!!this.options.friendRankReturn && this.options.friendRankReturn('');
						}
						return;
					}
				}
				if (this.canvasType == CANVASTYPE['gameOver']) {
					if (this.opt.type != 'beginner' && this.opt.type != 'tired' && pageX > 25 && pageX < 385 && pageY > 290 && pageY < 500) {
						// console.log('click rank');
						!!this.options.onClickRank && this.options.onClickRank();
					} else if (pageX > 150 && pageX < 260 && pageY > 199 && pageY < 260) {
						// console.log('click share');
						!!this.options.onClickShare && this.options.onClickShare();
					} else if ((!this.noplay_time || this.noplay_time < 0) && pageX > 117 && pageX < 297 && pageY > 540 && pageY < 660) {
						// console.log('click replay');
						!!this.options.onClickReplay && this.options.onClickReplay();
					} else if (!this.noplay_time || this.noplay_time < 0) {
						this._drawGameOverBtnClickRevert();
					}
					return;
				}
				if (this.canvasType == CANVASTYPE['gameOverHighest']) {
					if (pageX > 340 && pageX < 407 && pageY > 76 && pageY < 138) {
						// console.log('click return');
						this.canvasType = CANVASTYPE['gameOver'];
						this._drawGameOver();
					} else if (pageX > 111 && pageX < 380 && pageY > 540 && pageY < 660) {
						// console.log('click replay');
						!!this.options.onClickReplay && this.options.onClickReplay();
					} else if (this.changlleList.length > 0 && pageX > 170 && pageX < 230 && pageY > 330 && pageY < 390) {
						// 有超越好友的分享
						// console.log('click pure share');
						var typ = this.opt.type;
						if (this.opt.msg == '本周最高分') typ = 'week';
						!!this.options.onClickPureShare && this.options.onClickPureShare(typ);
					} else if (this.changlleList.length == 0 && pageX > 170 && pageX < 230 && pageY > 410 && pageY < 470) {
						// 没有超越好友的分享 
						var typ = this.opt.type;
						if (this.opt.msg == '本周最高分') typ = 'week';
						!!this.options.onClickPureShare && this.options.onClickPureShare(typ);
					} else if (this.changlleList.length > 7 && pageX > 55 && pageX < 115 && pageY > 437 && pageY < 497) {
						// 左翻页
						this._reDrawChangeAva(-1);
					} else if (this.changlleList.length > 7 && pageX > 297 && pageX < 357 && pageY > 437 && pageY < 497) {
						// 右翻页
						this._reDrawChangeAva(1);
					}
				}
				if (this.canvasType == CANVASTYPE['start']) {
					if (pageX > 100 && pageX < 320 && pageY > 515 && pageY < 645) {
						// console.log('-click 开始游戏')
						!!this.options.onClickStart && this.options.onClickStart();
					} else if (pageX > 110 && pageX < 290 && pageY > 645 && pageY < 705) {
						// console.log('-click 排行榜')
						!!this.options.onShowFriendRank && this.options.onShowFriendRank();
					} else {
						this._drawStartClickRevert();
					}
					return;
				}
				if (this.canvasType == CANVASTYPE['pk']) {
					if (pageX > 110 && pageX < 310 && pageY > 650 && pageY < 730) {
						// console.log('不挑战 直接开始');
						!!this.options.onBattlePlay && this.options.onBattlePlay(''); // 自己玩一局
						return;
					}
					if (this.data.organizerInfo.left_time > 0 && this.data.organizerInfo.is_self == 0 && pageX > 140 && pageX < 280 && pageY > 325 && pageY < 405) {
						// console.log('挑战按钮');
						!!this.options.onBattlePlay && this.options.onBattlePlay('pk'); // 再次挑战
						return;
					}
				}

				if (this.canvasType == CANVASTYPE['lookers']) {
					if (pageX > 130 && pageX < 280 && pageY > 650 && pageY < 720) {
						!!this.options.onLookersStart && this.options.onLookersStart();
					}
					return;
				}
			}
			var touchInfo = this._touchInfo;
			if (touchInfo.trackingID == -1) return;
			e.preventDefault();
			var delta = this._findDelta(e);
			if (!delta) return;
			var listener = touchInfo.listener;
			touchInfo.trackingID = -1;
			touchInfo.listener = null;

			// Compute velocity in the most atrocious way. Walk backwards until we find a sample that's 30ms away from
			// our initial sample. If the samples are too distant (nothing between 30 and 50ms away then blow it off
			// and declare zero velocity. Same if there are no samples.
			var sampleCount = touchInfo.historyTime.length;
			var velocity = { x: 0, y: 0 };
			if (sampleCount > 2) {
				var idx = touchInfo.historyTime.length - 1;
				var lastTime = touchInfo.historyTime[idx];
				var lastX = touchInfo.historyX[idx];
				var lastY = touchInfo.historyY[idx];
				var found = false;
				while (idx > 0) {
					idx--;
					var t = touchInfo.historyTime[idx];
					var dt = lastTime - t;
					if (dt > 30 && dt < 50) {
						// Ok, go with this one.
						velocity.x = (lastX - touchInfo.historyX[idx]) / (dt / 1000);
						velocity.y = (lastY - touchInfo.historyY[idx]) / (dt / 1000);
						break;
					}
				}
			}
			touchInfo.historyTime = [];
			touchInfo.historyX = [];
			touchInfo.historyY = [];

			if (listener && listener.onTouchEnd) listener.onTouchEnd(delta.x, delta.y, velocity);
		}
	}, {
		key: 'updatePosition',
		value: function updatePosition(scrollY) {
			var viewS; // 好友/ 群排行
			if (scrollY > 0) {
				// 表头下拉效果
				scrollY = 0;
			}
			var listlength = 10 * this._cwh(ListLineHeight) / HEIGHT * frustumSizeHeight; // list length 在 fust 下的尺寸
			var listlength1 = 10 * this._cwh(ListLineHeight);

			if (this.canvasType == CANVASTYPE['friendRank'] || this.canvasType == CANVASTYPE['groupRank']) {
				// 736/2 - 448/2  
				viewS = -(this._cy(143) + listlength1 / 2 - HEIGHT / 2) / HEIGHT * frustumSizeHeight; //这个坐标计算好像有点问题，设计稿是143
			}
			if (this.canvasType == CANVASTYPE['pk']) {
				viewS = -(this._cy(437) + listlength1 / 2 - HEIGHT / 2) / HEIGHT * frustumSizeHeight;
			}

			// 滑到第几屏的list

			var n = Math.floor((viewS - frustumSizeHeight * scrollY / H) / listlength);
			if (this.lastN != n && this.lastN - n < 0) {
				// 下移
				if (n % 2 == 0) {
					this._drawList((n + 1) * 10, 'list2');
				} else {
					this._drawList((n + 1) * 10, 'list1');
				}
			} else if (this.lastN != n && this.lastN - n > 0) {
				// 上移
				var x = n;
				if (x == -1) x = 1;
				if (n % 2 == 0) {
					this._drawList(n * 10, 'list1');
				} else {
					this._drawList(x * 10, 'list2');
				}
			}

			if (n % 2 == 0) {
				this.obj['list1'].position.y = viewS - frustumSizeHeight * scrollY / H - n * listlength;
				this.obj['list2'].position.y = viewS - frustumSizeHeight * scrollY / H - (n + 1) * listlength;
			} else {
				this.obj['list2'].position.y = viewS - frustumSizeHeight * scrollY / H - n * listlength;
				this.obj['list1'].position.y = viewS - frustumSizeHeight * scrollY / H - (n + 1) * listlength;
			}
			this.lastN = n;
			this.lastScrollY = scrollY;
		}
		// ----------------- 列表绘制 -----------------

	}, {
		key: '_drawList',
		value: function _drawList(offset, type) {
			var _this = this;

			if (type == 'list1') {
				// 两个list互不干扰，只在一个list显示时候++
				this.imgid['list1']++;
			} else if (type == 'list2') {
				this.imgid['list2']++;
			}

			var limit = 10;
			var list = this.sotedRankList.slice(offset, offset + limit);
			// 绘制列表 从 m 开始到 n 结束的列表
			var ctx = this.context[type];
			ctx.clearRect(0, 0, WIDTH, 10 * this._cwh(ListLineHeight));

			ctx.fillStyle = 'rgba(0,0,0,0.9)';
			if (this.canvasType == CANVASTYPE['pk']) {
				ctx.fillStyle = 'white';
			}
			ctx.textBaseline = "middle";
			ctx.fillRect(0, 0, WIDTH, 10 * this._cwh(ListLineHeight)); //list 底色为白色

			if (offset != 0 && list.length == 0) {
				// 最后面列表结束显示白色屏幕就可以，不显示
				this._updatePlane(type);
				return;
			}
			if (offset < 0) {
				// 这种情况下不要更新列表
				return;
			}

			var len = list.length;

			var _loop = function _loop() {
				if (_this.canvasType != CANVASTYPE['pk']) {
					if (i % 2 == 1) {
						ctx.fillStyle = 'rgba(255,255,255, 0.03)';
						ctx.fillRect(0, i * _this._cwh(ListLineHeight), _this._cwh(414), _this._cwh(ListLineHeight));
					}
				}

				// 写一个大的数字
				var y = (i + 0.5) * _this._cwh(ListLineHeight); // 每一行中间的y值
				ctx.textAlign = "center";
				n = i + 1 + offset;

				if (n == 1) {
					ctx.fillStyle = 'rgb(250,126,0)';
				} else if (n == 2) {
					ctx.fillStyle = 'rgb(254,193,30)';
				} else if (n == 3) {
					ctx.fillStyle = 'rgb(251,212,19)';
				} else {
					ctx.fillStyle = '#aaa';
				}
				ctx.font = "italic bold " + _this._cf(17);
				ctx.fillText(n, _this._cx(58.5), y);

				// 绘制头像
				var that = _this;

				var g = list[i].grade || 0;
				_this._drawImageRound(list[i].headimg, _this._cx(107), y, _this._cwh(34), _this._cwh(34), type, function () {
					if (that.canvasType == CANVASTYPE['pk']) {
						that._drawImageCenter('res/ava_lookers.png', that._cx(107), y, that._cwh(37), that._cwh(37), type, null, that.imgid[type]);
					} else that._drawImageCenter('res/ava_rank.png', that._cx(107), y, that._cwh(47), that._cwh(47), type, null, that.imgid[type]);
				}, _this.imgid[type], true);

				if (_this.canvasType == CANVASTYPE['pk']) {
					// 写名字
					ctx.textAlign = "left";
					ctx.fillStyle = '#000';
					ctx.font = 'bold ' + _this._cf(17);
					ctx.fillText(_this._cname(list[i].nickname, 16), _this._cx(144), y - _this._cwh(10));

					if (list[i].score_info[0].score > _this.data.organizerInfo.score_info[0].score) {
						ctx.font = _this._cf(12);
						ctx.fillStyle = '#FC4814';
						ctx.fillText('挑战成功', _this._cx(144), y + _this._cwh(12));
						ctx.fillStyle = '#000';
					} else {
						ctx.font = _this._cf(12);
						ctx.fillStyle = '#888';
						ctx.fillText('挑战失败', _this._cx(144), y + _this._cwh(12));
					}

					ctx.textAlign = "right";
					ctx.font = _this._cf(22, true);
					ctx.fillText(list[i].score_info[0].score || 0, _this._cx(364), y);
				} else {
					// 写名字
					ctx.textAlign = "left";
					ctx.fillStyle = '#fff';
					ctx.font = _this._cf(17);
					list[i].nickname = list[i].nickname || '';
					ctx.fillText(_this._cname(list[i].nickname, 16), _this._cx(144), y);

					// 写分数
					ctx.textAlign = "right";
					ctx.font = _this._cf(22, true);
					ctx.fillText(list[i].week_best_score || 0, _this._cx(364), y);
				}
			};

			for (var i = 0; i < len; i++) {
				var n;

				_loop();
			}

			if (len == 0) {
				// 没有任何数据
				ctx.textAlign = "center";
				ctx.fillStyle = '#ccc';
				ctx.font = this._cf(14);
				if (this.canvasType == CANVASTYPE['pk']) {
					ctx.fillText('暂无人应战', this._cx(207), this._cwh(100));
				} else {
					ctx.fillText('暂无排行数据', this._cx(207), this._cy(429));
				}
			}
			this._updatePlane(type);
		}
	}, {
		key: 'renderRankList',
		value: function renderRankList(res) {
			var rank_list = [];
			this.myUserInfo = this.myUserInfo || { headimg: '', nickname: '', week_best_score: 0, score_info: [{ score: 0 }] };

			if (this.canvasType == CANVASTYPE['friendRank'] || this.canvasType == CANVASTYPE['groupRank']) {
				res = res || [];
				res.push(this.myUserInfo); // 把自己的最高分放进去
				rank_list = this._rerank(res);
				this.sotedRankList = rank_list; // 存下来，滑动的时候用到
			} else {
				this.sotedRankList = res; // 存下来，滑动的时候用到
			}
			var innerHeight = this.sotedRankList.length * this._cwh(ListLineHeight) / Dpr;
			var outterOffsetHeight;

			if (this.canvasType == CANVASTYPE['friendRank'] || this.canvasType == CANVASTYPE['groupRank']) {
				this.myidx = rank_list.findIndex(this._findSelfIndex.bind(this)) + 1; // 找到自己的index
				outterOffsetHeight = this._cwh(445) / Dpr;
			}
			if (this.canvasType == CANVASTYPE['pk']) {
				outterOffsetHeight = this._cwh(194) / Dpr;
			}
			// scroll handler
			this.scrollHandler = new _scrollHandler2.default({
				innerOffsetHeight: innerHeight, // 个数 * 每一行的高度百分比 * 总高度
				outterOffsetHeight: outterOffsetHeight,
				updatePosition: this.updatePosition.bind(this)
			});
			this._drawList(0, 'list1'); // 绘制滚动列表
			this._drawList(10, 'list2'); // 绘制滚动列表
		}
		// ----------------- 点击态 -----------------

	}, {
		key: '_drawGameOverBtnClick',
		value: function _drawGameOverBtnClick() {
			// 再玩一局的点击态
			var ctx = this.context['btn'];
			ctx.clearRect(this._cx(91), this._cy(567), this._cwh(232), this._cwh(94));
			this._drawImageCenter('res/replay.png', this._cx(207), this._cy(607), this._cwh(190), this._cwh(75), 'btn', null, this.imgid['btn']);
		}
	}, {
		key: '_drawGameOverBtnClickRevert',
		value: function _drawGameOverBtnClickRevert() {
			// 再玩一局的点击态
			var ctx = this.context['btn'];
			ctx.clearRect(this._cx(91), this._cy(567), this._cwh(232), this._cwh(94));
			this._drawImageCenter('res/replay.png', this._cx(207), this._cy(607), this._cwh(212), this._cwh(84), 'btn', null, this.imgid['btn']);
		}
	}, {
		key: '_drawStartClick',
		value: function _drawStartClick() {
			// 再玩一局的点击态
			var ctx = this.context['btn'];
			ctx.clearRect(this._cx(91), this._cy(547), this._cwh(232), this._cwh(94));
			this._drawImageCenter('res/play.png', this._cx(207), this._cy(587), this._cwh(190), this._cwh(75), 'btn', null, this.imgid['btn']);
		}
	}, {
		key: '_drawStartClickRevert',
		value: function _drawStartClickRevert() {
			// 再玩一局的点击态
			var ctx = this.context['btn'];
			ctx.clearRect(this._cx(91), this._cy(547), this._cwh(232), this._cwh(94));
			this._drawImageCenter('res/play.png', this._cx(207), this._cy(587), this._cwh(212), this._cwh(84), 'btn', null, this.imgid['btn']);
		}

		// ----------------- 背景绘制 -----------------

	}, {
		key: '_drawPKListBg',
		value: function _drawPKListBg() {
			// 绘制背景图
			var ctx = this.context['bg'];
			ctx.clearRect(0, 0, WIDTH, HEIGHT);
			ctx.fillStyle = 'rgba(0,0,0, 0.8)';
			ctx.fillRect(0, 0, (WIDTH - this._cwh(354)) / 2, HEIGHT); // 左
			ctx.fillRect(this._cx(384), 0, (WIDTH - this._cwh(354)) / 2, HEIGHT); // 右

			ctx.fillRect(this._cx(30), 0, this._cwh(354), this._cy(110)); // 上
			ctx.fillRect(this._cx(30), this._cy(632), this._cwh(354), this._cy(144)); // 下

			// 显示擂主分数
			// 列表背景
			ctx.fillStyle = 'rgb(250,250,250)';
			ctx.fillRect(this._cx(31), this._cy(103), this._cwh(354), this._cwh(335));

			ctx.lineWidth = 2 * Dpr;
			ctx.strokeStyle = '#fff';
			this._roundedRectR(this._cx(30), this._cy(102), this._cwh(354), this._cwh(530), 1 * Dpr, 'bg');

			ctx.textBaseline = "middle";
			// 绘制头像
			var that = this;

			if (this.data.gg_score == undefined) {
				// 显示擂主信息
				this._drawImageCenter(this.data.organizerInfo.headimg, this._cx(207), this._cy(158), this._cwh(50), this._cwh(50), 'bg', null, this.imgid['bg']);
				// 写名字
				ctx.textAlign = "center";
				ctx.fillStyle = 'rgba(0,0,0,0.8)';
				ctx.font = this._cf(14);
				ctx.fillText(this.data.organizerInfo.nickname, this._cx(207), this._cy(195));
				ctx.fillText('擂主得分', this._cx(207), this._cy(242));
				// 一条线
				ctx.lineWidth = 0.5 * Dpr;
				ctx.strokeStyle = 'rgba(0,0,0,0.06)';
				ctx.beginPath();
				ctx.moveTo(this._cx(160), this._cy(217));
				ctx.lineTo(this._cx(254), this._cy(217));
				ctx.closePath();
				ctx.stroke();

				// 小方块
				ctx.fillStyle = 'rgba(0,0,0,0.2)';
				ctx.fillRect(this._cx(162), this._cy(239), this._cwh(9), this._cwh(3));
				ctx.fillRect(this._cx(162), this._cy(244), this._cwh(9), this._cwh(3));
				ctx.fillRect(this._cx(241), this._cy(239), this._cwh(9), this._cwh(3));
				ctx.fillRect(this._cx(241), this._cy(244), this._cwh(9), this._cwh(3));

				// 写分数
				ctx.fillStyle = '#000';
				ctx.font = this._cf(66, true);
				ctx.fillText(this.data.organizerInfo.score_info[0].score, this._cx(207), this._cy(298));
			} else {
				// 显示挑战结果
				var suc_src = void 0,
				    suc_word = void 0,
				    c1 = void 0,
				    c2 = void 0;
				if (this.data.gg_score > this.data.organizerInfo.score_info[0].score) {
					// 挑战成功
					suc_src = 'res/suc.png';
					suc_word = '挑战成功';
					c1 = 'rgba(0,0,0,1)';
					c2 = 'rgba(0,0,0,0.3)';
					// 烟花
					this._drawImageCenter('res/flower_small.png', this._cx(207), this._cy(175), this._cwh(140), this._cwh(53), 'bg', null, this.imgid['bg']);
				} else {
					// 挑战失败
					suc_src = 'res/fail.png';
					suc_word = '挑战失败';
					c1 = 'rgba(0,0,0,0.3)';
					c2 = 'rgba(0,0,0,1)';
				}

				// 顶部icon
				this._drawImageCenter(suc_src, this._cx(207), this._cy(135), this._cwh(20), this._cwh(15), 'bg', null, this.imgid['bg']);
				ctx.textAlign = 'center';
				ctx.fillStyle = '#000';
				ctx.font = 'bold ' + this._cf(30);
				ctx.fillText(suc_word, this._cx(207), this._cy(178));

				// 头像
				this._drawImageCenter(this.myUserInfo.headimg, this._cx(158), this._cy(289), this._cwh(26), this._cwh(26), 'bg', null, this.imgid['bg']);
				this._drawImageCenter(this.data.organizerInfo.headimg, this._cx(260), this._cy(289), this._cwh(26), this._cwh(26), 'bg', null, this.imgid['bg']);
				// 名字
				ctx.textAlign = 'center';
				ctx.fillStyle = 'rgba(0,0,0,0.8)';
				ctx.font = this._cf(11);
				ctx.fillText(this._cname(this.myUserInfo.nickname, 16), this._cx(158), this._cy(318));
				ctx.fillText(this._cname(this.data.organizerInfo.nickname, 16), this._cx(260), this._cy(318));

				// 分数
				ctx.fillStyle = c1;
				ctx.font = this._cf(44, true);
				if (this.data.gg_score > 999) {
					ctx.textAlign = 'right';
					ctx.fillText(this.data.gg_score, this._cx(190), this._cy(253));
				} else {
					ctx.textAlign = 'center';
					ctx.fillText(this.data.gg_score, this._cx(158), this._cy(253));
				}

				ctx.textAlign = 'center';
				ctx.fillStyle = 'rgba(0,0,0,0.3)';

				ctx.fillRect(this._cx(202), this._cy(242), this._cwh(10), this._cwh(4));

				ctx.fillStyle = c2;
				ctx.font = this._cf(44, true);
				if (this.data.organizerInfo.score_info[0].score > 999) {
					ctx.textAlign = 'left';
					ctx.fillText(this.data.organizerInfo.score_info[0].score, this._cx(231), this._cy(253));
				} else {
					ctx.textAlign = 'center';
					ctx.fillText(this.data.organizerInfo.score_info[0].score, this._cx(260), this._cy(253));
				}
			}

			// 列表有一条分界线
			ctx.strokeStyle = 'rgba(0,0,0,0.06)';
			ctx.lineWidth = 1;
			ctx.beginPath();
			ctx.moveTo(this._cx(30), this._cy(437));
			ctx.lineTo(this._cx(384), this._cy(437));
			ctx.stroke();
			ctx.closePath();

			// 挑战btn
			var msg = '挑战';
			var that = this;
			if (this.data.organizerInfo.left_time > 0 && this.data.organizerInfo.is_self == 0) {
				// 剩余时间 > 0 并且不是擂主，就可以挑战
				if (this.myidx > 0) {
					// 有名次的一定是 [1, ~)
					msg = '再次挑战';
				}
				this._drawImageCenter('res/btn_bg_g.png', this._cx(207), this._cy(368), this._cwh(130), this._cwh(63), 'bg', function () {
					ctx.textAlign = "center";
					ctx.fillStyle = '#fff';
					ctx.font = that._cf(14);
					ctx.fillText(msg, that._cx(207), that._cy(368));
					that._updatePlane('bg');
				}, this.imgid['bg']);
				// 显示有效时间
				ctx.font = this._cf(12);;
				ctx.textAlign = "right";
				ctx.fillStyle = '#000';
				ctx.fillText('有效时间至', this._cx(223), this._cy(403.5));
				ctx.textAlign = "left";
				ctx.fillStyle = '#fc4814';
				var nt = +new Date();
				var lt = nt + this.data.organizerInfo.left_time * 1000;
				nt = new Date(lt);
				var ho = nt.getHours();
				ho = ho < 10 ? '0' + ho : ho;
				var m = nt.getMinutes();
				m = m < 10 ? '0' + m : m;
				ctx.fillText(ho + ':' + m, this._cx(225), this._cy(403.5));
			} else if (this.data.organizerInfo.left_time == 0 && this.data.organizerInfo.is_self == 0) {
				// 没有剩余时间并且不是擂主， 显示失效
				var that = this;
				this._drawImageCenter('res/btn_bg_h.png', this._cx(207), this._cy(368), this._cwh(130), this._cwh(63), 'bg', function () {
					ctx.font = that._cf(14);
					ctx.textAlign = "center";
					ctx.fillStyle = 'rgba(0,0,0,0.3)';
					ctx.fillText('挑战结束', that._cx(207), that._cy(368));
					that._updatePlane('bg');
				}, this.imgid['bg']);
				ctx.font = this._cf(14);
				ctx.textAlign = "center";
				ctx.fillStyle = '#888';
				ctx.fillText('已失效', this._cx(207), this._cy(403.5));
			} else if (this.data.organizerInfo.left_time > 0 && this.data.organizerInfo.is_self == 1) {
				// 有剩余时间，是擂主，擂主看到失效时间
				ctx.font = this._cf(14);
				ctx.textAlign = "right";
				ctx.fillStyle = '#888';
				ctx.fillText('有效时间至', this._cx(223), this._cy(369));
				ctx.textAlign = "left";
				ctx.fillStyle = '#2c9f67';
				var nt = +new Date();
				var lt = nt + this.data.organizerInfo.left_time * 1000;
				nt = new Date(lt);
				var ho = nt.getHours();
				ho = ho < 10 ? '0' + ho : ho;
				var m = nt.getMinutes();
				m = m < 10 ? '0' + m : m;
				ctx.fillText(ho + ':' + m, this._cx(225), this._cy(369));
			}

			ctx.textAlign = "center";
			ctx.fillStyle = '#fff';
			ctx.font = this._cf(17);
			ctx.fillText('不挑战，直接开始', this._cx(199), this._cy(688));
			this._drawImageCenter('res/r_arr.png', this._cx(280), this._cy(688), this._cwh(6.5), this._cwh(12.5), 'bg', null, this.imgid['bg']);

			this._updatePlane('bg');
		}
	}, {
		key: '_drawRankListBg',
		value: function _drawRankListBg() {
			// 绘制背景图
			this.imgid['bg']++; // 从另一个bg场景，到这一个bg场景，为了不渲染上一个bg场景的图片，这里应该++
			var ctx = this.context['bg'];
			ctx.clearRect(0, 0, WIDTH, HEIGHT);
			ctx.fillStyle = 'rgba(0,0,0, 0.8)';
			ctx.fillRect(0, 0, (WIDTH - this._cwh(354)) / 2, HEIGHT); // 左
			ctx.fillRect(this._cx(384), 0, (WIDTH - this._cwh(354)) / 2, HEIGHT); // 右

			ctx.fillRect(this._cx(30), 0, this._cwh(354), this._cy(110)); // 上
			ctx.fillRect(this._cx(30), this._cy(592), this._cwh(354), this._cy(144)); // 下

			ctx.textBaseline = "middle";
			ctx.textAlign = "center";

			// 列表里面的半透明的蒙层
			/*var grd=ctx.createLinearGradient(this._cx(30), this._cy(185), this._cx(30), this._cy(191)); // xyxy
   grd.addColorStop(0, "rgba(0,0,0, 0.04)");
   grd.addColorStop(1,"rgba(255,255,255, 0.1)");
   ctx.fillStyle=grd;
   ctx.fillRect(this._cx(30), this._cy(185), this._cx(354), this._cx(6)); // xy wh*/

			ctx.fillStyle = 'rgba(0,0,0,0.9)';
			ctx.fillRect(this._cx(30), this._cy(110), this._cwh(354), this._cwh(33));

			// 列表有一条分界线
			ctx.strokeStyle = 'rgba(255,255,255,0.2)';
			ctx.lineWidth = 1 * Dpr;
			ctx.beginPath();
			ctx.moveTo(this._cx(30), this._cy(143));
			ctx.lineTo(this._cx(384), this._cy(143));
			ctx.stroke();
			ctx.closePath();

			ctx.fillStyle = '#fff';
			ctx.font = 'bold ' + this._cf(12);
			ctx.textAlign = "left";
			ctx.fillText('每周一凌晨刷新', this._cx(54), this._cy(126.5));

			ctx.lineWidth = 1 * Dpr;
			ctx.strokeStyle = 'rgba(255,255,255,0.2)';
			this._roundedRectR(this._cx(30), this._cy(110), this._cwh(354), this._cwh(482), 1 * Dpr, 'bg');

			this._updatePlane('bg');

			if (this.canvasType == CANVASTYPE['groupRank']) {
				var that = this;
				ctx.font = that._cf(17);
				ctx.fillStyle = '#fff';
				ctx.textAlign = "center";
				ctx.textBaseline = "middle";
				ctx.fillText('玩一局', that._cx(207), that._cy(680));
				this._drawImageCenter('res/r_arr.png', this._cx(244), this._cy(680), this._cwh(6.6), this._cwh(10), 'bg', null, this.imgid['bg']);
			}
			if (this.canvasType == CANVASTYPE['friendRank']) {
				ctx.fillStyle = '#fff';
				ctx.font = this._cf(17);
				ctx.textAlign = "left";
				ctx.fillText('查看群排行', this._cx(177), this._cy(674));
				this._drawImageCenter('res/r_arr.png', this._cx(270), this._cy(674), this._cwh(6.6), this._cwh(10), 'bg', null, this.imgid['bg']);
				this._drawImageCenter('res/rank.png', this._cx(154), this._cy(674), this._cwh(22), this._cwh(22), 'bg', null, this.imgid['bg']);
				this._drawImageCenter('res/close.png', this._cx(375), this._cy(114), this._cwh(48), this._cwh(48), 'bg', null, this.imgid['bg']);
			}
		}
	}, {
		key: '_drawGameOver',
		value: function _drawGameOver() {
			var _this2 = this;

			this.imgid['bg'];
			var opt = this.opt;
			opt.score = opt.score || 0;
			opt.highest_score = opt.highest_score || 0;
			var that = this;
			// 绘制背景图
			var ctx = this.context['bg'];
			ctx.clearRect(0, 0, WIDTH, HEIGHT);
			ctx.fillStyle = 'rgba(0,0,0, 0.8)';
			ctx.fillRect(0, 0, WIDTH, HEIGHT);

			ctx.textBaseline = "middle";

			// 分数
			ctx.textAlign = "center";
			ctx.fillStyle = '#fff';
			ctx.font = this._cf(14);
			ctx.fillText('本次得分', this._cx(207), this._cy(84));

			ctx.fillStyle = '#fff';
			ctx.font = this._cf(88, true);
			ctx.fillText(opt.score, this._cx(207 + 5), this._cy(150));

			// 本次得分的小方块
			ctx.fillStyle = 'rgba(255,255,255,0.2)';
			ctx.fillRect(this._cx(162), this._cy(78), this._cwh(9), this._cwh(3));
			ctx.fillRect(this._cx(162), this._cy(84), this._cwh(9), this._cwh(3));
			ctx.fillRect(this._cx(241), this._cy(78), this._cwh(9), this._cwh(3));
			ctx.fillRect(this._cx(241), this._cy(84), this._cwh(9), this._cwh(3));

			// 发起挑战
			this._drawImageCenter('res/btn.png', this._cx(207), this._cy(214), this._cwh(86), this._cwh(32), 'bg', null, this.imgid['bg']);
			ctx.font = this._cf(13);
			ctx.fillStyle = '#fff';
			ctx.fillText('发起挑战', this._cx(207), this._cy(214));

			var showTired = false; // 是否显示温馨提示
			if ((opt.game_cnt > 5 || opt.score > 5) && // 不是新手引导
			opt.score < opt.highest_score && // 不是历史最高分
			this.myidx != 1 && // 不是排行榜第一
			!this._has_show_tired && // 从未显示过
			+new Date() / 1000 - opt.start_time > 1800 // 玩的时间超过半小时
			) {
					showTired = true;
					this._has_show_tired = true;
				}

			if (showTired) {
				// this._has_show_tired = true;
				// 游戏时间超过30min
				ctx.lineWidth = 4 * Dpr;
				ctx.strokeStyle = '#fff';
				ctx.fillStyle = '#fff';
				this._roundedRectR(this._cx(31), this._cy(298), this._cwh(354), this._cwh(210), 1 * Dpr, 'bg');
				ctx.fill();

				ctx.fillStyle = 'black';
				ctx.font = this._cf(17);
				ctx.textAlign = 'left';
				ctx.fillText('玩了这么久', this._cx(80), this._cy(370));
				ctx.fillText('休息一下吧', this._cx(80), this._cy(410));

				this._drawImageCenter('res/tired.png', this._cx(297), this._cy(397), this._cwh(179), this._cwh(185), 'bg', null, that.imgid['bg']);
				this.opt.type = 'tired';
			} else {
				ctx.lineWidth = 0.5 * Dpr;
				ctx.fillStyle = 'rgba(0,0,0,0.3)';
				ctx.strokeStyle = 'rgba(255,255,255,0.3)';
				this._roundedRectR(this._cx(30), this._cy(297), this._cwh(354), this._cwh(192), 4 * Dpr, 'bg');
				ctx.fill();
				// 排行榜背景
				ctx.fillStyle = 'rgba(255,255,255,0.06)';
				ctx.fillRect(this._cx(150), this._cy(336), this._cwh(115), this._cwh(153));

				/*// 左右投影
    var grd=ctx.createLinearGradient(this._cx(90), this._cy(336), this._cx(150), this._cy(336)); // xyxy
    grd.addColorStop(0, "rgba(0,0,0, 0.1)");
    grd.addColorStop(1, "rgba(0,0,0, 0.4)");
    ctx.fillStyle=grd;
    ctx.fillRect(this._cx(90), this._cy(336), this._cwh(60), this._cwh(153)); // xy wh
    	// 左右投影
    var grd=ctx.createLinearGradient(this._cx(264), this._cy(336), this._cx(324), this._cy(336)); // xyxy
    grd.addColorStop(0, "rgba(0,0,0, 0.4)");
    grd.addColorStop(1, "rgba(0,0,0, 0.1)");
    ctx.fillStyle=grd;
    ctx.fillRect(this._cx(264), this._cy(336), this._cwh(60), this._cwh(153)); // xy wh*/

				// 排行榜文字
				ctx.beginPath();
				ctx.lineWidth = 0.5 * Dpr;
				ctx.strokeStyle = 'rgba(255,255,255,0.4)';
				ctx.moveTo(this._cx(30), this._cy(336));
				ctx.lineTo(this._cx(384), this._cy(336));
				ctx.stroke();
				ctx.closePath();

				ctx.font = this._cf(12);
				ctx.textAlign = "left";
				ctx.fillStyle = 'rgba(255,255,255,0.6)';
				ctx.fillText('排行榜 · 每周一凌晨刷新', this._cx(46), this._cy(316));
				ctx.fillStyle = '#fff';
				ctx.fillText('查看全部排行', this._cx(291), this._cy(316));
				this._drawImageCenter('res/r_arr.png', this._cx(371), this._cy(315), this._cwh(6.6), this._cwh(10), 'bg', null, this.imgid['bg']);

				// 排行榜数据
				// 个人要居中
				var start = this.myidx - 2;
				var no_friend_idx = 0;
				if (this.sotedRankList.length == 1) {
					// 该用户没有好友，自己要显示在中间
					no_friend_idx = 1;
				}
				for (var i = 0; i < 3; i++) {
					ctx.font = "italic bold " + this._cf(16);
					ctx.textAlign = "center";

					if (this.myidx == 1 && i == 0) {
						start++;
					}
					if (this.myidx == this.sotedRankList.length && i == 2) {
						// 最后一名，第三个格子空出
						continue;
					}
					if (this.myidx == start + 1 + i) {
						// 自己的名次是绿色
						ctx.fillStyle = '#41bf8c';
					} else {
						ctx.fillStyle = '#888';
					}
					if (!!this.sotedRankList[start + i]) {
						var that;

						(function () {
							ctx.fillText(start + 1 + i, _this2._cx(90 + 118 * (i + no_friend_idx)), _this2._cy(356));
							ctx.font = _this2._cf(14);
							ctx.fillStyle = '#888';
							ctx.fillText(_this2._cname(_this2.sotedRankList[start + i].nickname, 14), _this2._cx(90 + 118 * (i + no_friend_idx)), _this2._cy(435));

							ctx.font = _this2._cf(22, true);
							ctx.fillStyle = '#fff';
							ctx.fillText(_this2.sotedRankList[start + i].week_best_score || 0, _this2._cx(90 + 118 * (i + no_friend_idx)), _this2._cy(463));
							that = _this2;

							var x0 = _this2._cx(90 + 118 * (i + no_friend_idx));
							_this2._drawImageRound(_this2.sotedRankList[start + i].headimg, x0, _this2._cy(393), _this2._cwh(42), _this2._cwh(42), 'bg', function () {
								that._drawImageCenter('res/ava_rank.png', x0, that._cy(393), that._cwh(58), that._cwh(58), 'bg', null, that.imgid['bg']);
							}, _this2.imgid['bg'], true);
						})();
					}
				}
			}

			// 在玩一局， 返回的时候不要重新渲染
			var ctx1 = this.context['btn'];
			ctx1.clearRect(0, 0, WIDTH, HEIGHT);
			if (showTired) {
				this._drawImageCenter('res/noplay.png', this._cx(207), this._cy(607), this._cwh(212), this._cwh(84), 'btn', function () {
					ctx1.fillStyle = '#00C777';
					ctx1.textBaseline = 'middle';
					ctx1.font = that._cf(22);
					that.noplay_time = 5;
					ctx1.fillText(that.noplay_time, that._cx(140), that._cy(607));
					that._updatePlane('btn');
					that.timer = setInterval(function () {
						that.noplay_time--;
						if (that.noplay_time <= 0) {
							clearInterval(that.timer);
							ctx1.clearRect(0, 0, WIDTH, HEIGHT);
							that._drawImageCenter('res/replay.png', that._cx(207), that._cy(607), that._cwh(212), that._cwh(84), 'btn', null, that.imgid['btn']);
						} else {
							ctx1.fillStyle = 'white';
							ctx1.fillRect(that._cx(125), that._cy(590), that._cwh(30), that._cwh(30));
							ctx1.fillStyle = '#00C777';
							ctx1.textBaseline = 'middle';
							ctx1.font = that._cf(22);
							ctx1.fillText(that.noplay_time, that._cx(140), that._cy(607));
							that._updatePlane('btn');
						}
					}, 1000);
				}, this.imgid['btn']);
			} else {
				var ctx1 = this.context['btn'];
				ctx1.clearRect(this._cx(91), this._cy(547), this._cwh(232), this._cwh(94));
				this._drawImageCenter('res/replay.png', this._cx(207), this._cy(607), this._cwh(212), this._cwh(84), 'btn', null, this.imgid['btn']);
			}

			// 历史最高分
			ctx.font = this._cf(14);
			ctx.textAlign = "center";
			ctx.fillStyle = '#fff';
			ctx.fillText('历史最高分：' + Math.max(opt.highest_score, opt.score), this._cx(207), this._cy(703));

			this._updatePlane('bg');
		}
	}, {
		key: '_drawStart',
		value: function _drawStart(opt) {
			opt = opt || {};
			// 绘制背景图
			var ctx = this.context['bg'];
			ctx.clearRect(0, 0, WIDTH, HEIGHT);
			ctx.fillStyle = 'rgba(0,0,0, 0.3)';
			ctx.fillRect(0, 0, WIDTH, HEIGHT);

			var that = this;
			this._drawImageCenter('res/title.png', this._cx(204), this._cy(168), this._cwh(207), this._cwh(52), 'bg', null, this.imgid['bg']);

			var ctx1 = this.context['btn'];
			ctx1.clearRect(0, 0, WIDTH, HEIGHT);
			this._drawImageCenter('res/play.png', that._cx(207), that._cy(587), that._cwh(208), that._cwh(78), 'btn', null, this.imgid['btn']);

			ctx.font = this._cf(17);
			ctx.textBaseline = 'middle';
			ctx.textAlign = 'center';
			ctx.fillStyle = '#fff';
			ctx.fillText('排行榜', this._cx(213.5), that._cy(684));

			// 246 684
			this._drawImageCenter('res/r_arr.png', this._cx(250), this._cy(684), this._cwh(6.6), this._cwh(10), 'bg', null, this.imgid['bg']);

			this._drawImageCenter('res/rank.png', this._cx(165), this._cy(684), this._cwh(22), this._cwh(22), 'bg', null, this.imgid['bg']);

			this._updatePlane('bg');
		}
	}, {
		key: '_drawLookers',
		value: function _drawLookers(opt) {
			// 绘制背景图
			var ctx = this.context['bg'];
			ctx.clearRect(0, 0, WIDTH, HEIGHT);

			// 绘制头像
			var that = this;

			var score = opt.score || 0;
			var name = opt.nickname || '';
			ctx.textAlign = "center";

			ctx.textBaseline = "middle";
			if (opt.type == 'in') {
				this._drawImageRound(opt.headimg, this._cx(207), this._cy(91), this._cx(50), this._cx(50), 'bg', function () {
					that._drawImageCenter('res/ava_lookers.png', that._cx(207), that._cy(91), that._cx(53), that._cx(53), 'bg', null, that.imgid['bg']);
				}, this.imgid['bg'], true);
				ctx.font = this._cf(17);
				ctx.fillStyle = 'black';
				ctx.fillText(name + ' 正在游戏中', this._cx(207), this._cy(144));
			} else if (opt.type == 'gg') {
				ctx.fillStyle = 'rgba(0,0,0, 0.4)';
				ctx.fillRect(0, 0, WIDTH, HEIGHT);

				this._drawImageRound(opt.headimg, this._cx(207), this._cy(91), this._cwh(50), this._cwh(50), 'bg', function () {
					that._drawImageCenter('res/ava_lookers.png', that._cx(207), that._cy(91), that._cwh(53), that._cwh(53), 'bg', null, that.imgid['bg']);
				}, this.imgid['bg'], true);
				ctx.fillStyle = '#fff';
				ctx.strokeStyle = 'white';
				ctx.font = this._cf(17);
				ctx.fillText(name + ' 游戏已结束', this._cx(207), this._cy(144));
				ctx.lineWidth = 0.5 * Dpr;
				ctx.strokeStyle = 'rgba(255,255,255,0.5)';
				ctx.beginPath();
				ctx.moveTo(this._cx(157), this._cy(176));
				ctx.lineTo(this._cx(257), this._cy(176));
				ctx.closePath();
				ctx.stroke();
				ctx.font = this._cf(14);
				ctx.fillText('游戏得分', this._cx(207), this._cy(207));
				// 小方块
				ctx.fillStyle = 'rgba(255,255,255,0.2)';
				ctx.fillRect(this._cx(156), this._cy(203), this._cwh(9), this._cwh(3));
				ctx.fillRect(this._cx(156), this._cy(209), this._cwh(9), this._cwh(3));
				ctx.fillRect(this._cx(243), this._cy(203), this._cwh(9), this._cwh(3));
				ctx.fillRect(this._cx(243), this._cy(209), this._cwh(9), this._cwh(3));
				ctx.fillStyle = '#fff';
				ctx.font = this._cf(80, true);
				ctx.fillText(score || 0, this._cx(212), this._cy(267));
			} else if (opt.type == 'out') {
				ctx.fillStyle = 'rgba(0,0,0, 0.4)';
				ctx.fillRect(0, 0, WIDTH, HEIGHT);

				this._drawImageRound(opt.headimg, this._cx(207), this._cy(221), this._cwh(50), this._cwh(50), 'bg', function () {
					that._drawImageCenter('res/ava_lookers.png', that._cx(207), that._cy(221), that._cwh(53), that._cwh(53), 'bg', null, that.imgid['bg']);
				}, this.imgid['bg'], true);

				ctx.fillStyle = '#fff';
				ctx.font = this._cf(17);
				ctx.fillText(name + ' 游戏已结束', this._cx(207), this._cy(278));
			}

			var that = this;
			this._drawImageCenter('res/btn_iplay.png', this._cx(207), this._cy(663), this._cwh(131), this._cwh(54), 'bg', null, this.imgid['bg']);

			this._updatePlane('bg');
		}
	}, {
		key: '_drawGameOverHighest',
		value: function _drawGameOverHighest(opt, type) {
			this.imgid['bg']++;
			opt.score = opt.score || 0;

			var ctx = this.context['bg'];
			ctx.clearRect(0, 0, WIDTH, HEIGHT);
			ctx.fillStyle = 'rgba(0,0,0, 0.8)';
			ctx.fillRect(0, 0, WIDTH, HEIGHT);

			// 避免一次触发了超越，一次没有触发超越，显示了上一次的头像
			var ctx1 = this.context['btn'];
			ctx1.clearRect(this._cx(30), this._cy(448), this._cwh(354), this._cwh(55));

			// 历史最高分
			ctx.font = this._cf(14);
			ctx.textAlign = "center";
			ctx.fillStyle = '#fff';
			ctx.fillText('历史最高分：' + Math.max(opt.highest_score, opt.score), this._cx(207), this._cy(703));

			// 历史最高分 / 本周最高分 / 各种称号
			if (type == 'history') {
				if (this.changlleList.length == 0) {
					// 没有超越好友
					ctx.lineWidth = 2 * Dpr;
					ctx.strokeStyle = 'rgba(255,255,255,0.06)';
					ctx.fillStyle = 'rgba(0,0,0,0.6)';
					this._roundedRectR(this._cx(30), this._cy(104), this._cwh(354), this._cwh(371), 4 * Dpr, 'bg');
					ctx.fill();
					// 分享
					this._drawImageCenter('res/pure_share.png', this._cx(207), this._cy(440), this._cwh(18), this._cwh(24), 'bg', null, this.imgid['bg']);
				} else {
					// 有超越的好友
					ctx.lineWidth = 2 * Dpr;
					ctx.strokeStyle = 'rgba(255,255,255,0.06)';
					ctx.fillStyle = 'rgba(0,0,0,0.6)';
					this._roundedRectR(this._cx(30), this._cy(104), this._cwh(354), this._cwh(401), 4 * Dpr, 'bg');
					ctx.fill();
					// 线
					ctx.lineWidth = 0.5 * Dpr;
					ctx.strokeStyle = 'rgba(255,255,255,0.2)';
					ctx.beginPath();
					ctx.moveTo(this._cx(127), this._cy(406));
					ctx.lineTo(this._cx(287), this._cy(406));
					ctx.stroke();
					ctx.closePath();

					ctx.font = this._cf(14);
					ctx.fillStyle = '#fff';
					ctx.fillText('排名新超越' + this.changlleList.length + '位好友', this._cx(207), this._cy(429));

					// 好友头像
					this.changlleListStart = 0;
					this._reDrawChangeAva(0);

					// 分享
					this._drawImageCenter('res/pure_share.png', this._cx(207), this._cy(368), this._cwh(18), this._cwh(24), 'bg', null, this.imgid['bg']);
				}
				// 开始一坨称号的表演
				var other_msg = '';
				var color = '';
				var w = 80;
				if (this.opt.msg == '历史最高分') {
					/*if(this.opt.highest_score < 100 && this.opt.score >= 100) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 200 && this.opt.score >= 200) {
     	other_msg = '初窥门径';
     } 
     if(this.opt.highest_score < 300 && this.opt.score >= 300) {
     	other_msg = '初窥门径';
     } 
     if(this.opt.highest_score < 400 && this.opt.score >= 400) {
     	other_msg = '初窥门径'; 
     } 
     if(this.opt.highest_score < 500 && this.opt.score >= 500) {
     	other_msg = '初窥门径'; 
     } 
     if(this.opt.highest_score < 600 && this.opt.score >= 600) {
     	other_msg = '初窥门径'; 
     } 
     if(this.opt.highest_score < 700 && this.opt.score >= 700) {
     	other_msg = '初窥门径'; 
     } 
     if(this.opt.highest_score < 800 && this.opt.score >= 800) {
     	other_msg = '初窥门径'; 
     }
     if(this.opt.highest_score < 900 && this.opt.score >= 900) {
     	other_msg = 'hel';
     } 
     if(this.opt.highest_score < 1000 && this.opt.score >= 1000) {
     	other_msg = '0000000000000000';
     } 
     if(this.opt.highest_score < 1500 && this.opt.score >= 1500) {
     	other_msg = '初窥门径';
     } 
     if(this.opt.highest_score < 2000 && this.opt.score >= 2000) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 2500 && this.opt.score >= 2500) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 3000 && this.opt.score >= 3000) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 3500 && this.opt.score >= 3500) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 4000 && this.opt.score >= 4000) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 4500 && this.opt.score >= 4500) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 5000 && this.opt.score >= 5000) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 5500 && this.opt.score >= 5500) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 6000 && this.opt.score >= 6000) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 6500 && this.opt.score >= 6500) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 7000 && this.opt.score >= 7000) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 7500 && this.opt.score >= 7500) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 8000 && this.opt.score >= 8000) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 8500 && this.opt.score >= 8500) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 9000 && this.opt.score >= 9000) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 9500 && this.opt.score >= 9500) {
     	other_msg = '初窥门径';
     }
     if(this.opt.highest_score < 10000 && this.opt.score >= 10000) {
     	other_msg = '初窥门径';
     }*/
					if (this.opt.highest_score < 100 && this.opt.score >= 100) {
						// 第一次达到100分
						other_msg = '初窥门径';
						color = '#509FC9';
					}
					if (this.opt.highest_score < 500 && this.opt.score >= 500) {
						other_msg = '耐得寂寞';
						color = '#E67600';
					}
					if (this.opt.highest_score < 1000 && this.opt.score >= 1000) {
						other_msg = '登堂入室';
						color = '#009D5E';
					}
					if (this.opt.highest_score < 2000 && this.opt.score >= 2000) {
						other_msg = '无聊大师';
						color = '#7A0096';
					}
					if (this.opt.highest_score < 3000 && this.opt.score >= 3000) {
						other_msg = '一指禅';
						color = '#555555';
					}
					if (this.opt.highest_score < 5000 && this.opt.score >= 5000) {
						other_msg = '立地成佛';
						color = '#AC8742';
					}
					// 结束一坨称号的表演
				}
				if (!!other_msg) {
					/*if(this.opt.score > 9000){
     	color = '#AC8742';
     } else if(this.opt.score > 6000){
     	color = '#555555';
     } else if(this.opt.score > 3000){
     	color = '#7A0096';
     } else if(this.opt.score > 1000){
     	color = '#009D5E';
     } else if(this.opt.score > 500){
     	color = '#E67600';
     } else {
     	color = '#509FC9';
     }
     	if( other_msg.length <= 4){
     	w = 80
     } else if(other_msg.length <= 6){
     	w = 120
     } else {
     	w = 160
     }*/
					ctx.fillStyle = color;
					ctx.strokeStyle = color;
					ctx.lineWidth = 1 * Dpr;

					// ctx.fillRect( this._cx(163), this._cy(154), this._cx(88), this._cx(26) );
					this._roundedRectR(this._cx(207 - w / 2), this._cy(154), this._cwh(w), this._cwh(26), 2 * Dpr, 'bg');
					ctx.fill();
					ctx.fillStyle = 'white';
					ctx.textAlign = 'center';
					ctx.textBaseline = 'middle';
					ctx.font = 'bold ' + this._cf(14);
					ctx.fillText(other_msg, this._cx(207), this._cy(167));
				} else this._drawImageCenter('res/new.png', this._cx(207), this._cy(167), this._cwh(58), this._cwh(26), 'bg', null, this.imgid['bg']);

				ctx.font = this._cf(14);
				ctx.textAlign = "center";
				ctx.fillStyle = '#fff';
				ctx.textBaseline = 'middle';

				ctx.fillText(this.opt.msg || '本周最高分', this._cx(207), this._cy(224));

				ctx.font = this._cf(86, true);
				ctx.fillStyle = '#00c777';
				ctx.fillText(opt.score, this._cx(207), this._cy(292.5));
			}

			// 排行榜最高分
			if (type == 'rank') {
				this._drawImageCenter('res/new.png', this._cx(207), this._cy(167), this._cwh(58), this._cwh(26), 'bg', null, this.imgid['bg']);

				ctx.lineWidth = 2 * Dpr;
				ctx.strokeStyle = 'rgba(255,255,255,0.06)';
				ctx.fillStyle = 'rgba(0,0,0,0.6)';
				this._roundedRectR(this._cx(30), this._cy(104), this._cwh(354), this._cwh(371), 4 * Dpr, 'bg');
				ctx.fill();

				var that = this;
				this._drawImageRound(this.myUserInfo.headimg, this._cx(207), this._cy(291), this._cwh(56), this._cwh(56), 'bg', function () {
					that._drawImageCenter('res/gold.png', that._cx(207), that._cy(253), that._cwh(40), that._cwh(40), 'bg', null, that.imgid['bg']);
				}, this.imgid['bg']);

				ctx.font = this._cf(14);
				ctx.textAlign = "center";
				ctx.fillStyle = '#fff';
				ctx.textBaseline = 'middle';
				ctx.fillText('排行榜冠军', this._cx(207), this._cy(224));

				ctx.font = this._cf(40, true);
				ctx.fillStyle = '#00c777';
				ctx.fillText(opt.score, this._cx(207), this._cy(349));

				// 分享
				this._drawImageCenter('res/pure_share.png', this._cx(207), this._cy(415), this._cwh(18), this._cwh(24), 'bg', null, this.imgid['bg']);
			}

			// title的小方块
			ctx.fillStyle = 'rgba(255,255,255,0.2)';
			ctx.fillRect(this._cx(155), this._cy(218.5), this._cwh(9), this._cwh(3));
			ctx.fillRect(this._cx(155), this._cy(224.5), this._cwh(9), this._cwh(3));
			ctx.fillRect(this._cx(248), this._cy(218.5), this._cwh(9), this._cwh(3));
			ctx.fillRect(this._cx(248), this._cy(224.5), this._cwh(9), this._cwh(3));

			// 关闭 - 回到正常结算页
			this._drawImageCenter('res/close.png', this._cx(375), this._cy(112), this._cwh(43), this._cwh(43), 'bg', null, this.imgid['bg']);

			// 头像会改变层级，所以要在头像之后显示
			var ctx1 = this.context['btn'];
			ctx1.clearRect(this._cx(91), this._cy(547), this._cwh(232), this._cwh(94));
			this._drawImageCenter('res/replay.png', this._cx(207), this._cy(607), this._cwh(212), this._cwh(84), 'btn', null, this.imgid['btn']);

			// 礼花
			this._drawImageCenter('res/flower.png', this._cx(207), this._cy(290), this._cwh(260), this._cwh(141), 'bg', null, this.imgid['bg']);

			/*var that = this;
   this.particles = {};
   setInterval(function(){
   	that.explode(-7, 9, 1);// 烟花动画
   	that.explode(7, 9, 2);// 烟花动画
   	that.explode(0, 2, 3);// 烟花动画
   }, 3000)*/
			this._updatePlane('bg');
		}
	}, {
		key: '_reDrawChangeAva',
		value: function _reDrawChangeAva(pos) {
			var _this3 = this;

			this.imgid['btn']++; // 避免上一次的头像显示在这里
			if (this.changlleListStart + pos * 5 < 0 || this.changlleListStart + pos * 5 >= this.changlleList.length) {
				return;
			}
			this.changlleListStart = this.changlleListStart + pos * 5;

			var show_ava_list = this.changlleList.slice(this.changlleListStart, this.changlleListStart + 5);
			var n = show_ava_list.length,
			    w = 32,
			    p = 10;
			var startx = 207 - (n * 32 + (n - 1) * 10) / 2;

			var ctx = this.context['btn'];
			ctx.clearRect(this._cx(30), this._cy(448), this._cwh(354), this._cwh(55));

			var _loop2 = function _loop2() {
				var x0 = _this3._cx(startx + w / 2 + i * (w + p));
				that = _this3;

				_this3._drawImageRound(show_ava_list[i].headimg, x0, _this3._cy(469), _this3._cwh(w), _this3._cwh(w), 'btn', function () {
					that._drawImageCenter('res/ava_rank.png', x0, that._cy(469), that._cwh(w + 14), that._cwh(w + 14), 'btn', null, that.imgid['btn']);
				}, _this3.imgid['btn'], true);
			};

			for (var i = 0; i < n; i++) {
				var that;

				_loop2();
			}

			// 是否显示左右箭头
			if (this.changlleList.length > 5 && this.changlleListStart + 5 < Math.floor(this.changlleList.length / 5) * 5) {
				this._drawImageCenter('res/r_arr1.png', this._cx(339), this._cy(469), this._cwh(6), this._cwh(8), 'btn', null, this.imgid['btn']);
			}
			if (this.changlleList.length > 5 && this.changlleListStart != 0) {
				this._drawImageCenter('res/l_arr.png', this._cx(69), this._cy(469), this._cwh(6), this._cwh(8), 'btn', null, this.imgid['btn']);
			}
		}
	}, {
		key: '_drawBeginner',
		value: function _drawBeginner() {
			var ctx = this.context['bg'];
			ctx.clearRect(0, 0, WIDTH, HEIGHT);

			ctx.fillStyle = 'rgba(255,255,255,0.3)';
			ctx.fillRect(this._cx(103), this._cy(134), this._cwh(206), this._cwh(115));

			ctx.fillStyle = 'black';
			ctx.textBaseline = 'middle';
			ctx.textAlign = 'center';
			ctx.font = this._cf(17);
			ctx.fillText('长按屏幕并释放', this._cx(207), this._cy(172));

			ctx.textAlign = 'left';
			ctx.fillText('控制', this._cx(149), this._cy(213));

			ctx.textAlign = 'right';
			ctx.fillText('向前跳', this._cx(265), this._cy(213));

			this._drawImageCenter('res/i.png', this._cx(198), this._cy(211), this._cwh(13.2), this._cwh(35.6), 'bg', null, this.imgid['bg']);

			this._updatePlane('bg');
		}
		// ----------------- 画布创建与更新 -----------------

	}, {
		key: '_createPlane',
		value: function _createPlane() {
			// 创建画布
			if (!!this.canvas['bg']) return;
			for (var i = 0; i < planList.length; i++) {
				this.canvas[planList[i]] = document.createElement('canvas');
				this.context[planList[i]] = this.canvas[planList[i]].getContext('2d');
				this.canvas[planList[i]].width = WIDTH;
				if (planList[i] == 'list1' || planList[i] == 'list2') {
					// 高度是10倍的列表高度
					this.canvas[planList[i]].height = 10 * this._cwh(ListLineHeight);
				} else {
					this.canvas[planList[i]].height = HEIGHT;
				}

				this.texture[planList[i]] = new THREE.Texture(this.canvas[planList[i]]);
				// this.texture[i].needsUpdate = true;
				this.material[planList[i]] = new THREE.MeshBasicMaterial({ map: this.texture[planList[i]], transparent: true });
				if (planList[i] == 'list1' || planList[i] == 'list2') {
					this.geometry[planList[i]] = new THREE.PlaneGeometry(frustumSizeWidth, 10 * this._cwh(ListLineHeight) / HEIGHT * frustumSizeHeight);
				} else {
					this.geometry[planList[i]] = new THREE.PlaneGeometry(frustumSizeWidth, frustumSizeHeight);
				}
				this.obj[planList[i]] = new THREE.Mesh(this.geometry[planList[i]], this.material[planList[i]]);
				this.material[planList[i]].map.minFilter = THREE.LinearFilter;
				this.obj[planList[i]].position.y = 0; // 上下
				this.obj[planList[i]].position.x = 0; // 左右
				this.obj[planList[i]].position.z = 9 - i * 0.001; // 前后 -1 - scrollBar , -2 background, -3 list 1, -4 list 2
			}

			if (DEBUG && showDebugImg) {
				var ctx = this.context['sample'];
				ctx.globalAlpha = 0.4;
				var that = this;
				setTimeout(function () {
					that._drawImageCenter('res/sample.png', that._cx(207), that._cy(368), that._cwh(414), that._cwh(736), 'sample', null, that.imgid);
				}, 2000);
			}
		}
	}, {
		key: '_updatePlane',
		value: function _updatePlane(type) {
			// 画布更新
			if (!this.showState) {
				return;
			}

			if (this.canvasType == CANVASTYPE['gameOver'] && type != 'bg' && type != 'btn' && type != 'sample') {
				return;
			}
			if (this.canvasType == CANVASTYPE['start'] && type != 'bg' && type != 'btn' && type != 'sample') {
				return;
			}
			this.texture[type].needsUpdate = true;
			this.obj[type].visible = true;
			this.options.camera.add(this.obj[type]);
		}
	}, {
		key: '_updateClip',
		value: function _updateClip() {
			// 更新切面位置
			var cp0 = this.p0.clone();
			var cp1 = this.p1.clone();
			var cp2 = this.p2.clone();
			var cp3 = this.p3.clone();
			var cp4 = this.p4.clone();
			if (this.canvasType == CANVASTYPE['pk']) {
				cp1 = this.p5.clone();
				cp2 = this.p6.clone();
				cp3 = this.p7.clone();
				cp4 = this.p8.clone();
			}

			this.options.camera.updateMatrixWorld();
			var matrixWorld = this.options.camera.matrixWorld;

			cp0.applyMatrix4(matrixWorld);
			cp1.applyMatrix4(matrixWorld);
			cp2.applyMatrix4(matrixWorld);
			cp3.applyMatrix4(matrixWorld);
			cp4.applyMatrix4(matrixWorld);

			var triangle = new THREE.Triangle(cp2, cp1);
			var cutA = triangle.plane();
			this._negatePlane(cutA, cp0.clone());

			triangle = new THREE.Triangle(cp3, cp2);
			var cutB = triangle.plane();
			this._negatePlane(cutB, cp0.clone());

			triangle = new THREE.Triangle(cp4, cp3);
			var cutC = triangle.plane();
			this._negatePlane(cutC, cp0.clone());

			triangle = new THREE.Triangle(cp1, cp4);
			var cutD = triangle.plane();
			this._negatePlane(cutD, cp0.clone());

			this.material['list1'].clippingPlanes = [cutA, cutB, cutC, cutD];
			this.material['list1'].needsUpdate = true;
			this.material['list2'].clippingPlanes = [cutA, cutB, cutC, cutD];
			this.material['list2'].needsUpdate = true;

			// 更新切面位置结束
		}

		// ----------------- 工具函数 -----------------

	}, {
		key: '_cname',
		value: function _cname(x, namelen) {
			namelen = namelen || 16;
			x = x || '';
			var len = x.replace(/[^\x00-\xff]/g, '**').length;
			if (len > namelen) {
				x = this._sliceName(x, namelen) + '...';
			}
			return x;
		}
	}, {
		key: '_sliceName',
		value: function _sliceName(x, namelen) {
			x = x || '';
			var len = x.replace(/[^\x00-\xff]/g, '**').length;
			if (len > namelen) {
				x = x.substring(0, x.length - 1);
				x = this._sliceName(x, namelen);
			}
			return x;
		}
	}, {
		key: '_cwh',
		value: function _cwh(x) {
			var realx = x * W / 414;
			if (H / W < 736 / 414) {
				// 某4
				realx = x * H / 736;
			}
			return realx * Dpr;
		}
	}, {
		key: '_cx',
		value: function _cx(x) {
			// change x 
			// x 为 在 414*736 屏幕下的，标准像素的 x ，即为设计图的x的px值
			// realx 表示在当前屏幕下，应该得到的x值，这里所有屏幕画布将按照x轴缩放
			var realx = x * W / 414;
			if (H / W < 736 / 414) {
				// 某4
				realx = x * H / 736 + (W - H * 414 / 736) / 2;
			}
			return realx * Dpr;
		}
	}, {
		key: '_cy',
		value: function _cy(y) {
			// change y
			// y 位在 414*736 屏幕下的，标准像素的y，即为设计图的y的px值
			// realy表示在当前屏幕下，应该得到的y值，如果屏幕的长宽值特别大（某X，某note8），那么就上下留白
			var really;
			if (H / W > 736 / 414) {
				// 某X
				// 屏幕显示区域的高度h: WIDTH*736/414, 上下留白是  (HEIGHT - h)/2
				really = y * W / 414 + (H - W * 736 / 414) / 2;
			} else {
				really = y * H / 736;
			}
			return really * Dpr;
		}
	}, {
		key: '_cf',
		value: function _cf(size, is_num) {
			// font size 
			var realf = size * Dpr * W / 414;
			if (H / W < 736 / 414) {
				// 某4
				realf = size * Dpr * H / 736;
			}
			if (!!is_num && !!family) return realf + ('px ' + family);else return realf + 'px Helvetica';
		}
	}, {
		key: '_cxp',
		value: function _cxp(x) {
			// 根据坐标反推出x
			return x / W * 414;
		}
	}, {
		key: '_cyp',
		value: function _cyp(y) {
			// 根据坐标反推出y
			var really;
			if (H / W > 736 / 414) {
				// 某X
				// 屏幕显示区域的高度h: WIDTH*736/414, 上下留白是  (HEIGHT - h)/2
				really = (y - (H - W * 736 / 414) / 2) / W * 414;
			} else {
				really = y / H * 736;
			}
			return really;
		}
	}, {
		key: '_negatePlane',
		value: function _negatePlane(plane, point) {
			if (!plane || !point) {
				return;
			}
			var distance = plane.distanceToPoint(point);
			if (distance < 0) {
				plane.negate();
			}
		}
	}, {
		key: '_drawImageCenter',
		value: function _drawImageCenter(src, x, y, width, height, type, cb, imgid, noupdate) {
			// imgid 是渲染时候的imgid， 在每次改变画布的时候自增
			// 以xy为中心来显示一副图片

			if (src == '/0' || src == '/96' || src == '/64' || !src) {
				src = 'res/ava.png';
			}
			var img = new Image();
			var that = this;
			img.onload = function () {
				if (that.imgid[type] == imgid) {
					that.context[type].drawImage(img, x - width / 2, y - height / 2, width, height);
					!!cb && cb();
					if (!noupdate) that._updatePlane(type); // 更新画布
				} else {}
					//console.log(that.imgid[type], imgid, type, src, '出现了时序错误!!!')

					// 切到了其他场景，自然cb也就不需要了
			};
			img.onerror = function () {
				!!cb && cb();
			};
			img.src = src;
		}
	}, {
		key: '_drawImageRound',
		value: function _drawImageRound(src, x, y, width, height, type, cb, imgid, noupdate) {
			// imgid 是渲染时候的imgid， 在每次改变画布的时候自增
			// 以xy为中心来显示一副图片
			if (src == '/0' || src == '/96' || src == '/64' || !src) {
				src = 'res/ava.png';
			}
			// src = 'http://wx.qlogo.cn/mmhead/Q3auHgzwzM73y96lOXERaFVGib5ENtBXAVQ1Zn9Wk1oNIAEKibq7jMTA/96'
			var img = new Image();
			var that = this;
			var ctx = this.context[type];
			var can = this.canvas[type];
			img.onload = function () {
				if (that.imgid[type] == imgid) {
					ctx.save();
					that._roundedRectR(x - width / 2, y - height / 2, width, height, 2, type);
					ctx.clip();
					ctx.drawImage(img, x - width / 2, y - height / 2, width, height);
					ctx.closePath();
					ctx.restore();
					!!cb && cb();
					if (!noupdate) that._updatePlane(type); // 更新画布
				} else {}
					//console.log(that.imgid[type], imgid, type, src, '出现了时序错误!!!')

					// 切到了其他场景，自然cb也就不需要了
			};
			img.onerror = function () {
				!!cb && cb();
			};
			img.src = src;
		}
	}, {
		key: '_rerank',
		value: function _rerank(array) {
			// 排行榜重新排序
			var i = 0,
			    len = array.length,
			    j,
			    d;
			for (; i < len; i++) {
				for (j = 0; j < len; j++) {
					if (array[i].week_best_score > array[j].week_best_score) {
						d = array[j];
						array[j] = array[i];
						array[i] = d;
					}
				}
			}
			return array;
		}
	}, {
		key: '_findSelfIndex',
		value: function _findSelfIndex(element, index, array) {
			// 从排行列表中找出自己的排名
			return element.nickname === this.myUserInfo.nickname;
		}
	}, {
		key: '_findPartner',
		value: function _findPartner(element, index, array) {
			// 从排行列表中找出自己的排名
			return element.is_self === 1;
		}
	}, {
		key: '_roundedRectR',
		value: function _roundedRectR(x, y, width, height, radius, type) {
			var ctx = this.context[type];
			ctx.beginPath();
			ctx.moveTo(x, y + radius - 1);
			ctx.lineTo(x, y + height - radius);
			ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
			ctx.lineTo(x + width - radius, y + height);
			ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
			ctx.lineTo(x + width, y + radius);
			ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
			ctx.lineTo(x + radius, y); // 终点
			ctx.quadraticCurveTo(x, y, x, y + radius);
			ctx.stroke();
			ctx.closePath();
		}
	}, {
		key: 'explode',
		value: function explode(x, y, idx) {
			if (!this.particles[idx]) {
				var colors = [0x00B6F1, 0x1800FF, 0xFF0000, 0xFEFF00, 0x00FF00];
				this.materials = [];
				var geometry = new THREE.PlaneGeometry(0.4, 0.4);
				for (var i = 0; i < colors.length; ++i) {
					this.materials.push(new THREE.MeshBasicMaterial({ color: colors[i], transparent: true }));
				}
				this.particles[idx] = [];
				for (var i = 0; i < 25; ++i) {
					var particle = new THREE.Mesh(geometry, this.materials[i % colors.length]);
					// particle.position.set(0, 0, 9.9);
					this.options.camera.add(particle);
					this.particles[idx].push(particle);
				}
			}
			var t1 = 0.35;
			var t2 = 0.35;

			for (var i = 0; i < this.particles[idx].length; ++i) {
				var x0 = x,
				    y0 = y;
				this.particles[idx][i].position.set(x0, y0, 9.9);

				// 快速 随机左右散开，占 2/3
				var x1 = (1 - 2 * Math.random()) * 5 + x0;
				var y1 = (1 - 2 * Math.random()) * 5 + y0;

				var x11 = x0 + (x1 - x0) * 0.95;
				var y11 = y0 + (y1 - y0) * 0.95;

				_animation.customAnimation.to(this.particles[idx][i].position, t1, {
					x: x11,
					y: y11
				});

				_animation.customAnimation.to(this.particles[idx][i].position, t2, {
					x: x1,
					y: y1,
					delay: t1
				});
			}
			/*for (var i = 0; i < this.materials.length; ++i) {
   	this.materials[i].opacity = 1;
   	customAnimation.to(this.materials[i], t2, { opacity: 0, delay: t1});
   }*/
		}
	}, {
		key: 'showFinger',
		value: function showFinger() {
			var _this4 = this;

			return;
			if (!this.hand) {
				this.hand = new THREE.Mesh(new THREE.PlaneGeometry(2, 3.4), new THREE.MeshBasicMaterial({ map: _config.loader.load('res/hand.png'), transparent: true }));
				this.hand.position.set(11, -8, 9.9);
				this.circle = new THREE.Mesh(new THREE.RingGeometry(1, 1.2, 30), new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true }));
				this.circle.position.set(10.5, -6.8, 9.9);
			}
			this.options.camera.add(this.hand);
			this.options.camera.add(this.circle);
			_animation.customAnimation.to(this.circle.material, 0.1, { opacity: 1 });
			_animation.customAnimation.to(this.circle.scale, 0.3, { x: 1.5, y: 1.5, z: 1.5 });
			_animation.customAnimation.to(this.circle.material, 0.1, { opacity: 0, delay: 1.3 });

			_animation.customAnimation.to(this.hand.scale, 0.5, { x: 1, y: 1, delay: 1 });
			_animation.customAnimation.to(this.hand.scale, 0.5, { x: 1.5, y: 1.5, delay: 2 });

			this.fingerTimer = setTimeout(function () {
				_this4.showFinger();
				_this4.circle.scale.set(1, 1, 1);
			}, 3000);
		}
	}, {
		key: 'clearFinger',
		value: function clearFinger() {
			if (this.fingerTimer) {
				clearTimeout(this.fingerTimer);
				this.fingerTimer = null;
			}
			this.opts.camera.remove(this.hand);
		}
	}]);

	return Rank;
}();

exports.default = Rank;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var singleSettlementPage = function () {
  function singleSettlementPage(camera) {
    _classCallCheck(this, singleSettlementPage);

    var material = new THREE.MeshBasicMaterial({ color: 0x0080c0 });
    var rankList = new THREE.Mesh(new THREE.PlaneGeometry(5, 5), material);
    var replay = rankList.clone();
    var challenge = rankList.clone();

    replay.position.set(0, -20, -1);
    rankList.position.set(-10, -20, -1);
    challenge.position.set(10, -20, -1);

    this.ui = [replay, rankList, challenge];
    this.camera = camera;
  }

  _createClass(singleSettlementPage, [{
    key: 'show',
    value: function show() {
      var _this = this;

      this.ui.forEach(function (ui) {
        _this.camera.add(ui);
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      var _this2 = this;

      this.ui.forEach(function (ui) {
        _this2.camera.remove(ui);
      });
    }
  }]);

  return singleSettlementPage;
}();

exports.default = singleSettlementPage;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

var _config = __webpack_require__(2);

var _text = __webpack_require__(8);

var _text2 = _interopRequireDefault(_text);

var _animation = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// 间隔时常
// const minDistance = 0
var minDistance = 5;

// 启动步数
// const minStartDistance = 10
var minStartDistance = 2;

var AvatorRadius = 1.3;
var OuterRadius = AvatorRadius / 20 * 21;
var InnerRadius = OuterRadius - 0.5;
var AvatorY = 10;
var AnimateDuration = 0.8;
var AnimateHeight = 3;

var startScale = 0;

function roundedRect(ctx, x, y, width, height, radius) {
  ctx.moveTo(x, y + radius);
  ctx.lineTo(x, y + height - radius);
  ctx.quadraticCurveTo(x, y + height, x + radius, y + height);
  ctx.lineTo(x + width - radius, y + height);
  ctx.quadraticCurveTo(x + width, y + height, x + width, y + height - radius);
  ctx.lineTo(x + width, y + radius);
  ctx.quadraticCurveTo(x + width, y, x + width - radius, y);
  ctx.lineTo(x + radius, y);
  ctx.quadraticCurveTo(x, y, x, y + radius);
  return ctx;
}

function reMapUv(geometry) {
  geometry.computeBoundingBox();

  var max = geometry.boundingBox.max,
      min = geometry.boundingBox.min;
  var offset = new THREE.Vector2(0 - min.x, 0 - min.y);
  var range = new THREE.Vector2(max.x - min.x, max.y - min.y);
  var faces = geometry.faces;

  geometry.faceVertexUvs[0] = [];

  for (var i = 0; i < faces.length; i++) {

    var v1 = geometry.vertices[faces[i].a],
        v2 = geometry.vertices[faces[i].b],
        v3 = geometry.vertices[faces[i].c];

    geometry.faceVertexUvs[0].push([new THREE.Vector2((v1.x + offset.x) / range.x, (v1.y + offset.y) / range.y), new THREE.Vector2((v2.x + offset.x) / range.x, (v2.y + offset.y) / range.y), new THREE.Vector2((v3.x + offset.x) / range.x, (v3.y + offset.y) / range.y)]);
  }
  geometry.uvsNeedUpdate = true;
}

var RankSystem = function () {
  function RankSystem(game) {
    _classCallCheck(this, RankSystem);

    this.game = game;
    this.seed = 0;
    this.startDist = 0;

    this.hitPoint = {
      uuid: '',
      ready: false,
      texture: null
    };

    this.loader = new THREE.TextureLoader();

    this.text = new _text2.default('超越！', {
      fillStyle: 0x252525,
      chinese: true,
      textAlign: 'center'
    });
    // this.avatorFrame = new THREE.Mesh(new THREE.PlaneGeometry(AvatorRadius * 2, AvatorRadius * 2), new THREE.MeshBasicMaterial({
    //   transparent: true,
    //   opacity: 1
    // }))

    var shape = new THREE.Shape();
    shape = roundedRect(shape, -OuterRadius, -OuterRadius, OuterRadius * 2, OuterRadius * 2, 0.5);
    var shape2 = new THREE.Shape();
    shape2 = roundedRect(shape2, -AvatorRadius, -AvatorRadius, AvatorRadius * 2, AvatorRadius * 2, 0.5);

    var geometry = new THREE.ShapeGeometry(shape2);
    reMapUv(geometry);

    this.avatorFrame = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
      transparent: true,
      opacity: 1
    }));

    this.avatorOuter = new THREE.Mesh(new THREE.ShapeGeometry(shape), new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 1
    }));

    this.text.obj.scale.set(0.8, 0.8, 0.8);
    this.text.obj.position.set(0, 2.2, 0.1);

    this.avatorFrame.position.set(0, 0, 0.1);
    // this.avatorFrame.scale.set(startScale, startScale, startScale)
    this.avatorFrame.material.opacity = 0;

    this.avatorOuter.position.set(0, 0, 0);
    // this.avatorOuter.scale.set(startScale, startScale, startScale)
    this.avatorOuter.material.opacity = 0;
    this.text.material.opacity = 0;

    this.obj = new THREE.Object3D();

    this.text.obj.visible = false;
    this.obj.add(this.avatorOuter);
    this.obj.add(this.avatorFrame);
    this.obj.add(this.text.obj);

    this.obj.rotateY(-Math.PI / 4);
    this.obj.rotateX(-Math.PI / 16 * 3);
    this.game.scene.add(this.obj);
    this.obj.visible = false;
  }

  _createClass(RankSystem, [{
    key: 'update',
    value: function update() {

      // 没有好友数据就不更新了
      if (!this.game.gameModel.friendsScore) {
        return;
      }
      if (!this.game.gameModel.friendsScore.length) {
        return;
      }

      // 计步器++
      this.seed++;

      if (this.hitPoint.uuid == this.game.currentBlock.obj.uuid && this.hitPoint.ready && this.hitPoint.texture) {
        if (this.startDist < minStartDistance) {
          this.startDist++;
          // this.obj.add(this.text.obj)
          this.text.obj.visible = true;
        }
        this.playAnimate();
        this.seed = 0;
      }

      // 如果开始走过的步数小于最小出现步数
      // if (this.startDist < minStartDistance) {
      //   this.startDist++
      //   return
      // }

      // 计算计步器是不是大于间隔步伐
      if (this.seed >= minDistance) {
        // if (this.game.UI.score >= this.game.heightestScore) {
        this.checkScore();
        // }
      }
      // console.log('seed', this.seed)
    }
  }, {
    key: 'checkScore',
    value: function checkScore() {
      // 获取当前分数，找出下一个分数与你差别在1的人
      var score = this.game.UI.score;
      var friends = this.game.gameModel.friendsScore;

      // 遍历数组，获取人-----待优化性能
      try {
        for (var i = 0; i < friends.length; i++) {
          // !! roy 这里有风险，score_info[0]可能会是次数
          if (friends[i].week_best_score == score) {
            this.hitPoint.uuid = this.game.nextBlock.obj.uuid;
            this.hitPoint.ready = false;
            // this.showAvator(friends[i])
            this.animateAvator(friends[i]);
            break;
          }
        }
      } catch (e) {
        console.log('RankSystem checkScore err:', e);
      }
    }
  }, {
    key: 'animateAvator',
    value: function animateAvator(user) {
      var _this = this;

      this.loader.load(user.headimg, function (texture) {
        if (_this.hitPoint.uuid == _this.game.nextBlock.obj.uuid) {
          _this.hitPoint.ready = true;
          texture.minFilter = THREE.LinearFilter;
          _this.hitPoint.texture = texture;
        }
      });
    }
  }, {
    key: 'playAnimate',
    value: function playAnimate() {
      var _this2 = this;

      /**
       * 更改加分位置
       */
      // console.log('showAvator')
      this.game.bottle.changeScorePos(3);

      var _game$bottle$obj$posi = this.game.bottle.obj.position.clone(),
          x = _game$bottle$obj$posi.x,
          z = _game$bottle$obj$posi.z;

      this.obj.position.set(x, AvatorY, z);

      this.avatorFrame.material.map = this.hitPoint.texture;

      this.obj.visible = true;

      // TweenMax.to(this.obj.position, 1.6, {
      //   y: AnimateHeight + AvatorY,
      //   // onComplete: () => {
      //   //   this.resetAvator()
      //   //   this.game.bottle.changeScorePos(0)
      //   // }
      // });

      // TweenMax.to([this.text.obj.material, this.avatorOuter.material, this.avatorFrame.material], 1.6, {
      //   opacity: 0,
      //   onComplete: () => {
      //     this.resetAvator()
      //     this.game.bottle.changeScorePos(0)
      //   }
      // });

      _animation.customAnimation.to(this.obj.position, 0.4, {
        y: AnimateHeight + AvatorY
      });
      _animation.customAnimation.to(this.text.material, 0.4, {
        opacity: 1
      });
      _animation.customAnimation.to(this.avatorOuter.material, 0.4, {
        opacity: 1
      });
      _animation.customAnimation.to(this.avatorFrame.material, 0.4, {
        opacity: 1
      });

      _animation.customAnimation.to(this.text.material, 0.4, {
        opacity: 0,
        delay: 0.6,
        onComplete: function onComplete() {
          _this2.resetAvator();
          _this2.game.bottle.changeScorePos(0);
        }
      });
      _animation.customAnimation.to(this.avatorOuter.material, 0.4, {
        opacity: 0,
        delay: 0.6
      });
      _animation.customAnimation.to(this.avatorFrame.material, 0.4, {
        opacity: 0,
        delay: 0.6
      });

      this.hitPoint.uuid = '';
      this.hitPoint.ready = false;
      this.hitPoint.texture = null;
    }
  }, {
    key: 'resetAvator',
    value: function resetAvator() {
      this.obj.visible = false;
      this.text.obj.visible = false;
      // this.obj.remove(this.text.obj)

      this.avatorFrame.material.opacity = 0;
      // this.avatorFrame.material.opacity = 1
      // this.avatorFrame.scale.set(startScale, startScale, startScale)
      this.avatorFrame.material.map = '';

      // this.avatorOuter.scale.set(startScale, startScale, startScale)
      this.avatorOuter.material.opacity = 0;
      // this.avatorOuter.material.opacity = 1

      // this.text.obj.material.opacity = 1
      this.text.material.opacity = 0;
    }
  }, {
    key: 'reset',
    value: function reset() {
      this.seed = 0;
      this.seed = 0;
      this.startDist = 0;
      this.startDist = 0;
      this.hitPoint = {
        uuid: '',
        ready: false,
        texture: null
      };
      this.obj.visible = false;
    }
  }]);

  return RankSystem;
}();

exports.default = RankSystem;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _storage = __webpack_require__(5);

var _storage2 = _interopRequireDefault(_storage);

var _network = __webpack_require__(3);

var _network2 = _interopRequireDefault(_network);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// var data = {
//   accurate: 0,
//   bonus: 0
// }

var historyTimes = function () {
  function historyTimes(game) {
    _classCallCheck(this, historyTimes);

    this.times = _storage2.default.getHistoryTimes();
    if (!this.times) {
      this.times = {
        accurate: 0,
        bonus: 0
      };
    }
    this.game = game;
    this.limitScore = 5;
  }

  // 与服务器的数据进行比较


  _createClass(historyTimes, [{
    key: 'verifyScore',
    value: function verifyScore(onlineScore) {
      if (onlineScore >= this.times.accurate) {

        // 如果网上的分数比当前分数大，则赋值，更新本地缓存
        this.times.accurate = onlineScore;

        if (this.times.bonus >= this.limitScore) {

          // 如果累加分数超过5分
          this.upLoadHistoryTimes();
        } else {

          _storage2.default.saveHistoryTimes(this.times);
        }
      } else {
        this.upLoadHistoryTimes();
      }
    }
  }, {
    key: 'addOne',
    value: function addOne() {
      // console.log('score add one')
      this.times.bonus++;
      // this.checkUp()
    }
  }, {
    key: 'checkUp',
    value: function checkUp() {
      if (this.times.bonus >= this.limitScore) {

        // 如果累加分数超过5分
        this.upLoadHistoryTimes();
      } else {
        _storage2.default.saveHistoryTimes(this.times);
      }
    }
  }, {
    key: 'upLoadHistoryTimes',
    value: function upLoadHistoryTimes() {
      var highestScore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var verifyData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var times = this.times.accurate + this.times.bonus;
      // 上传分数
      _network2.default.requestSettlement(highestScore, times, this.afterUpload.bind(this), verifyData);
    }
  }, {
    key: 'afterUpload',
    value: function afterUpload(success) {
      if (success) {
        this.times.accurate += this.times.bonus;
        this.times.bonus = 0;
      }
      _storage2.default.saveHistoryTimes(this.times);
    }
  }, {
    key: 'getTimes',
    value: function getTimes() {
      return this.times.accurate + this.times.bonus;
    }
  }]);

  return historyTimes;
}();

exports.default = historyTimes;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cellTailConfig = {
  duration: 100,
  height: 2.0,
  width: 0.5,
  distance: 0.5
};

var TailSystem = function () {
  function TailSystem(scene, bottle) {
    _classCallCheck(this, TailSystem);

    this.scene = scene;
    this.bottle = bottle;
    this.tailsRemainPool = [];
    this.tailsUsingPool = [];
    this.lastDotPosition = this.bottle.obj.position.clone();
    this.nowPosition = this.bottle.obj.position.clone();

    this.distance = cellTailConfig.distance;

    this.init();
  }

  _createClass(TailSystem, [{
    key: 'init',
    value: function init() {
      var width = cellTailConfig.width;
      var height = cellTailConfig.height;
      this.geometry = new THREE.PlaneGeometry(width, height);
      this.material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.3
      });
      //this.cloneMesh = new THREE.Mesh(geometry, material)
      //this.cloneMesh.visible = false
      // this.cloneMesh.visible = true

      // 创造50个尾巴单元,平面和圆柱，先选择平面
      for (var i = 0; i < 20; i++) {
        var cellTail = new CellTail(this.geometry, this.material);

        this.scene.add(cellTail.mesh);
        this.tailsRemainPool.push(cellTail);
      }
    }
  }, {
    key: 'update',
    value: function update(tickTime) {
      // console.log(tickTime)
      this.updateActiveCell(tickTime);
      if (this.bottle.status == 'prepare') {
        this.nowPosition = this.bottle.obj.position.clone();
        this.lastDotPosition = this.bottle.obj.position.clone();
      }

      if (this.bottle.status == 'jump') {
        var distance = void 0;

        // 更新位置
        this.nowPosition = this.bottle.obj.position.clone();

        distance = this.nowPosition.clone().distanceTo(this.lastDotPosition.clone());
        if (distance < 5) {
          if (distance >= this.distance) {
            // 距离过大问题
            var m = distance / this.distance;
            var n = Math.floor(m);
            var lastPosition = this.lastDotPosition.clone();
            var nowPosition = this.nowPosition.clone();
            var tickScale = tickTime / cellTailConfig.duration;
            for (var i = 1; i <= n; i++) {
              nowPosition = this.lastDotPosition.clone().lerp(this.nowPosition.clone(), i / m);
              var scale = 1 + tickScale * (i / m - 1);
              scale = scale <= 0 ? 0 : scale;
              this.layEgg(lastPosition.clone(), nowPosition.clone(), scale);
              lastPosition = nowPosition.clone();
              if (i == n) {
                this.lastDotPosition = nowPosition.clone();
              }
            }
          }
        } else {
          this.lastDotPosition = this.nowPosition.clone();
        }
      }
    }
  }, {
    key: 'updateActiveCell',
    value: function updateActiveCell(tickTime) {
      var array = this.tailsUsingPool;
      var deltaScaleY = 1 / cellTailConfig.duration;
      var delatAlpha = 1 / cellTailConfig.duration;
      for (var i = 0; i < array.length; i++) {
        // 更新时间
        array[i].tickTime += tickTime;

        // 压缩所有cell的高度
        var newScale = array[i].mesh.scale.y - deltaScaleY * tickTime;
        if (newScale > 0) {

          array[i].mesh.scale.y = newScale > 0 ? newScale : 0;

          // array[i].mesh.material.opacity = 0.3

          // 判断透明度和高度，剔除用完的
          if (array[i].tickTime >= cellTailConfig.duration) {
            array[i].reset();
            var cell = array.shift();
            this.tailsRemainPool.push(cell);
            i--;
          }
        } else {
          array[i].reset();
          var _cell = array.shift();
          this.tailsRemainPool.push(_cell);
          i--;
        }
      }
    }
  }, {
    key: 'correctPosition',
    value: function correctPosition() {
      this.lastDotPosition = this.bottle.obj.position.clone();
    }
  }, {
    key: 'layEgg',
    value: function layEgg(lastDotPosition, nowPosition) {
      var scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      // 获取一个
      var cellTail = this.getMesh();

      this.tailsUsingPool.push(cellTail);

      // 摆放位置
      cellTail.mesh.position.set(nowPosition.x, nowPosition.y, nowPosition.z);

      cellTail.mesh.scale.y = scale;

      // 修正方向
      cellTail.mesh.lookAt(lastDotPosition);

      cellTail.mesh.rotateY(Math.PI / 2);

      // 变可见
      cellTail.mesh.visible = true;
    }
  }, {
    key: 'getMesh',
    value: function getMesh() {
      var res = this.tailsRemainPool.shift();
      if (!res) {
        res = new CellTail(this.geometry, this.material);
        this.scene.add(res.mesh);
      }
      return res;
    }
  }, {
    key: 'allReset',
    value: function allReset() {
      this.tailsRemainPool.forEach(function (el) {
        el.reset();
      });
    }
  }]);

  return TailSystem;
}();

exports.default = TailSystem;

var CellTail = function () {
  function CellTail(geometry, material) {
    _classCallCheck(this, CellTail);

    this.tickTime = 0;
    this.mesh = new THREE.Mesh(geometry, material);
    this.mesh.visible = false;
    this.mesh.name = 'tail';
  }

  _createClass(CellTail, [{
    key: 'reset',
    value: function reset() {
      this.tickTime = 0;
      this.mesh.scale.set(1, 1, 1);
      this.mesh.visible = false;
    }
  }]);

  return CellTail;
}();

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

var _config = __webpack_require__(2);

var _animation = __webpack_require__(4);

var _text = __webpack_require__(8);

var _text2 = _interopRequireDefault(_text);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HEIGHT = window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth;
var WIDTH = window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth;
var ASPECT = WIDTH / HEIGHT;

var UI = function () {
	function UI(scene, camera, full2D, game) {
		_classCallCheck(this, UI);

		var that = this;
		this.game = game;
		this.full2D = full2D;
		this.scene = scene;
		this.camera = camera;
		this.score = 0;
		this.double = 1;

		// var observeGeometry = new THREE.PlaneGeometry(FRUSTUMSIZE * ASPECT * 0.034, FRUSTUMSIZE * ASPECT * 0.034 / 42 * 48);
		// var observeMaterial = new THREE.MeshBasicMaterial({
		// 	map: loader.load('res/observShare.png'),
		// 	transparent: true,
		// });

		// var observeBg = new THREE.Mesh(new THREE.PlaneGeometry(9.5, 9.5), new THREE.MeshBasicMaterial({
		// 	map: loader.load('res/share2x.png'),
		// 	transparent: true,
		// }))
		// observeBg.position.set(-1.1, -1.8, 0)

		// this.observe = new THREE.Mesh(observeGeometry, observeMaterial);
		// var res = wx.getSystemInfoSync()
		// var sys = (res.system).toLowerCase()
		// if (res.screenHeight >= 812 && sys.indexOf('ios') > -1) {
		// 	this.observe.position.set(-FRUSTUMSIZE * ASPECT * 0.38, - FRUSTUMSIZE * 0.464, -1)
		// } else {
		// 	this.observe.position.set(-FRUSTUMSIZE * ASPECT * 0.435, - FRUSTUMSIZE * 0.464, -1)
		// }
		// // this.observe.position.set(-FRUSTUMSIZE / 2 * ASPECT, -FRUSTUMSIZE / 2, -1)
		// this.observe.updateMatrix();
		// this.observe.matrixAutoUpdate = false;
		// this.observe.visible = false

		// this.observe.add(observeBg)
		// this.camera.add(this.observe);

		//this.createSky();
		this.scoreText = new _text2.default('0', { fillStyle: 0x252525, sumScore: true, opacity: 0.8 });
		this.scoreText.obj.position.set(0, 21, -10);
		//this.scoreText.obj.scale.set(1.4, 1.4, 1.4);
		this.scoreText.obj.updateMatrix();
		this.scoreText.obj.matrixAutoUpdate = false;
		this.camera.add(this.scoreText.obj);
		this.quickText = new _text2.default('好快！', { fillStyle: 0x252525, chinese: true });
		this.quickText.obj.position.set(-13, 18, -10);
		this.quickText.obj.updateMatrix();
		this.quickText.obj.matrixAutoUpdate = false;
		this.quickText.obj.visible = false;
		this.perfectText = new _text2.default('很好！', { fillStyle: 0x252525, chinese: true });
		this.perfectText.obj.position.set(-13, 16, -10);
		this.perfectText.obj.updateMatrix();
		this.perfectText.obj.matrixAutoUpdate = false;
		this.perfectText.obj.visible = false;
		this.camera.add(this.quickText.obj);
		this.camera.add(this.perfectText.obj);
	}

	_createClass(UI, [{
		key: 'reset',
		value: function reset() {
			this.scoreText.setScore(0);
			//var bonus = this.gameOverPage.getObjectByName('bonus');
			//if (bonus) this.gameOverPage.remove(bonus);
			//this.camera.remove(this.gameOverPage);
			//this.bgAudio.currentTime = 0;
			//this.bgAudio.play();
			this.score = 0;
			this.double = 1;
			this.perfectText.obj.visible = false;
			this.quickText.obj.visible = false;
		}
	}, {
		key: 'update',
		value: function update() {
			//if (!this.bgAudio.paused) this.music.rotation.z -= 0.02;

		}
	}, {
		key: 'hideScore',
		value: function hideScore() {
			this.scoreText.obj.visible = false;
		}
	}, {
		key: 'showScore',
		value: function showScore() {
			this.scoreText.obj.visible = true;
		}
	}, {
		key: 'addScore',
		value: function addScore(score, double, quick, keepDouble) {
			if (keepDouble) {
				this.score += score;
				this.setScore(this.score);
				return;
			}
			if (double) {
				if (this.double === 1) this.double = 2;else this.double += 2;
			} else {
				this.double = 1;
			}
			if (quick && this.double <= 2) {
				this.double *= 2;
			}
			this.double = Math.min(32, this.double);
			score = score * this.double;
			this.score += score;
			this.setScore(this.score);
			// var showToast = Math.random() < 0.4;
			// if (double && showToast && (this.game.mode != 'observe')) {
			// 	//this.perfectText.obj.scale.set(0, 0, 0)
			// 	//TweenMax.to(this.perfectText.obj.scale, 0.4, { x: 0.8, y: 0.8, z: 0.8  });
			// 	var text = ['太棒了！', '很好！', '稳住！'];
			// 	//this.perfectText.setText(text[Math.floor(Math.random() * 3)]);
			// 	this.perfectText.obj.visible = true;
			// 	customAnimation.to(this.perfectText.material, 0.4, { opacity: 1 });
			// 	customAnimation.to(this.perfectText.material, 0.4, { opacity: 0, delay: 0.6, onComplete: () => {
			// 		this.perfectText.obj.visible = false;
			// 	}});
			// 	if (double && !quick) {
			// 		this.perfectText.obj.position.y = 18;
			// 	} else {
			// 		this.perfectText.obj.position.y = 16;
			// 	}
			// 	this.perfectText.obj.updateMatrix();
			// }
			// if (quick && showToast && (this.game.mode != 'observe')) {
			// 	//this.quickText.obj.scale.set(0, 0, 0)
			// 	//TweenMax.to(this.quickText.obj.scale, 0.4, { x: 0.8, y: 0.8, z: 0.8 });
			// 	var text = ['好快！', '给力！'];
			// 	//this.quickText.setText(text[Math.floor(Math.random() * 2)]);
			// 	this.quickText.obj.visible = true;
			// 	customAnimation.to(this.quickText.material, 0.4, { opacity: 1 });
			// 	customAnimation.to(this.quickText.material, 0.4, { opacity: 0, delay: 0.6, onComplete: () => {
			// 		this.quickText.obj.visible = false;
			// 	}});
			// }
		}
	}, {
		key: 'setScore',
		value: function setScore(score) {
			//console.log("setScore");
			this.scoreText.setScore(score);
			_config.BLOCK.minRadiusScale -= 0.005;
			//console.log("BBB", BLOCK.minRadiusScale, BLOCK.maxRadiusScale)
			_config.BLOCK.minRadiusScale = Math.max(0.25, _config.BLOCK.minRadiusScale);
			_config.BLOCK.maxRadiusScale -= 0.005;
			_config.BLOCK.maxRadiusScale = Math.max(_config.BLOCK.maxRadiusScale, 0.6);
			_config.BLOCK.maxDistance += 0.03;
			_config.BLOCK.maxDistance = Math.min(22, _config.BLOCK.maxDistance);

			// BLOCK.minRadiusScale = +BLOCK.minRadiusScale.toFixed(2);
			// BLOCK.maxRadiusScale = +BLOCK.maxRadiusScale.toFixed(2);
			// BLOCK.maxDistance = +BLOCK.maxDistance.toFixed(2);
		}
	}]);

	return UI;
}();

exports.default = UI;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _config = __webpack_require__(2);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AudioManager = function () {
  function AudioManager(game) {
    var _this = this;

    _classCallCheck(this, AudioManager);

    this.game = game;
    this.musicPool = ['success', 'combo1', 'combo2', 'combo3', 'combo4', 'combo5', 'combo6', 'combo7', 'combo8', 'scale_intro', 'scale_loop', 'restart', 'fall', 'fall_2', 'pop', 'icon', 'sing', 'store', 'water'];
    this.musicPool.forEach(function (key) {
      _this[key] = wx.createInnerAudioContext();
      _this[key].src = _config.AUDIO[key];
    });
    this.scale_loop.loop = true;
    this.store.onPlay(function () {
      _this.store.before && _this.store.before();
    });
    this.store.onEnded(function () {
      _this.store.after && _this.store.after();
      _this.timer = setTimeout(function () {
        _this.store.seek(0);
        _this.store.play();
      }, 3000);
    });
    this.sing.onEnded(function () {
      _this.timer = setTimeout(function () {
        _this.sing.seek(0);
        _this.sing.play();
      }, 3000);
    });

    this.water.onEnded(function () {
      _this.timer = setTimeout(function () {
        _this.water.seek(0);
        _this.water.play();
      }, 3000);
    });
    // this.sing.onPlay(() => {
    //   this.sing.before && this.sing.before();
    // });
    this.scale_intro.onEnded(function () {
      if (_this.game.bottle.status == 'prepare') _this.scale_loop.play();
    });
  }

  _createClass(AudioManager, [{
    key: 'resetAudio',
    value: function resetAudio() {
      var _this2 = this;

      this.musicPool.forEach(function (key) {
        _this2[key].stop();
      });
    }
  }, {
    key: 'register',
    value: function register(key, before, after) {
      this[key].before = before;
      this[key].after = after;
    }
  }, {
    key: 'clearTimer',
    value: function clearTimer() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    }
  }, {
    key: 'replay',
    value: function replay(key) {
      var music = this[key];
      if (music) {
        music.stop();
        music.play();
      } else {
        console.warn('there is no music', key);
      }
    }
  }]);

  return AudioManager;
}();

exports.default = AudioManager;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

var _lookers = __webpack_require__(45);

var _lookers2 = _interopRequireDefault(_lookers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var viewer = function () {
  function viewer(camera) {
    _classCallCheck(this, viewer);

    this.num = 0;
    this.list = [];
    this.imgPlanes = [];
    this.camera = camera;
    this.lookers = new _lookers2.default({ camera: camera });
    this.isOpen = false;
  }

  _createClass(viewer, [{
    key: 'peopleCome',
    value: function peopleCome(data) {

      var index = this.list.findIndex(function (el) {
        if (el) {
          return el.audience_openid == data.audience_openid;
        } else {
          return false;
        }
      });

      // 如果存在就返回
      if (index > -1) {
        return;
      }

      this.list.push(data);
      this.num++;
      if (this.isOpen) {
        this.showAvatar();
      }
    }
  }, {
    key: 'peopleOut',
    value: function peopleOut(data) {
      var index = this.list.findIndex(function (el) {
        if (el) {
          return el.audience_openid == data.audience_openid;
        } else {
          return false;
        }
      });

      // 没找到就算了
      if (index < 0) {
        return;
      }

      this.num = this.num - 1 < 0 ? 0 : this.num - 1;
      this.list.splice(index, 1);

      if (this.isOpen) {
        this.showAvatar();
      }
    }
  }, {
    key: 'showAvatar',
    value: function showAvatar() {
      if (this.num > 0) {

        var avatar = [];
        for (var i = 1; i < 4; i++) {
          if (this.list.length - i >= 0) {
            avatar.unshift(this.list[this.list.length - i].audience_headimg);
          }
        }
        this.lookers.showLookers({
          avaImg: true,
          icon: true,
          wording: false,
          num: this.num,
          avatar: avatar
        });
      } else {
        this.lookers.showLookers({
          avaImg: false,
          icon: true,
          wording: false
        });
      }
    }
  }, {
    key: 'open',
    value: function open() {
      this.isOpen = true;
      this.showAvatar();
    }
  }, {
    key: 'close',
    value: function close() {
      this.isOpen = false;
      this.hideAll();
    }
  }, {
    key: 'reset',
    value: function reset() {
      this.num = 0;
      this.list = [];
      this.lookers.hideLookers();
    }
  }, {
    key: 'hideAll',
    value: function hideAll() {
      this.lookers.hideLookers();
    }
  }]);

  return viewer;
}();
// {
//   udience_cmd: 0
//   audience_headimg: "http://wx.qlogo.cn/mmhead/Q3auHgzwzM4zFTRfibLzc9yiao5pcYygKRf3BKMYLiaEc8eavxSjEnIIA/0"
//   audience_nickname: "荣钦， …"
//   audience_openid: "ofCYP0eere2xI5Nyxw5Suq5yxS_g"
//   cmd: 108
//   game_id: "2352595985513730"
// }


exports.default = viewer;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

var _config = __webpack_require__(2);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var geometry = new THREE.RingGeometry(_config.WAVE.innerRadius, _config.WAVE.outerRadius, _config.WAVE.thetaSeg);

var Wave = function () {
	function Wave() {
		_classCallCheck(this, Wave);

		var material = new THREE.MeshBasicMaterial({ color: _config.COLORS.pureWhite, transparent: true });
		this.obj = new THREE.Mesh(geometry, material);
		this.obj.rotation.x = -Math.PI / 2;
		this.obj.name = 'wave';
		//this.obj.visible = false;
	}

	_createClass(Wave, [{
		key: 'reset',
		value: function reset() {
			this.obj.scale.set(1, 1, 1);
			this.obj.material.opacity = 1;
			this.obj.visible = false;
		}
	}]);

	return Wave;
}();

exports.default = Wave;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/******/(function (modules) {
	// webpackBootstrap
	/******/ // The module cache
	/******/var installedModules = {};

	/******/ // The require function
	/******/function __webpack_require__(moduleId) {

		/******/ // Check if module is in cache
		/******/if (installedModules[moduleId])
			/******/return installedModules[moduleId].exports;

		/******/ // Create a new module (and put it into the cache)
		/******/var module = installedModules[moduleId] = {
			/******/exports: {},
			/******/id: moduleId,
			/******/loaded: false
			/******/ };

		/******/ // Execute the module function
		/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

		/******/ // Flag the module as loaded
		/******/module.loaded = true;

		/******/ // Return the exports of the module
		/******/return module.exports;
		/******/
	}

	/******/ // expose the modules object (__webpack_modules__)
	/******/__webpack_require__.m = modules;

	/******/ // expose the module cache
	/******/__webpack_require__.c = installedModules;

	/******/ // __webpack_public_path__
	/******/__webpack_require__.p = "";

	/******/ // Load entry module and return exports
	/******/return __webpack_require__(0);
	/******/
})(
/************************************************************************/
/******/[
/* 0 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	var _window2 = __webpack_require__(1);

	var _window = _interopRequireWildcard(_window2);

	function _interopRequireWildcard(obj) {
		if (obj && obj.__esModule) {
			return obj;
		} else {
			var newObj = {};if (obj != null) {
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
				}
			}newObj.default = obj;return newObj;
		}
	}

	var global = GameGlobal;

	function inject() {
		_window.addEventListener = _window.canvas.addEventListener = function (type, listener) {
			_window.document.addEventListener(type, listener);
		};
		_window.removeEventListener = _window.canvas.removeEventListener = function (type, listener) {
			_window.document.removeEventListener(type, listener);
		};

		var _wx$getSystemInfoSync = wx.getSystemInfoSync(),
		    platform = _wx$getSystemInfoSync.platform;

		// 开发者工具无法重定义 window


		if (typeof __devtoolssubcontext === 'undefined' && platform === 'devtools') {
			for (var key in _window) {
				var descriptor = Object.getOwnPropertyDescriptor(global, key);

				if (!descriptor || descriptor.configurable === true) {
					Object.defineProperty(window, key, {
						value: _window[key]
					});
				}
			}

			for (var _key in _window.document) {
				var _descriptor = Object.getOwnPropertyDescriptor(global.document, _key);

				if (!_descriptor || _descriptor.configurable === true) {
					Object.defineProperty(global.document, _key, {
						value: _window.document[_key]
					});
				}
			}
			window.parent = window;
		} else {
			for (var _key2 in _window) {
				global[_key2] = _window[_key2];
			}
			global.window = _window;
			window = global;
			window.top = window.parent = window;
		}
	}

	if (!GameGlobal.__isAdapterInjected) {
		GameGlobal.__isAdapterInjected = true;
		inject();
	}

	/***/
},
/* 1 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.cancelAnimationFrame = exports.requestAnimationFrame = exports.clearInterval = exports.clearTimeout = exports.setInterval = exports.setTimeout = exports.canvas = exports.location = exports.localStorage = exports.HTMLElement = exports.FileReader = exports.Audio = exports.Image = exports.WebSocket = exports.XMLHttpRequest = exports.navigator = exports.document = undefined;

	var _WindowProperties = __webpack_require__(2);

	Object.keys(_WindowProperties).forEach(function (key) {
		if (key === "default" || key === "__esModule") return;
		Object.defineProperty(exports, key, {
			enumerable: true,
			get: function get() {
				return _WindowProperties[key];
			}
		});
	});

	var _constructor = __webpack_require__(3);

	Object.keys(_constructor).forEach(function (key) {
		if (key === "default" || key === "__esModule") return;
		Object.defineProperty(exports, key, {
			enumerable: true,
			get: function get() {
				return _constructor[key];
			}
		});
	});

	var _Canvas = __webpack_require__(9);

	var _Canvas2 = _interopRequireDefault(_Canvas);

	var _document2 = __webpack_require__(10);

	var _document3 = _interopRequireDefault(_document2);

	var _navigator2 = __webpack_require__(17);

	var _navigator3 = _interopRequireDefault(_navigator2);

	var _XMLHttpRequest2 = __webpack_require__(18);

	var _XMLHttpRequest3 = _interopRequireDefault(_XMLHttpRequest2);

	var _WebSocket2 = __webpack_require__(19);

	var _WebSocket3 = _interopRequireDefault(_WebSocket2);

	var _Image2 = __webpack_require__(11);

	var _Image3 = _interopRequireDefault(_Image2);

	var _Audio2 = __webpack_require__(12);

	var _Audio3 = _interopRequireDefault(_Audio2);

	var _FileReader2 = __webpack_require__(20);

	var _FileReader3 = _interopRequireDefault(_FileReader2);

	var _HTMLElement2 = __webpack_require__(4);

	var _HTMLElement3 = _interopRequireDefault(_HTMLElement2);

	var _localStorage2 = __webpack_require__(21);

	var _localStorage3 = _interopRequireDefault(_localStorage2);

	var _location2 = __webpack_require__(22);

	var _location3 = _interopRequireDefault(_location2);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	exports.document = _document3.default;
	exports.navigator = _navigator3.default;
	exports.XMLHttpRequest = _XMLHttpRequest3.default;
	exports.WebSocket = _WebSocket3.default;
	exports.Image = _Image3.default;
	exports.Audio = _Audio3.default;
	exports.FileReader = _FileReader3.default;
	exports.HTMLElement = _HTMLElement3.default;
	exports.localStorage = _localStorage3.default;
	exports.location = _location3.default;

	// 暴露全局的 canvas
	var canvas = new _Canvas2.default();

	exports.canvas = canvas;
	exports.setTimeout = setTimeout;
	exports.setInterval = setInterval;
	exports.clearTimeout = clearTimeout;
	exports.clearInterval = clearInterval;
	exports.requestAnimationFrame = requestAnimationFrame;
	exports.cancelAnimationFrame = cancelAnimationFrame;

	/***/
},
/* 2 */
/***/function (module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _wx$getSystemInfoSync = wx.getSystemInfoSync(),
	    screenWidth = _wx$getSystemInfoSync.screenWidth,
	    screenHeight = _wx$getSystemInfoSync.screenHeight,
	    devicePixelRatio = _wx$getSystemInfoSync.devicePixelRatio;

	var innerWidth = exports.innerWidth = screenWidth;
	var innerHeight = exports.innerHeight = screenHeight;
	exports.devicePixelRatio = devicePixelRatio;
	var screen = exports.screen = {
		availWidth: innerWidth,
		availHeight: innerHeight
	};
	var performance = exports.performance = {
		now: function now() {
			return Date.now() / 1000;
		}
	};
	var ontouchstart = exports.ontouchstart = null;
	var ontouchmove = exports.ontouchmove = null;
	var ontouchend = exports.ontouchend = null;

	/***/
},
/* 3 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.HTMLCanvasElement = exports.HTMLImageElement = undefined;

	var _HTMLElement3 = __webpack_require__(4);

	var _HTMLElement4 = _interopRequireDefault(_HTMLElement3);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var HTMLImageElement = exports.HTMLImageElement = function (_HTMLElement) {
		_inherits(HTMLImageElement, _HTMLElement);

		function HTMLImageElement() {
			_classCallCheck(this, HTMLImageElement);

			return _possibleConstructorReturn(this, (HTMLImageElement.__proto__ || Object.getPrototypeOf(HTMLImageElement)).call(this, 'img'));
		}

		return HTMLImageElement;
	}(_HTMLElement4.default);

	var HTMLCanvasElement = exports.HTMLCanvasElement = function (_HTMLElement2) {
		_inherits(HTMLCanvasElement, _HTMLElement2);

		function HTMLCanvasElement() {
			_classCallCheck(this, HTMLCanvasElement);

			return _possibleConstructorReturn(this, (HTMLCanvasElement.__proto__ || Object.getPrototypeOf(HTMLCanvasElement)).call(this, 'canvas'));
		}

		return HTMLCanvasElement;
	}(_HTMLElement4.default);

	/***/
},
/* 4 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () {
		function defineProperties(target, props) {
			for (var i = 0; i < props.length; i++) {
				var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
			}
		}return function (Constructor, protoProps, staticProps) {
			if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
		};
	}();

	var _Element2 = __webpack_require__(5);

	var _Element3 = _interopRequireDefault(_Element2);

	var _util = __webpack_require__(8);

	var _WindowProperties = __webpack_require__(2);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var HTMLElement = function (_Element) {
		_inherits(HTMLElement, _Element);

		function HTMLElement() {
			var tagName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

			_classCallCheck(this, HTMLElement);

			var _this = _possibleConstructorReturn(this, (HTMLElement.__proto__ || Object.getPrototypeOf(HTMLElement)).call(this));

			_this.className = '';
			_this.childern = [];
			_this.style = {
				width: _WindowProperties.innerWidth + 'px',
				height: _WindowProperties.innerHeight + 'px'
			};
			_this.insertBefore = _util.noop;
			_this.innerHTML = '';

			_this.tagName = tagName.toUpperCase();
			return _this;
		}

		_createClass(HTMLElement, [{
			key: 'setAttribute',
			value: function setAttribute(name, value) {
				this[name] = value;
			}
		}, {
			key: 'getAttribute',
			value: function getAttribute(name) {
				return this[name];
			}
		}, {
			key: 'getBoundingClientRect',
			value: function getBoundingClientRect() {
				return {
					top: 0,
					left: 0,
					width: _WindowProperties.innerWidth,
					height: _WindowProperties.innerHeight
				};
			}
		}, {
			key: 'focus',
			value: function focus() {}
		}, {
			key: 'clientWidth',
			get: function get() {
				var ret = parseInt(this.style.fontSize, 10) * this.innerHTML.length;

				return Number.isNaN(ret) ? 0 : ret;
			}
		}, {
			key: 'clientHeight',
			get: function get() {
				var ret = parseInt(this.style.fontSize, 10);

				return Number.isNaN(ret) ? 0 : ret;
			}
		}]);

		return HTMLElement;
	}(_Element3.default);

	exports.default = HTMLElement;

	/***/
},
/* 5 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _Node2 = __webpack_require__(6);

	var _Node3 = _interopRequireDefault(_Node2);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var ELement = function (_Node) {
		_inherits(ELement, _Node);

		function ELement() {
			_classCallCheck(this, ELement);

			var _this = _possibleConstructorReturn(this, (ELement.__proto__ || Object.getPrototypeOf(ELement)).call(this));

			_this.className = '';
			_this.children = [];
			return _this;
		}

		return ELement;
	}(_Node3.default);

	exports.default = ELement;

	/***/
},
/* 6 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () {
		function defineProperties(target, props) {
			for (var i = 0; i < props.length; i++) {
				var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
			}
		}return function (Constructor, protoProps, staticProps) {
			if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
		};
	}();

	var _EventTarget2 = __webpack_require__(7);

	var _EventTarget3 = _interopRequireDefault(_EventTarget2);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var Node = function (_EventTarget) {
		_inherits(Node, _EventTarget);

		function Node() {
			_classCallCheck(this, Node);

			var _this = _possibleConstructorReturn(this, (Node.__proto__ || Object.getPrototypeOf(Node)).call(this));

			_this.childNodes = [];
			return _this;
		}

		_createClass(Node, [{
			key: 'appendChild',
			value: function appendChild(node) {
				if (node instanceof Node) {
					this.childNodes.push(node);
				} else {
					throw new TypeError('Failed to executed \'appendChild\' on \'Node\': parameter 1 is not of type \'Node\'.');
				}
			}
		}, {
			key: 'cloneNode',
			value: function cloneNode() {
				var copyNode = Object.create(this);

				Object.assign(copyNode, this);
				return copyNode;
			}
		}, {
			key: 'removeChild',
			value: function removeChild(node) {
				var index = this.childNodes.findIndex(function (child) {
					return child === node;
				});

				if (index > -1) {
					return this.childNodes.splice(index, 1);
				}
				return null;
			}
		}]);

		return Node;
	}(_EventTarget3.default);

	exports.default = Node;

	/***/
},
/* 7 */
/***/function (module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () {
		function defineProperties(target, props) {
			for (var i = 0; i < props.length; i++) {
				var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
			}
		}return function (Constructor, protoProps, staticProps) {
			if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
		};
	}();

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	var _events = new WeakMap();

	var EventTarget = function () {
		function EventTarget() {
			_classCallCheck(this, EventTarget);

			_events.set(this, {});
		}

		_createClass(EventTarget, [{
			key: 'addEventListener',
			value: function addEventListener(type, listener) {
				var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

				var events = _events.get(this);

				if (!events) {
					events = {};
					_events.set(this, events);
				}
				if (!events[type]) {
					events[type] = [];
				}
				events[type].push(listener);

				if (options.capture) {
					console.warn('EventTarget.addEventListener: options.capture is not implemented.');
				}
				if (options.once) {
					console.warn('EventTarget.addEventListener: options.once is not implemented.');
				}
				if (options.passive) {
					console.warn('EventTarget.addEventListener: options.passive is not implemented.');
				}
			}
		}, {
			key: 'removeEventListener',
			value: function removeEventListener(type, listener) {
				var listeners = _events.get(this)[type];

				if (listeners && listeners.length > 0) {
					for (var i = listeners.length; i--; i > 0) {
						if (listeners[i] === listener) {
							listeners.splice(i, 1);
							break;
						}
					}
				}
			}
		}, {
			key: 'dispatchEvent',
			value: function dispatchEvent() {
				var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

				var listeners = _events.get(this)[event.type];

				if (listeners) {
					for (var i = 0; i < listeners.length; i++) {
						listeners[i](event);
					}
				}
			}
		}]);

		return EventTarget;
	}();

	exports.default = EventTarget;

	/***/
},
/* 8 */
/***/function (module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.noop = noop;
	function noop() {}

	/***/
},
/* 9 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = Canvas;

	var _constructor = __webpack_require__(3);

	var _HTMLElement = __webpack_require__(4);

	var _HTMLElement2 = _interopRequireDefault(_HTMLElement);

	var _document = __webpack_require__(10);

	var _document2 = _interopRequireDefault(_document);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	var hasModifiedCanvasPrototype = false;
	var hasInit2DContextConstructor = false;
	var hasInitWebGLContextConstructor = false;

	function Canvas() {
		var canvas = wx.createCanvas();

		canvas.type = 'canvas';

		canvas.__proto__.__proto__ = new _HTMLElement2.default('canvas');

		var _getContext = canvas.getContext;

		canvas.getBoundingClientRect = function () {
			var ret = {
				top: 0,
				left: 0,
				width: window.innerWidth,
				height: window.innerHeight
			};
			return ret;
		};

		return canvas;
	}

	/***/
},
/* 10 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _window = __webpack_require__(1);

	var window = _interopRequireWildcard(_window);

	var _HTMLElement = __webpack_require__(4);

	var _HTMLElement2 = _interopRequireDefault(_HTMLElement);

	var _Image = __webpack_require__(11);

	var _Image2 = _interopRequireDefault(_Image);

	var _Audio = __webpack_require__(12);

	var _Audio2 = _interopRequireDefault(_Audio);

	var _Canvas = __webpack_require__(9);

	var _Canvas2 = _interopRequireDefault(_Canvas);

	__webpack_require__(15);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _interopRequireWildcard(obj) {
		if (obj && obj.__esModule) {
			return obj;
		} else {
			var newObj = {};if (obj != null) {
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
				}
			}newObj.default = obj;return newObj;
		}
	}

	var events = {};

	var document = {
		readyState: 'complete',
		visibilityState: 'visible',
		documentElement: window,
		hidden: false,
		style: {},
		location: window.location,
		ontouchstart: null,
		ontouchmove: null,
		ontouchend: null,

		head: new _HTMLElement2.default('head'),
		body: new _HTMLElement2.default('body'),

		createElement: function createElement(tagName) {
			if (tagName === 'canvas') {
				return new _Canvas2.default();
			} else if (tagName === 'audio') {
				return new _Audio2.default();
			} else if (tagName === 'img') {
				return new _Image2.default();
			}

			return new _HTMLElement2.default(tagName);
		},
		getElementById: function getElementById(id) {
			if (id === window.canvas.id) {
				return window.canvas;
			}
			return null;
		},
		getElementsByTagName: function getElementsByTagName(tagName) {
			if (tagName === 'head') {
				return [document.head];
			} else if (tagName === 'body') {
				return [document.body];
			} else if (tagName === 'canvas') {
				return [window.canvas];
			}
			return [];
		},
		querySelector: function querySelector(query) {
			if (query === 'head') {
				return document.head;
			} else if (query === 'body') {
				return document.body;
			} else if (query === 'canvas') {
				return window.canvas;
			} else if (query === '#' + window.canvas.id) {
				return window.canvas;
			}
			return null;
		},
		querySelectorAll: function querySelectorAll(query) {
			if (query === 'head') {
				return [document.head];
			} else if (query === 'body') {
				return [document.body];
			} else if (query === 'canvas') {
				return [window.canvas];
			}
			return [];
		},
		addEventListener: function addEventListener(type, listener) {
			if (!events[type]) {
				events[type] = [];
			}
			events[type].push(listener);
		},
		removeEventListener: function removeEventListener(type, listener) {
			var listeners = events[type];

			if (listeners && listeners.length > 0) {
				for (var i = listeners.length; i--; i > 0) {
					if (listeners[i] === listener) {
						listeners.splice(i, 1);
						break;
					}
				}
			}
		},
		dispatchEvent: function dispatchEvent(event) {
			var listeners = events[event.type];

			if (listeners) {
				for (var i = 0; i < listeners.length; i++) {
					listeners[i](event);
				}
			}
		}
	};

	exports.default = document;

	/***/
},
/* 11 */
/***/function (module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	exports.default = Image;
	function Image() {
		var image = wx.createImage();

		return image;
	}

	/***/
},
/* 12 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () {
		function defineProperties(target, props) {
			for (var i = 0; i < props.length; i++) {
				var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
			}
		}return function (Constructor, protoProps, staticProps) {
			if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
		};
	}();

	var _HTMLAudioElement2 = __webpack_require__(13);

	var _HTMLAudioElement3 = _interopRequireDefault(_HTMLAudioElement2);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var HAVE_NOTHING = 0;
	var HAVE_METADATA = 1;
	var HAVE_CURRENT_DATA = 2;
	var HAVE_FUTURE_DATA = 3;
	var HAVE_ENOUGH_DATA = 4;

	var _innerAudioContext = new WeakMap();
	var _src = new WeakMap();
	var _loop = new WeakMap();
	var _autoplay = new WeakMap();

	var Audio = function (_HTMLAudioElement) {
		_inherits(Audio, _HTMLAudioElement);

		function Audio(url) {
			_classCallCheck(this, Audio);

			var _this = _possibleConstructorReturn(this, (Audio.__proto__ || Object.getPrototypeOf(Audio)).call(this));

			_this.HAVE_NOTHING = HAVE_NOTHING;
			_this.HAVE_METADATA = HAVE_METADATA;
			_this.HAVE_CURRENT_DATA = HAVE_CURRENT_DATA;
			_this.HAVE_FUTURE_DATA = HAVE_FUTURE_DATA;
			_this.HAVE_ENOUGH_DATA = HAVE_ENOUGH_DATA;
			_this.readyState = HAVE_NOTHING;

			_src.set(_this, '');

			var innerAudioContext = wx.createInnerAudioContext();

			_innerAudioContext.set(_this, innerAudioContext);

			innerAudioContext.onCanplay(function () {
				_this.dispatchEvent({ type: 'load' });
				_this.dispatchEvent({ type: 'loadend' });
				_this.dispatchEvent({ type: 'canplay' });
				_this.dispatchEvent({ type: 'canplaythrough' });
				_this.dispatchEvent({ type: 'loadedmetadata' });
				_this.readyState = HAVE_CURRENT_DATA;
			});
			innerAudioContext.onPlay(function () {
				_this.dispatchEvent({ type: 'play' });
			});
			innerAudioContext.onPause(function () {
				_this.dispatchEvent({ type: 'pause' });
			});
			innerAudioContext.onEnded(function () {
				_this.dispatchEvent({ type: 'ended' });
				_this.readyState = HAVE_ENOUGH_DATA;
			});
			innerAudioContext.onError(function () {
				_this.dispatchEvent({ type: 'error' });
			});

			if (url) {
				_innerAudioContext.get(_this).src = url;
			}
			return _this;
		}

		_createClass(Audio, [{
			key: 'load',
			value: function load() {
				console.warn('HTMLAudioElement.load() is not implemented.');
			}
		}, {
			key: 'play',
			value: function play() {
				_innerAudioContext.get(this).play();
			}
		}, {
			key: 'pause',
			value: function pause() {
				_innerAudioContext.get(this).pause();
			}
		}, {
			key: 'canPlayType',
			value: function canPlayType() {
				var mediaType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

				if (typeof mediaType !== 'string') {
					return '';
				}

				if (mediaType.indexOf('audio/mpeg') > -1 || mediaType.indexOf('audio/mp4')) {
					return 'probably';
				}
				return '';
			}
		}, {
			key: 'cloneNode',
			value: function cloneNode() {
				var newAudio = new Audio();
				newAudio.loop = _innerAudioContext.get(this).loop;
				newAudio.autoplay = _innerAudioContext.get(this).loop;
				newAudio.src = this.src;
				return newAudio;
			}
		}, {
			key: 'currentTime',
			get: function get() {
				return _innerAudioContext.get(this).currentTime;
			},
			set: function set(value) {
				_innerAudioContext.get(this).seek(value);
			}
		}, {
			key: 'src',
			get: function get() {
				return _src.get(this);
			},
			set: function set(value) {
				_src.set(this, value);
				_innerAudioContext.get(this).src = value;
			}
		}, {
			key: 'loop',
			get: function get() {
				return _innerAudioContext.get(this).loop;
			},
			set: function set(value) {
				_innerAudioContext.get(this).loop = value;
			}
		}, {
			key: 'autoplay',
			get: function get() {
				return _innerAudioContext.get(this).autoplay;
			},
			set: function set(value) {
				_innerAudioContext.get(this).autoplay = value;
			}
		}, {
			key: 'paused',
			get: function get() {
				return _innerAudioContext.get(this).paused;
			}
		}]);

		return Audio;
	}(_HTMLAudioElement3.default);

	exports.default = Audio;

	/***/
},
/* 13 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _HTMLMediaElement2 = __webpack_require__(14);

	var _HTMLMediaElement3 = _interopRequireDefault(_HTMLMediaElement2);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var HTMLAudioElement = function (_HTMLMediaElement) {
		_inherits(HTMLAudioElement, _HTMLMediaElement);

		function HTMLAudioElement() {
			_classCallCheck(this, HTMLAudioElement);

			return _possibleConstructorReturn(this, (HTMLAudioElement.__proto__ || Object.getPrototypeOf(HTMLAudioElement)).call(this, 'audio'));
		}

		return HTMLAudioElement;
	}(_HTMLMediaElement3.default);

	exports.default = HTMLAudioElement;

	/***/
},
/* 14 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () {
		function defineProperties(target, props) {
			for (var i = 0; i < props.length; i++) {
				var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
			}
		}return function (Constructor, protoProps, staticProps) {
			if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
		};
	}();

	var _HTMLElement2 = __webpack_require__(4);

	var _HTMLElement3 = _interopRequireDefault(_HTMLElement2);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	function _possibleConstructorReturn(self, call) {
		if (!self) {
			throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
		}return call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === "object" || typeof call === "function") ? call : self;
	}

	function _inherits(subClass, superClass) {
		if (typeof superClass !== "function" && superClass !== null) {
			throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));
		}subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	}

	var HTMLMediaElement = function (_HTMLElement) {
		_inherits(HTMLMediaElement, _HTMLElement);

		function HTMLMediaElement(type) {
			_classCallCheck(this, HTMLMediaElement);

			return _possibleConstructorReturn(this, (HTMLMediaElement.__proto__ || Object.getPrototypeOf(HTMLMediaElement)).call(this, type));
		}

		_createClass(HTMLMediaElement, [{
			key: 'addTextTrack',
			value: function addTextTrack() {}
		}, {
			key: 'captureStream',
			value: function captureStream() {}
		}, {
			key: 'fastSeek',
			value: function fastSeek() {}
		}, {
			key: 'load',
			value: function load() {}
		}, {
			key: 'pause',
			value: function pause() {}
		}, {
			key: 'play',
			value: function play() {}
		}]);

		return HTMLMediaElement;
	}(_HTMLElement3.default);

	exports.default = HTMLMediaElement;

	/***/
},
/* 15 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(16);

	/***/
},
/* 16 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	var _window = __webpack_require__(1);

	var window = _interopRequireWildcard(_window);

	var _document = __webpack_require__(10);

	var _document2 = _interopRequireDefault(_document);

	var _util = __webpack_require__(8);

	function _interopRequireDefault(obj) {
		return obj && obj.__esModule ? obj : { default: obj };
	}

	function _interopRequireWildcard(obj) {
		if (obj && obj.__esModule) {
			return obj;
		} else {
			var newObj = {};if (obj != null) {
				for (var key in obj) {
					if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
				}
			}newObj.default = obj;return newObj;
		}
	}

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	var TouchEvent = function TouchEvent(type) {
		_classCallCheck(this, TouchEvent);

		this.target = window.canvas;
		this.currentTarget = window.canvas;
		this.touches = [];
		this.targetTouches = [];
		this.changedTouches = [];
		this.preventDefault = _util.noop;
		this.stopPropagation = _util.noop;

		this.type = type;
	};

	function touchEventHandlerFactory(type) {
		return function (event) {
			var touchEvent = new TouchEvent(type);

			touchEvent.touches = event.touches;
			touchEvent.targetTouches = Array.prototype.slice.call(event.touches);
			touchEvent.changedTouches = event.changedTouches;
			touchEvent.timeStamp = event.timeStamp;
			_document2.default.dispatchEvent(touchEvent);
		};
	}

	wx.onTouchStart(touchEventHandlerFactory('touchstart'));
	wx.onTouchMove(touchEventHandlerFactory('touchmove'));
	wx.onTouchEnd(touchEventHandlerFactory('touchend'));
	wx.onTouchCancel(touchEventHandlerFactory('touchcancel'));

	/***/
},
/* 17 */
/***/function (module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _util = __webpack_require__(8);

	// TODO 需要 wx.getSystemInfo 获取更详细信息
	var _wx$getSystemInfoSync = wx.getSystemInfoSync(),
	    platform = _wx$getSystemInfoSync.platform;

	var navigator = {
		platform: platform,
		language: 'zh-cn',
		appVersion: '5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1',
		userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E8301 MicroMessenger/6.6.0 MiniGame NetType/WIFI Language/zh_CN',
		onLine: true, // TODO 用 wx.getNetworkStateChange 和 wx.onNetworkStateChange 来返回真实的状态

		// TODO 用 wx.getLocation 来封装 geolocation
		geolocation: {
			getCurrentPosition: _util.noop,
			watchPosition: _util.noop,
			clearWatch: _util.noop
		}
	};

	exports.default = navigator;

	/***/
},
/* 18 */
/***/function (module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () {
		function defineProperties(target, props) {
			for (var i = 0; i < props.length; i++) {
				var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
			}
		}return function (Constructor, protoProps, staticProps) {
			if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
		};
	}();

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	var _url = new WeakMap();
	var _method = new WeakMap();
	var _requestHeader = new WeakMap();
	var _responseHeader = new WeakMap();
	var _requestTask = new WeakMap();

	function _triggerEvent(type) {
		if (typeof this['on' + type] === 'function') {
			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}

			this['on' + type].apply(this, args);
		}
	}

	function _changeReadyState(readyState) {
		this.readyState = readyState;
		_triggerEvent.call(this, 'readystatechange');
	}

	var XMLHttpRequest = function () {
		// TODO 没法模拟 HEADERS_RECEIVED 和 LOADING 两个状态
		function XMLHttpRequest() {
			_classCallCheck(this, XMLHttpRequest);

			this.onabort = null;
			this.onerror = null;
			this.onload = null;
			this.onloadstart = null;
			this.onprogress = null;
			this.ontimeout = null;
			this.onloadend = null;
			this.onreadystatechange = null;
			this.readyState = 0;
			this.response = null;
			this.responseText = null;
			this.responseType = '';
			this.responseXML = null;
			this.status = 0;
			this.statusText = '';
			this.upload = {};
			this.withCredentials = false;

			_requestHeader.set(this, {
				'content-type': 'application/x-www-form-urlencoded'
			});
			_responseHeader.set(this, {});
		}

		/*
   * TODO 这一批事件应该是在 XMLHttpRequestEventTarget.prototype 上面的
   */

		_createClass(XMLHttpRequest, [{
			key: 'abort',
			value: function abort() {
				var myRequestTask = _requestTask.get(this);

				if (myRequestTask) {
					myRequestTask.abort();
				}
			}
		}, {
			key: 'getAllResponseHeaders',
			value: function getAllResponseHeaders() {
				var responseHeader = _responseHeader.get(this);

				return Object.keys(responseHeader).map(function (header) {
					return header + ': ' + responseHeader[header];
				}).join('\n');
			}
		}, {
			key: 'getResponseHeader',
			value: function getResponseHeader(header) {
				return _responseHeader.get(this)[header];
			}
		}, {
			key: 'open',
			value: function open(method, url /* async, user, password 这几个参数在小程序内不支持*/) {
				_method.set(this, method);
				_url.set(this, url);
				_changeReadyState.call(this, XMLHttpRequest.OPENED);
			}
		}, {
			key: 'overrideMimeType',
			value: function overrideMimeType() {}
		}, {
			key: 'send',
			value: function send() {
				var _this = this;

				var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

				if (this.readyState !== XMLHttpRequest.OPENED) {
					throw new Error("Failed to execute 'send' on 'XMLHttpRequest': The object's state must be OPENED.");
				} else {
					wx.request({
						data: data,
						url: _url.get(this),
						method: _method.get(this),
						header: _requestHeader.get(this),
						responseType: this.responseType,
						success: function success(_ref) {
							var data = _ref.data,
							    statusCode = _ref.statusCode,
							    header = _ref.header;

							if (typeof data !== 'string' && !(data instanceof ArrayBuffer)) {
								try {
									data = JSON.stringify(data);
								} catch (e) {
									data = data;
								}
							}

							_this.status = statusCode;
							_responseHeader.set(_this, header);
							_triggerEvent.call(_this, 'loadstart');
							_changeReadyState.call(_this, XMLHttpRequest.HEADERS_RECEIVED);
							_changeReadyState.call(_this, XMLHttpRequest.LOADING);

							_this.response = data;

							if (data instanceof ArrayBuffer) {
								_this.responseText = '';
								var bytes = new Uint8Array(data);
								var len = bytes.byteLength;

								for (var i = 0; i < len; i++) {
									_this.responseText += String.fromCharCode(bytes[i]);
								}
							} else {
								_this.responseText = data;
							}
							_changeReadyState.call(_this, XMLHttpRequest.DONE);
							_triggerEvent.call(_this, 'load');
							_triggerEvent.call(_this, 'loadend');
						},
						fail: function fail(_ref2) {
							var errMsg = _ref2.errMsg;

							// TODO 规范错误
							if (errMsg.indexOf('abort') !== -1) {
								_triggerEvent.call(_this, 'abort');
							} else {
								_triggerEvent.call(_this, 'error', errMsg);
							}
							_triggerEvent.call(_this, 'loadend');
						}
					});
				}
			}
		}, {
			key: 'setRequestHeader',
			value: function setRequestHeader(header, value) {
				var myHeader = _requestHeader.get(this);

				myHeader[header] = value;
				_requestHeader.set(this, myHeader);
			}
		}]);

		return XMLHttpRequest;
	}();

	XMLHttpRequest.UNSEND = 0;
	XMLHttpRequest.OPENED = 1;
	XMLHttpRequest.HEADERS_RECEIVED = 2;
	XMLHttpRequest.LOADING = 3;
	XMLHttpRequest.DONE = 4;
	exports.default = XMLHttpRequest;

	/***/
},
/* 19 */
/***/function (module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _createClass = function () {
		function defineProperties(target, props) {
			for (var i = 0; i < props.length; i++) {
				var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
			}
		}return function (Constructor, protoProps, staticProps) {
			if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
		};
	}();

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	var _socketTask = new WeakMap();

	var WebSocket = function () {
		// TODO 更新 binaryType
		// The connection is in the process of closing.
		// The connection is not yet open.
		function WebSocket(url) {
			var _this = this;

			var protocols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

			_classCallCheck(this, WebSocket);

			this.binaryType = '';
			this.bufferedAmount = 0;
			this.extensions = '';
			this.onclose = null;
			this.onerror = null;
			this.onmessage = null;
			this.onopen = null;
			this.protocol = '';
			this.readyState = 3;

			if (typeof url !== 'string' || !/(^ws:\/\/)|(^wss:\/\/)/.test(url)) {
				throw new TypeError('Failed to construct \'WebSocket\': The URL \'' + url + '\' is invalid');
			}

			this.url = url;
			this.readyState = WebSocket.CONNECTING;

			var socketTask = wx.connectSocket({
				url: url,
				protocols: Array.isArray(protocols) ? protocols : [protocols]
			});

			_socketTask.set(this, socketTask);

			socketTask.onClose(function (res) {
				_this.readyState = WebSocket.CLOSED;
				if (typeof _this.onclose === 'function') {
					_this.onclose(res);
				}
			});

			socketTask.onMessage(function (res) {
				if (typeof _this.onmessage === 'function') {
					_this.onmessage(res);
				}
			});

			socketTask.onOpen(function () {
				_this.readyState = WebSocket.OPEN;
				if (typeof _this.onopen === 'function') {
					_this.onopen();
				}
			});

			socketTask.onError(function (res) {
				if (typeof _this.onerror === 'function') {
					_this.onerror(new Error(res.errMsg));
				}
			});

			return this;
		} // TODO 小程序内目前获取不到，实际上需要根据服务器选择的 sub-protocol 返回
		// TODO 更新 bufferedAmount
		// The connection is closed or couldn't be opened.

		// The connection is open and ready to communicate.


		_createClass(WebSocket, [{
			key: 'close',
			value: function close(code, reason) {
				this.readyState = WebSocket.CLOSING;
				var socketTask = _socketTask.get(this);

				socketTask.close({
					code: code,
					reason: reason
				});
			}
		}, {
			key: 'send',
			value: function send(data) {
				if (typeof data !== 'string' && !(data instanceof ArrayBuffer)) {
					throw new TypeError('Failed to send message: The data ' + data + ' is invalid');
				}

				var socketTask = _socketTask.get(this);

				socketTask.send({
					data: data
				});
			}
		}]);

		return WebSocket;
	}();

	WebSocket.CONNECTING = 0;
	WebSocket.OPEN = 1;
	WebSocket.CLOSING = 2;
	WebSocket.CLOSED = 3;
	exports.default = WebSocket;

	/***/
},
/* 20 */
/***/function (module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	function _classCallCheck(instance, Constructor) {
		if (!(instance instanceof Constructor)) {
			throw new TypeError("Cannot call a class as a function");
		}
	}

	/*
  * TODO 使用 wx.readFile 来封装 FileReader
  */
	var FileReader = function FileReader() {
		_classCallCheck(this, FileReader);
	};

	exports.default = FileReader;

	/***/
},
/* 21 */
/***/function (module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	var localStorage = {
		get length() {
			var _wx$getStorageInfoSyn = wx.getStorageInfoSync(),
			    keys = _wx$getStorageInfoSyn.keys;

			return keys.length;
		},

		key: function key(n) {
			var _wx$getStorageInfoSyn2 = wx.getStorageInfoSync(),
			    keys = _wx$getStorageInfoSyn2.keys;

			return keys[n];
		},
		getItem: function getItem(key) {
			return wx.getStorageSync(key);
		},
		setItem: function setItem(key, value) {
			return wx.setStorageSync(key, value);
		},
		removeItem: function removeItem(key) {
			wx.removeStorageSync(key);
		},
		clear: function clear() {
			wx.clearStorageSync();
		}
	};

	exports.default = localStorage;

	/***/
},
/* 22 */
/***/function (module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	var location = {
		href: 'game.js',
		reload: function reload() {}
	};

	exports.default = location;

	/***/
}]
/******/);

/***/ }),
/* 31 */
/***/ (function(module, exports) {

module.exports = function (point, vs) {
    // ray-casting algorithm based on
    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
    
    var x = point[0], y = point[1];
    
    var inside = false;
    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        var xi = vs[i][0], yi = vs[i][1];
        var xj = vs[j][0], yj = vs[j][1];
        
        var intersect = ((yi > y) != (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    
    return inside;
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _battlePkPage = __webpack_require__(43);

var _battlePkPage2 = _interopRequireDefault(_battlePkPage);

var _battleGamePage = __webpack_require__(42);

var _battleGamePage2 = _interopRequireDefault(_battleGamePage);

var _network = __webpack_require__(3);

var _network2 = _interopRequireDefault(_network);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BattleCtrl = function () {
  function BattleCtrl(game, modeCtrl) {
    _classCallCheck(this, BattleCtrl);

    this.name = 'battlePage';
    this.game = game;
    this.gameCtrl = this.game.gameCtrl;
    this.model = this.game.gameModel;
    this.view = this.game.gameView;
    this.modeCtrl = modeCtrl;
    this.netWorkCtrl = this.gameCtrl.netWorkCtrl;
    this.currentPage = null;
    this.pkPage = new _battlePkPage2.default(game);
    this.gamePage = new _battleGamePage2.default(game);

    this.shareTicket = '';
    this.pkId = '';
    this.shareInfoTimeout = null;
    this.battleScore = undefined;
  }

  _createClass(BattleCtrl, [{
    key: 'init',
    value: function init(options) {
      var sessionId = this.model.getSessionId();
      this.shareTicket = options.shareTicket;
      this.pkId = options.query.pkId;
      this.model.setStage('');
      wx.showLoading();
      if (!sessionId) {
        this.netWorkCtrl.netWorkLogin(this.afterLogin.bind(this));
      } else {
        this.afterLogin(true);
      }
    }
  }, {
    key: 'afterLogin',
    value: function afterLogin(success) {
      var _this = this;

      if (success) {
        this.setShareInfoTimeout();

        // 换取rawdata
        wx.getShareInfo({
          shareTicket: this.shareTicket,
          success: function success(res) {

            // 如果定时器还没有触发，就取消定时器
            if (_this.shareInfoTimeout != null) {
              // console.log('没有触发定时器')
              _this.clearShareInfoTimeout();
            } else {
              // console.log('已经触发定时器')
              return;
            }
            _this.model.setShareTicket(res.rawData);

            // console.log('wx.getShareInfo success group', res)
            _this.gotoBattlePage();
            _this.gameCtrl.loginBattle(1);
          },
          fail: function fail(res) {

            // 如果定时器还没有触发，就取消定时器
            if (_this.shareInfoTimeout != null) {
              _this.clearShareInfoTimeout();
              // console.log('没有触发定时器')
            } else {
              // console.log('已经触发定时器')
              return;
            }

            // 失败就是个人
            _this.gotoBattlePage();
            _this.gameCtrl.loginBattle(0);
          }
        });
      } else {
        this.goToBattleFail();
      }
    }
  }, {
    key: 'gotoBattlePage',
    value: function gotoBattlePage() {

      // 拉分数
      _network2.default.getBattleData(this.gotoBattlePageAfterHaveData.bind(this), this.pkId);
    }
  }, {
    key: 'gotoBattlePageAfterHaveData',
    value: function gotoBattlePageAfterHaveData(success, res) {
      wx.hideLoading();
      if (success) {
        var pkList = [];
        if (res.data.challenger.length) {
          res.data.challenger.forEach(function (el) {
            pkList.push({
              headimg: el.headimg,
              is_self: el.is_self ? 1 : 0,
              nickname: el.nickname,
              score_info: [{
                score: el.score
              }]
            });
          }, this);
        }

        pkList.sort(function (a, b) {
          return b.score_info[0].score - a.score_info[0].score;
        });

        var obj = {
          data: {
            organizerInfo: {
              headimg: res.data.owner.headimg,
              nickname: res.data.owner.nickname,
              score_info: [{
                score: res.data.owner.score
              }],
              // create_time: res.data.create_time,
              left_time: res.data.left_time,
              is_self: res.data.is_owner ? 1 : 0
            },
            pkListInfo: pkList,
            gg_score: this.battleScore
          }
        };

        if (this.currentPage) {
          this.currentPage.hide();
        }
        this.pkPage.show(obj);
        this.model.setStage(this.pkPage.name);
        this.currentPage = this.pkPage;

        this.gameCtrl.showPkPage(res.data.owner.score);
      } else {
        this.goToBattleFail();
      }
    }
  }, {
    key: 'goToBattleFail',
    value: function goToBattleFail() {
      this.view.showGoToBattleFail();
      this.modeCtrl.changeMode('singleCtrl');
    }
  }, {
    key: 'setShareInfoTimeout',
    value: function setShareInfoTimeout() {
      this.shareInfoTimeout = setTimeout(this.handleShareInfoTimeout.bind(this), 5000);
    }
  }, {
    key: 'clearShareInfoTimeout',
    value: function clearShareInfoTimeout() {
      if (this.shareInfoTimeout != null) {
        clearTimeout(this.shareInfoTimeout);
        this.shareInfoTimeout = null;
      }
    }
  }, {
    key: 'handleShareInfoTimeout',
    value: function handleShareInfoTimeout() {
      this.clearShareInfoTimeout();
      this.goToBattleFail();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.currentPage) {
        this.currentPage.hide();
      }
      this.model.setStage('');
      wx.hideLoading();
      this.shareTicket = '';
      this.pkId = '';
      this.clearShareInfoTimeout();
      this.model.clearShareTicket();
      this.game.resetScene();
      this.battleScore = undefined;
    }
  }, {
    key: 'battlePlay',
    value: function battlePlay(pk) {
      if (pk) {
        if (this.currentPage) {
          this.currentPage.hide();
        }
        this.gamePage.show();
        this.game.replayGame();
        this.model.setStage(this.gamePage.name);
        this.currentPage = this.gamePage;
      } else {
        this.modeCtrl.directPlaySingleGame();
        this.gameCtrl.battleToSingle();
      }
    }
  }, {
    key: 'showGameOverPage',
    value: function showGameOverPage() {
      if (this.currentPage) {
        this.currentPage.hide();
      }
      this.model.setStage('');
      this.currentPage = null;
      var score = this.model.currentScore;
      this.battleScore = score;

      // 先上传分数，然后再拉分数
      wx.showLoading();
      _network2.default.updatepkinfo(this.gotoBattlePageAgain.bind(this), this.pkId, score);
    }
  }, {
    key: 'gotoBattlePageAgain',
    value: function gotoBattlePageAgain(scoreUpLoad) {
      if (!scoreUpLoad) {
        this.view.showUploadPkScoreFail();
      }

      this.gotoBattlePage();
    }
  }, {
    key: 'wxOnhide',
    value: function wxOnhide() {
      return;
    }
  }]);

  return BattleCtrl;
}();

exports.default = BattleCtrl;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _groupPage = __webpack_require__(44);

var _groupPage2 = _interopRequireDefault(_groupPage);

var _network = __webpack_require__(3);

var _network2 = _interopRequireDefault(_network);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GroupShareCtrl = function () {
  function GroupShareCtrl(game, modeCtrl) {
    _classCallCheck(this, GroupShareCtrl);

    this.name = 'groupShare';
    this.game = game;
    this.gameCtrl = this.game.gameCtrl;
    this.model = this.game.gameModel;
    this.view = this.game.gameView;
    this.netWorkCtrl = this.gameCtrl.netWorkCtrl;
    this.modeCtrl = modeCtrl;
    this.groupPage = new _groupPage2.default(game);

    this.shareTicket = '';
    this.shareInfoTimeout = null;
  }

  _createClass(GroupShareCtrl, [{
    key: 'init',
    value: function init(options) {
      // console.log('init groupShareCtrl')
      // 服务器
      var serverConfig = this.model.getServerConfig();
      if (serverConfig) {
        if (!serverConfig.group_score_switch) {
          this.view.showServeConfigForbiddenGroupShare();
          this.modeCtrl.changeMode('singleCtrl');
          return;
        }
      }
      this.model.setStage('');
      var sessionId = this.model.getSessionId();
      this.shareTicket = options.shareTicket;
      wx.showLoading();
      if (!sessionId) {
        this.netWorkCtrl.netWorkLogin(this.afterLogin.bind(this));
      } else {
        this.afterLogin(true);
      }
    }
  }, {
    key: 'afterLogin',
    value: function afterLogin(success) {
      var _this = this;

      if (success) {
        this.setShareInfoTimeout();
        // 换取rawdata
        wx.getShareInfo({
          shareTicket: this.shareTicket,
          success: function success(res) {

            // 如果定时器还没有触发，就取消定时器
            if (_this.shareInfoTimeout != null) {
              _this.clearShareInfoTimeout();
              // console.log('没有触发定时器')
            } else {
              // console.log('已经触发定时器')
              return;
            }

            _this.model.setShareTicket(res.rawData);

            // 获取群数据
            _network2.default.getGroupScore(function (success, res) {

              // 如果成功则显示好友排行
              if (success) {
                var list = res.data.user_info || [];
                var myUserInfo = res.data.my_user_info || {};
                _this.showGroupRankPage(list, myUserInfo);
              } else {

                // 如果失败，回到单机模式
                // this.handleNetworkFucked(true, '数据异常，点击确定进入游戏')
                _this.goToGroupShareFail();
              }
              wx.hideLoading();
            });
          },
          fail: function fail(res) {

            // 如果定时器还没有触发，就取消定时器
            if (_this.shareInfoTimeout != null) {
              _this.clearShareInfoTimeout();
              // console.log('没有触发定时器')
            } else {
              // console.log('已经触发定时器')
              return;
            }

            wx.hideLoading();
            _this.goToGroupShareFail('群里的群分享才有效哦~');
            // this.handleNetworkFucked(true, '数据异常，点击确定进入游戏')
          }
        });
      } else {
        wx.hideLoading();
        this.goToGroupShareFail();
      }
    }
  }, {
    key: 'setShareInfoTimeout',
    value: function setShareInfoTimeout() {
      this.shareInfoTimeout = setTimeout(this.handleShareInfoTimeout.bind(this), 5000);
    }
  }, {
    key: 'clearShareInfoTimeout',
    value: function clearShareInfoTimeout() {
      if (this.shareInfoTimeout != null) {
        clearTimeout(this.shareInfoTimeout);
        this.shareInfoTimeout = null;
      }
    }
  }, {
    key: 'handleShareInfoTimeout',
    value: function handleShareInfoTimeout() {
      this.clearShareInfoTimeout();
      this.goToGroupShareFail();
    }
  }, {
    key: 'goToGroupShareFail',
    value: function goToGroupShareFail(wording) {
      this.view.showGroupShareFail(wording);
      this.modeCtrl.changeMode('singleCtrl');
    }
  }, {
    key: 'showGroupRankPage',
    value: function showGroupRankPage(list, myUserInfo) {
      this.groupPage.show(list, myUserInfo);
      this.model.setStage(this.groupPage.name);
      this.currentPage = this.groupPage;
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      wx.hideLoading();
      if (this.currentPage) {
        this.currentPage.hide();
      }
      this.model.setStage('');
      this.shareTicket = '';
      this.model.clearShareTicket();
      this.clearShareInfoTimeout();
      this.game.resetScene();
    }
  }, {
    key: 'groupPlayGame',
    value: function groupPlayGame() {
      this.modeCtrl.directPlaySingleGame();
    }
  }, {
    key: 'wxOnhide',
    value: function wxOnhide() {
      return;
    }
  }]);

  return GroupShareCtrl;
}();

exports.default = GroupShareCtrl;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _singleCtrl = __webpack_require__(10);

var _singleCtrl2 = _interopRequireDefault(_singleCtrl);

var _groupShareCtrl = __webpack_require__(33);

var _groupShareCtrl2 = _interopRequireDefault(_groupShareCtrl);

var _battleCtrl = __webpack_require__(32);

var _battleCtrl2 = _interopRequireDefault(_battleCtrl);

var _observeCtrl = __webpack_require__(36);

var _observeCtrl2 = _interopRequireDefault(_observeCtrl);

var _playerCtrl = __webpack_require__(37);

var _playerCtrl2 = _interopRequireDefault(_playerCtrl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ModeCtrl = function () {
  function ModeCtrl(game) {
    _classCallCheck(this, ModeCtrl);

    this.game = game;
    this.singleCtrl = new _singleCtrl2.default(game, this);
    this.groupShareCtrl = new _groupShareCtrl2.default(game, this);
    this.battleCtrl = new _battleCtrl2.default(game, this);
    this.observeCtrl = new _observeCtrl2.default(game, this);
    this.playerCtrl = new _playerCtrl2.default(game, this);

    this.model = game.gameModel;
    this.gameCtrl = game.gameCtrl;
    this.currentCtrl = null;
  }

  _createClass(ModeCtrl, [{
    key: 'initFirstPage',
    value: function initFirstPage(options) {
      var mode = this.model.getMode();
      switch (mode) {
        case 'single':
          this.currentCtrl = this.singleCtrl;
          this.singleCtrl.init(options);
          this.gameCtrl.netWorkLogin();
          break;
        case 'groupShare':
          this.currentCtrl = this.groupShareCtrl;
          this.groupShareCtrl.init(options);
          break;
        case 'battle':
          this.currentCtrl = this.battleCtrl;
          this.battleCtrl.init(options);
          break;
        case 'observe':
          this.currentCtrl = this.observeCtrl;
          this.observeCtrl.init(options);
          break;

        default:
          this.currentCtrl = this.singleCtrl;
          this.model.setMode('single');
          this.singleCtrl.init(options);
          this.gameCtrl.netWorkLogin();
          // console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!')
          // console.log('InitFirstPage 找不到对应mode')
          // console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!')
          break;
      }
    }
  }, {
    key: 'reInitFirstPage',
    value: function reInitFirstPage(options) {
      if (this.currentCtrl) {
        this.currentCtrl.destroy();
        this.currentCtrl = null;
      }
      this.gameCtrl.queryCtrl.identifyMode(options);
      this.initFirstPage(options);
    }
  }, {
    key: 'clickStart',
    value: function clickStart() {
      if (this.currentCtrl) {
        if (this.currentCtrl.clickStart) {
          this.currentCtrl.clickStart();
        }
      }
    }
  }, {
    key: 'showGameOverPage',
    value: function showGameOverPage() {
      if (this.currentCtrl) {
        if (this.currentCtrl.showGameOverPage) {
          this.currentCtrl.showGameOverPage();
        }
      }
    }
  }, {
    key: 'gameOverClickReplay',
    value: function gameOverClickReplay() {
      if (this.currentCtrl) {
        if (this.currentCtrl.gameOverClickReplay) {
          this.currentCtrl.gameOverClickReplay();
        } else {
          this.game.handleWxOnError({
            message: 'cannot Find this.currentCtrl.gameOverClickReplay',
            stack: this.game.mode + '' + this.game.stage
          });
        }
      }
    }
  }, {
    key: 'showFriendRank',
    value: function showFriendRank() {
      if (this.currentCtrl) {
        if (this.currentCtrl.showFriendRank) {
          this.currentCtrl.showFriendRank();
        }
      }
    }
  }, {
    key: 'friendRankReturn',
    value: function friendRankReturn() {
      if (this.currentCtrl) {
        if (this.currentCtrl.friendRankReturn) {
          this.currentCtrl.friendRankReturn();
        }
      }
    }
  }, {
    key: 'shareGroupRank',
    value: function shareGroupRank() {
      if (this.currentCtrl) {
        if (this.currentCtrl.shareGroupRank) {
          this.currentCtrl.shareGroupRank();
        }
      }
    }
  }, {
    key: 'clickRank',
    value: function clickRank() {
      if (this.currentCtrl) {
        if (this.currentCtrl.clickRank) {
          this.currentCtrl.clickRank();
        }
      }
    }
  }, {
    key: 'shareBattleCard',
    value: function shareBattleCard() {
      if (this.currentCtrl) {
        if (this.currentCtrl.shareBattleCard) {
          this.currentCtrl.shareBattleCard();
        }
      }
    }
  }, {
    key: 'changeMode',
    value: function changeMode(name) {
      if (this.currentCtrl) {
        if (this.currentCtrl.destroy) {
          this.currentCtrl.destroy();
        }
      }
      this.model.setMode(this[name].name);
      this.currentCtrl = this[name];
      this[name].init();
    }
  }, {
    key: 'singleChangeToPlayer',
    value: function singleChangeToPlayer() {
      // 因为是单机转主播，所以不需要hide
      this.model.setMode(this.playerCtrl.name);
      this.currentCtrl = this.playerCtrl;
      this.playerCtrl.init();
    }
  }, {
    key: 'groupPlayGame',
    value: function groupPlayGame() {
      if (this.currentCtrl) {
        if (this.currentCtrl.groupPlayGame) {
          this.currentCtrl.groupPlayGame();
        }
      }
    }
  }, {
    key: 'directPlaySingleGame',
    value: function directPlaySingleGame() {
      if (this.currentCtrl) {
        this.currentCtrl.destroy();
      }
      this.model.setMode(this.singleCtrl.name);
      this.currentCtrl = this.singleCtrl;
      this.singleCtrl.clickStart();
    }
  }, {
    key: 'battlePlay',
    value: function battlePlay(pk) {
      if (this.currentCtrl) {
        if (this.currentCtrl.battlePlay) {
          this.currentCtrl.battlePlay(pk);
        }
      }
    }
  }, {
    key: 'shareObservCard',
    value: function shareObservCard() {
      if (this.currentCtrl) {
        if (this.currentCtrl.shareObservCard) {
          this.currentCtrl.shareObservCard();
        }
      }
    }
  }, {
    key: 'socketJoinSuccess',
    value: function socketJoinSuccess(success) {
      if (this.currentCtrl) {
        if (this.currentCtrl.socketJoinSuccess) {
          this.currentCtrl.socketJoinSuccess(success);
        }
      }
    }
  }, {
    key: 'showPlayerGG',
    value: function showPlayerGG(data) {
      if (this.currentCtrl) {
        if (this.currentCtrl.showPlayerGG) {
          this.currentCtrl.showPlayerGG(data);
        }
      }
    }
  }, {
    key: 'showPlayerWaiting',
    value: function showPlayerWaiting() {
      if (this.currentCtrl) {
        if (this.currentCtrl.showPlayerWaiting) {
          this.currentCtrl.showPlayerWaiting();
        }
      }
    }
  }, {
    key: 'onPlayerOut',
    value: function onPlayerOut() {
      if (this.currentCtrl) {
        if (this.currentCtrl.onPlayerOut) {
          this.currentCtrl.onPlayerOut();
        } else {
          this.game.handleWxOnError({
            message: 'cannot Find this.currentCtrl.onPlayerOut',
            stack: this.game.mode + '' + this.game.stage
          });
        }
      }
    }
  }, {
    key: 'onViewerStart',
    value: function onViewerStart() {
      if (this.currentCtrl) {
        if (this.currentCtrl.onViewerStart) {
          this.currentCtrl.onViewerStart();
        }
      }
    }
  }, {
    key: 'wxOnhide',
    value: function wxOnhide() {
      if (this.currentCtrl) {
        if (this.currentCtrl.wxOnhide) {
          this.currentCtrl.wxOnhide();
        }
      }
    }
  }]);

  return ModeCtrl;
}();

exports.default = ModeCtrl;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _network = __webpack_require__(3);

var _network2 = _interopRequireDefault(_network);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SERVERCONFIG = 60000;

var NetworkCtrl = function () {
  function NetworkCtrl(game) {
    _classCallCheck(this, NetworkCtrl);

    this.game = game;
    this.gameCtrl = game.gameCtrl;
    this.model = game.gameModel;
    this.loginCb = null;

    // 服务器拉取配置的定时器
    this.serverConfigInterval = null;

    this.historyTimes = this.game.historyTimes;
  }

  _createClass(NetworkCtrl, [{
    key: 'netWorkLogin',
    value: function netWorkLogin(cb) {
      if (cb) {
        this.loginCb = cb;
      }
      _network2.default.requestLogin(this.afterRequestLogin.bind(this));
    }
  }, {
    key: 'afterRequestLogin',
    value: function afterRequestLogin(success) {
      if (this.loginCb) {
        this.loginCb(success);
      }

      if (success) {

        // 拉取用户头像
        _network2.default.getUserInfo();

        // 获取好友排行
        _network2.default.requestFriendsScore(this.updateFriendsScore.bind(this));

        // 拉配置,每分钟拉一次
        this.requestServerInit();

        // 抛出事件
        this.gameCtrl.onLoginSuccess();
      }
    }
  }, {
    key: 'requestServerInit',
    value: function requestServerInit() {
      _network2.default.requestInit();
      this.serverConfigInterval = setInterval(_network2.default.requestInit.bind(_network2.default), SERVERCONFIG);
    }
  }, {
    key: 'clearServerInit',
    value: function clearServerInit() {
      if (this.serverConfigInterval) {
        clearInterval(this.serverConfigInterval);
      }
    }
  }, {
    key: 'upDateFriendsScoreList',
    value: function upDateFriendsScoreList() {
      var sessionId = this.model.getSessionId();
      if (sessionId) {
        // 获取好友排行
        _network2.default.requestFriendsScore(this.updateFriendsScore2.bind(this));
      }
    }
  }, {
    key: 'updateFriendsScore',
    value: function updateFriendsScore(res, data) {
      if (res) {
        // this.friendsScore = data.user_info

        // 对好友分数进行排序
        data.user_info.sort(function (el1, el2) {
          var score1 = el1.week_best_score || 0;
          var score2 = el2.week_best_score || 0;
          return -score1 + score2;
        });

        this.model.saveFriendsScore(data.user_info);

        if (data.my_user_info) {

          var netWorkHighestScore = data.my_user_info.history_best_score || 0;
          if (netWorkHighestScore > this.model.highestScore) {
            // console.log('update highest score')
            this.model.saveHeighestScore(netWorkHighestScore);
          } else if (netWorkHighestScore < this.model.highestScore) {
            var actionData = this.model.getActionData();
            var now = Date.now();
            if (actionData) {
              if (actionData.ts > now) {
                var verifyData = actionData.data;
                this.game.historyTimes.upLoadHistoryTimes(this.model.highestScore, verifyData);
              }
            }
          }

          // 更新本周最高分
          var weekBestScore = data.my_user_info.week_best_score || 0;
          // console.log('update weekBestScore history times')
          this.model.weekBestScore = weekBestScore;
          this.model.saveWeekBestScore(weekBestScore);
          var times = data.my_user_info.times;
          this.historyTimes.verifyScore(times);
          // this.grade = data.my_user_info.grade
        }

        // 加测试数据
        // 设置假数据
        // console.log(this.friendsScore)
        // for (var i = 0; i < 1000; i++) {
        //   this.friendsScore.push({
        //     nickname: 'tunny',
        //     headimg: 'https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJFbxurAsxCCqN5GLcc8qQPboZN8dcDcsQkhmgicErTosqKfbthk6Ejyoib7h0iaZBT156Vbviczpic4QQ/0',
        //     score_info: [
        //       { type: 0, score: i }
        //     ],
        //   })
        // }
      }
    }
  }, {
    key: 'updateFriendsScore2',
    value: function updateFriendsScore2(res, data) {
      if (res) {

        // 对好友分数进行排序
        data.user_info.sort(function (el1, el2) {
          var score1 = el1.week_best_score || 0;
          var score2 = el2.week_best_score || 0;
          return -score1 + score2;
        });

        this.model.saveFriendsScore(data.user_info);
      }
    }
  }, {
    key: 'uploadScore',
    value: function uploadScore(score) {
      _network2.default.requestSettlement(score);
    }
  }]);

  return NetworkCtrl;
}();

exports.default = NetworkCtrl;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _observeWaiting = __webpack_require__(48);

var _observeWaiting2 = _interopRequireDefault(_observeWaiting);

var _observeGg = __webpack_require__(46);

var _observeGg2 = _interopRequireDefault(_observeGg);

var _observeOut = __webpack_require__(47);

var _observeOut2 = _interopRequireDefault(_observeOut);

var _network = __webpack_require__(3);

var _network2 = _interopRequireDefault(_network);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SYCTIME = 10000;
var TIMEOUT = 9000;

var ObserveCtrl = function () {
  function ObserveCtrl(game, modeCtrl) {
    _classCallCheck(this, ObserveCtrl);

    this.game = game;
    this.name = 'observe';
    this.gameCtrl = this.game.gameCtrl;
    this.model = this.game.gameModel;
    this.view = this.game.gameView;
    this.modeCtrl = modeCtrl;
    this.netWorkCtrl = this.gameCtrl.netWorkCtrl;
    this.gameSocket = this.game.gameSocket;
    this.currentPage = null;

    this.waitingPage = new _observeWaiting2.default(game);
    this.ggPage = new _observeGg2.default(game);
    this.outPage = new _observeOut2.default(game);

    this.gameId = '';
    this.longTimeout = null;
  }

  _createClass(ObserveCtrl, [{
    key: 'init',
    value: function init(options) {
      // TODO 如果服务器下发的配置禁止围观，返回单机游戏
      var serverConfig = this.model.getServerConfig();
      if (serverConfig) {
        if (!serverConfig.audience_mode_switch) {
          this.view.showServeConfigForbiddenObserveMode();
          this.modeCtrl.changeMode('singleCtrl');
          return;
        }
      }
      this.model.setStage('');
      var sessionId = this.model.getSessionId();
      this.gameId = options.query.gameId;
      this.model.setObserveInfo({
        headimg: options.query.headimg,
        nickName: options.query.nickName
      });
      this.model.setGameId(this.gameId);

      wx.showLoading();
      if (!sessionId) {
        this.netWorkCtrl.netWorkLogin(this.afterLogin.bind(this));
      } else {
        this.afterLogin(true);
      }
    }
  }, {
    key: 'afterLogin',
    value: function afterLogin(success) {
      if (success) {
        this.setLongTimeHandle();
        this.gameSocket.connectSocket();
        this.model.setStage('');
      } else {
        this.goToObserveStateFail();
      }
    }
  }, {
    key: 'socketJoinSuccess',
    value: function socketJoinSuccess(success) {

      // 清除定时器
      this.clearLongTimeHandle();
      wx.hideLoading();
      if (success) {

        // 切换页面
        this.waitingPage.show();
        this.model.setStage(this.waitingPage.name);
        this.currentPage = this.waitingPage;

        // 清UI分数
        this.game.UI.setScore(0);

        // 设置轮询，查主播状态
        this.checkPlayerTimeout = setInterval(this.checkPlayerState.bind(this), SYCTIME);
      } else {

        // 展示主播直播结束
        this.showPlayerDead();
      }
    }
  }, {
    key: 'goToObserveStateFail',
    value: function goToObserveStateFail() {

      // 提示wording
      this.view.showObserveStateFail();

      // 跳回单机主页
      this.modeCtrl.changeMode('singleCtrl');
    }
  }, {
    key: 'setLongTimeHandle',
    value: function setLongTimeHandle() {
      this.longTimeout = setTimeout(this.handleLongTime.bind(this), TIMEOUT);
    }
  }, {
    key: 'handleLongTime',
    value: function handleLongTime() {
      this.goToObserveStateFail();
    }
  }, {
    key: 'clearLongTimeHandle',
    value: function clearLongTimeHandle() {
      if (this.longTimeout != null) {
        clearTimeout(this.longTimeout);
        this.longTimeout = null;
      }
    }
  }, {
    key: 'showPlayerDead',
    value: function showPlayerDead() {
      // 关闭socket
      this.gameSocket.close();

      // 关闭定时器
      this.clearCheckPlayerTimeout();

      // 展示主播退出页面
      if (this.currentPage) {
        this.currentPage.hide();
      }
      this.outPage.show();
      this.model.setStage(this.outPage.name);
      this.currentPage = this.outPage;
    }
  }, {
    key: 'checkPlayerState',
    value: function checkPlayerState() {
      _network2.default.syncop(this.judgePlayerState.bind(this));
    }
  }, {
    key: 'judgePlayerState',
    value: function judgePlayerState(success, res) {
      if (success) {
        if (res.data.state != 0) {
          this.clearCheckPlayerTimeout();
          this.showPlayerDead();
        }
      } else {
        this.handleSyncopErr();
      }
    }
  }, {
    key: 'handleSyncopErr',
    value: function handleSyncopErr() {
      this.view.showSyncopErr();
      this.goToObserveStateFail();
    }
  }, {
    key: 'clearCheckPlayerTimeout',
    value: function clearCheckPlayerTimeout() {
      if (this.checkPlayerTimeout != null) {
        clearInterval(this.checkPlayerTimeout);
        this.checkPlayerTimeout = null;
      }
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.currentPage) {
        this.currentPage.hide();
      }
      this.currentPage = null;
      this.model.setStage('');

      // 清理gameID
      this.model.clearGameId();

      // 清理连接超时定时器
      this.clearLongTimeHandle();

      // 清理sycop定时器
      this.clearCheckPlayerTimeout();

      // 隐藏loading
      wx.hideLoading();

      if (this.gameSocket.alive) {

        // 关闭socket
        this.gameSocket.close();
      }

      // 清楚围观者的信息
      this.model.clearObserveInfo();

      this.game.instructionCtrl.destroy();

      this.game.resetScene();
    }
  }, {
    key: 'showPlayerWaiting',
    value: function showPlayerWaiting() {
      // 查看当前stage是否是playerWaiting，不是才改
      if (this.currentPage != this.waitingPage) {
        if (this.currentPage != null) {
          this.currentPage.hide();
        }
        this.waitingPage.show();
        this.model.setStage(this.waitingPage.name);
        this.currentPage = this.waitingPage;
      }
    }
  }, {
    key: 'showPlayerGG',
    value: function showPlayerGG(score) {
      if (this.currentPage != null) {
        this.currentPage.hide();
      }
      this.ggPage.show(score);
      this.model.setStage(this.ggPage.name);
      this.currentPage = this.ggPage;
    }
  }, {
    key: 'onPlayerOut',
    value: function onPlayerOut() {
      this.showPlayerDead();
    }
  }, {
    key: 'onViewerStart',
    value: function onViewerStart() {
      this.gameSocket.quitObserve();
      this.game.instructionCtrl.destroy();
      this.modeCtrl.directPlaySingleGame();
    }
  }, {
    key: 'showGameOverPage',
    value: function showGameOverPage() {
      return;
    }
  }, {
    key: 'wxOnhide',
    value: function wxOnhide() {
      this.clearCheckPlayerTimeout();
      this.gameSocket.quitObserve();
      this.gameSocket.close();
      this.game.resetScene();
    }
  }, {
    key: 'wxOnshow',
    value: function wxOnshow() {
      return;
    }
  }]);

  return ObserveCtrl;
}();

exports.default = ObserveCtrl;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _singleCtrl = __webpack_require__(10);

var _singleCtrl2 = _interopRequireDefault(_singleCtrl);

var _shareApp = __webpack_require__(7);

var _playerGamePage = __webpack_require__(49);

var _playerGamePage2 = _interopRequireDefault(_playerGamePage);

var _network = __webpack_require__(3);

var _network2 = _interopRequireDefault(_network);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var playerCtrl = function (_SingleCtrl) {
  _inherits(playerCtrl, _SingleCtrl);

  function playerCtrl(game, modeCtrl) {
    _classCallCheck(this, playerCtrl);

    var _this = _possibleConstructorReturn(this, (playerCtrl.__proto__ || Object.getPrototypeOf(playerCtrl)).call(this, game, modeCtrl));

    _this.name = 'player';
    _this.currentPage = null;
    _this.gamePage = new _playerGamePage2.default(game);
    return _this;
  }

  _createClass(playerCtrl, [{
    key: 'init',
    value: function init() {
      // this.model.setStage(this.gamePage.name)
      // this.gamePage.show()
      var stage = this.model.stage;
      switch (stage) {
        case 'game':
          this.currentPage = this.gamePage;
          this.currentPage.show();
          break;
        case 'singleSettlementPgae':
          this.currentPage = this.gameOverPage;
          break;
        default:
          this.model.setStage(this.gamePage.name);
          this.currentPage = this.gamePage;
          this.currentPage.show();
          break;
      }
    }
  }, {
    key: 'showGameOverPage',
    value: function showGameOverPage() {
      this.game.seq++;
      this.gameSocket.sendCommand(this.game.seq, {
        type: -1,
        s: this.game.currentScore
      });
      _get(playerCtrl.prototype.__proto__ || Object.getPrototypeOf(playerCtrl.prototype), 'showGameOverPage', this).call(this);
    }
  }, {
    key: 'shareObservCard',
    value: function shareObservCard() {
      this.shareObservCardA();
    }
  }, {
    key: 'shareObservCardA',
    value: function shareObservCardA() {
      this.shareObservCardB();
    }
  }, {
    key: 'shareObservCardB',
    value: function shareObservCardB() {
      var _this2 = this;

      this.model.setStage('loading');
      (0, _shareApp.shareObserve)(function (success, num) {
        if (!!success) {
          _this2.gameCtrl.afterShareObserveCard(num);
        }
        setTimeout(function () {
          // console.log('!!!!!!shareObservCardB,stage2', this.model.stage)
          if (_this2.model.stage == 'loading') {
            _this2.model.setStage('game');
          }
        }, 50);
      });
    }
  }, {
    key: 'gameOverClickReplay',
    value: function gameOverClickReplay() {
      _get(playerCtrl.prototype.__proto__ || Object.getPrototypeOf(playerCtrl.prototype), 'gameOverClickReplay', this).call(this);
      this.game.seq++;
      this.gameSocket.sendCommand(this.game.seq, {
        type: 0,
        seed: this.game.randomSeed
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.currentPage) {
        this.currentPage.hide();
      }
      this.currentPage = null;
      this.model.setStage('');
      if (this.gameSocket.alive) {
        // 关闭socket
        this.gameSocket.close();
      }

      // 清理gameId，gameTicket
      this.model.clearGameId();
      this.model.clearGameTicket();
      this.game.viewer.reset();
      // this.game.viewer.hideAll()

      this.game.resetScene();
    }
  }, {
    key: 'wxOnhide',
    value: function wxOnhide() {
      var _this3 = this;

      // 这个地方影响PK分享，群分享
      if (this.model.stage != 'loading' && this.model.stage != 'singleSettlementPgae' && this.model.stage != 'friendRankList') {

        _network2.default.quitGame();

        // 结束心跳
        this.gameSocket.cleanHeartBeat();

        this.gameSocket.close();
        setTimeout(function () {
          // this.handleNetworkFucked(true, '直播断开')
          // this.handleNetworkFucked()
          _this3.modeCtrl.changeMode('singleCtrl');
        }, 100);
      }
    }
  }, {
    key: 'wxOnshow',
    value: function wxOnshow() {}
  }]);

  return playerCtrl;
}(_singleCtrl2.default);

exports.default = playerCtrl;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var QueryCtrl = function () {
  function QueryCtrl(game) {
    _classCallCheck(this, QueryCtrl);

    this.game = game;
    this.model = this.game.gameModel;
    this.gameCtrl = this.game.gameCtrl;
  }

  _createClass(QueryCtrl, [{
    key: 'identifyMode',
    value: function identifyMode(options) {
      // if (options.scene == 1086 || options.scene == 1087) {
      //   this.model.setIsFromWn(1)
      // } else {
      //   this.model.setIsFromWn(0)
      // }

      if (!!options.query && options.query.hasOwnProperty('mode')) {
        switch (options.query.mode) {
          case 'groupShare':
            if (options.shareTicket) {
              this.model.setMode('groupShare');
            } else {
              this.gameCtrl.identifyModeErr('获取群信息失败');
              this.model.setMode('single');
            }
            break;
          case 'battle':
            if (options.query.pkId) {
              this.model.setMode('battle');
            } else {
              this.gameCtrl.identifyModeErr('获取PK信息失败');
              this.model.setMode('single');
            }
            break;
          case 'observe':
            if (options.query.gameId) {

              // gameId存session里！！！！！切记不看的时候关闭链接，清空gameId
              // Session.setGameId(options.query.gameId)
              this.model.setMode('observe');
            } else {
              this.gameCtrl.identifyModeErr('获取围观信息失败');
              this.model.setMode('single');
            }
            break;
          default:
            this.model.setMode('single');
            break;
        }
      } else {
        this.model.setMode('single');
      }
    }
  }]);

  return QueryCtrl;
}();

exports.default = QueryCtrl;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var font = { "glyphs": { "0": { "ha": 868, "x_min": 0, "x_max": 696, "o": "m 0 868 l 696 868 l 696 693 l 0 693 l 0 868 m 696 0 l 0 0 l 0 175 l 696 175 l 696 0 m 0 694 l 175 694 l 175 174 l 0 174 l 0 694 m 521 694 l 696 694 l 696 174 l 521 174 l 521 694 z " }, "1": { "ha": 521, "x_min": 0, "x_max": 347, "o": "m 174 0 l 347 0 l 347 868 l 0 868 l 0 694 l 174 694 l 174 0 z " }, "2": { "ha": 868, "x_min": 0, "x_max": 694, "o": "m 0 868 l 0 694 l 521 694 l 521 521 l 0 521 l 0 0 l 694 0 l 694 174 l 174 174 l 174 347 l 694 347 l 694 868 l 0 868 z " }, "3": { "ha": 868, "x_min": 0, "x_max": 694, "o": "m 694 0 l 694 868 l 0 868 l 0 694 l 521 694 l 521 521 l 0 521 l 0 347 l 521 347 l 521 174 l 0 174 l 0 0 l 694 0 z " }, "4": { "ha": 868, "x_min": 0, "x_max": 694, "o": "m 521 347 l 174 347 l 174 868 l 0 868 l 0 174 l 521 174 l 521 0 l 694 0 l 694 868 l 521 868 l 521 347 z " }, "5": { "ha": 868, "x_min": 0, "x_max": 694, "o": "m 694 694 l 694 868 l 0 868 l 0 347 l 521 347 l 521 174 l 0 174 l 0 0 l 694 0 l 694 521 l 174 521 l 174 694 l 694 694 z " }, "6": { "ha": 868, "x_min": 0, "x_max": 694, "o": "m 0 869 l 175 869 l 175 0 l 0 0 l 0 869 m 174 519 l 694 519 l 694 346 l 174 346 l 174 519 m 174 869 l 519 869 l 519 694 l 174 694 l 174 869 m 174 174 l 694 174 l 694 0 l 174 0 l 174 174 m 521 347 l 694 347 l 694 174 l 521 174 l 521 347 z " }, "7": { "ha": 868, "x_min": 0, "x_max": 694, "o": "m 0 868 l 0 694 l 521 694 l 521 521 l 694 521 l 694 868 l 0 868 m 347 347 l 521 347 l 521 521 l 347 521 l 347 347 m 174 0 l 347 0 l 347 347 l 174 347 l 174 0 z " }, "8": { "ha": 868, "x_min": 0, "x_max": 694, "o": "m 0 868 l 174 868 l 174 0 l 0 0 l 0 868 m 521 868 l 694 868 l 694 0 l 521 0 l 521 868 m 174 174 l 521 174 l 521 0 l 174 0 l 174 174 m 174 868 l 521 868 l 521 693 l 174 693 l 174 868 m 174 521 l 521 521 l 521 346 l 174 346 l 174 521 z " }, "9": { "ha": 868, "x_min": 0, "x_max": 696, "o": "m 0 521 l 696 521 l 696 346 l 0 346 l 0 521 m 0 868 l 694 868 l 694 694 l 0 694 l 0 868 m 0 696 l 175 696 l 175 519 l 0 519 l 0 696 m 521 696 l 694 696 l 694 521 l 521 521 l 521 696 m 521 349 l 696 349 l 696 -1 l 521 -1 l 521 349 m 174 174 l 521 174 l 521 -1 l 174 -1 l 174 174 z " }, "+": { "ha": 694, "x_min": 0, "x_max": 521, "o": "m 174 174 l 347 174 l 347 347 l 521 347 l 521 521 l 347 521 l 347 694 l 174 694 l 174 521 l 0 521 l 0 347 l 174 347 l 174 174 z " }, "了": { "ha": 1389, "x_min": 72, "x_max": 1278, "o": "m 659 954 q 1092 1246 891 1096 l 72 1246 l 72 1358 l 1278 1358 l 1278 1225 q 781 899 1035 1058 l 781 400 q 730 216 781 266 q 544 159 680 161 q 323 164 469 159 q 301 293 315 231 q 534 277 437 278 q 659 400 659 275 l 659 954 z " }, "住": { "ha": 1389, "x_min": 18, "x_max": 1364, "o": "m 423 279 l 841 279 l 841 694 l 502 694 l 502 793 l 841 793 l 841 1122 l 464 1122 l 464 1221 l 1324 1221 l 1324 1122 l 949 1122 l 949 793 l 1286 793 l 1286 694 l 949 694 l 949 279 l 1364 279 l 1364 180 l 423 180 l 423 279 m 18 788 q 346 1462 235 1084 l 457 1430 q 339 1135 401 1274 l 339 129 l 233 129 l 233 926 q 64 670 152 783 q 18 788 45 730 m 773 1407 l 860 1462 q 996 1287 935 1373 l 897 1225 q 773 1407 837 1325 z " }, "力": { "ha": 1389, "x_min": 30, "x_max": 1265, "o": "m 87 1154 l 526 1154 q 532 1458 530 1303 l 650 1458 q 643 1154 647 1314 l 1265 1154 q 1234 406 1249 625 q 985 170 1217 172 q 716 175 873 170 q 696 302 711 228 l 700 302 q 974 288 876 286 q 1119 433 1105 290 q 1143 1044 1135 677 l 640 1044 q 528 513 628 690 q 110 132 420 315 q 30 235 72 180 q 415 567 323 399 q 522 1044 510 720 l 87 1044 l 87 1154 z " }, "太": { "ha": 1389, "x_min": 19, "x_max": 1367, "o": "m 19 229 q 616 1019 548 514 l 43 1019 l 43 1123 l 624 1123 q 629 1453 629 1260 l 747 1453 q 743 1123 747 1280 l 1344 1123 l 1344 1019 l 749 1019 q 1367 262 891 467 q 1270 155 1303 199 q 694 878 831 401 q 102 129 581 411 q 19 229 75 164 m 540 408 l 625 476 q 817 267 723 372 l 720 190 q 540 408 636 297 z " }, "好": { "ha": 1389, "x_min": 24, "x_max": 1370, "o": "m 591 376 l 511 290 q 358 430 434 362 q 90 145 258 275 q 27 232 61 187 q 283 496 189 349 q 79 671 176 590 q 168 1073 127 842 l 24 1073 l 24 1173 l 184 1173 q 227 1459 206 1309 l 336 1444 q 290 1173 312 1295 l 547 1173 l 547 1086 q 414 521 515 718 q 591 376 503 449 m 545 849 l 918 849 l 918 1061 q 1165 1268 1053 1175 l 594 1268 l 594 1366 l 1314 1366 l 1314 1260 q 1025 1015 1168 1135 l 1025 849 l 1370 849 l 1370 751 l 1025 751 l 1025 316 q 850 152 1025 152 q 673 156 793 152 q 655 263 666 206 q 836 251 777 252 q 918 332 918 251 l 918 751 l 545 751 l 545 849 m 442 1073 l 271 1073 q 189 699 224 812 l 332 585 q 442 1073 423 774 z " }, "很": { "ha": 1389, "x_min": 22, "x_max": 1370, "o": "m 552 1381 l 1248 1381 l 1248 716 l 1145 716 l 1145 750 l 886 750 q 1002 526 928 627 q 1248 688 1134 605 l 1313 604 q 1058 457 1188 528 q 1370 235 1183 323 q 1287 138 1331 191 q 785 750 902 370 l 655 750 l 655 297 q 899 408 753 336 q 921 308 909 351 q 658 175 825 267 q 579 117 617 151 l 507 210 q 552 316 552 254 l 552 1381 m 22 650 q 395 1111 245 842 l 488 1058 q 343 844 419 944 l 343 123 l 239 123 l 239 715 q 69 545 157 623 q 22 650 49 600 m 1145 1289 l 655 1289 l 655 1112 l 1145 1112 l 1145 1289 m 28 1070 q 376 1458 243 1234 l 469 1404 q 79 972 312 1164 q 28 1070 54 1024 m 655 841 l 1145 841 l 1145 1021 l 655 1021 l 655 841 z " }, "快": { "ha": 1389, "x_min": 18, "x_max": 1354, "o": "m 407 779 l 768 779 q 783 1115 779 891 l 499 1115 l 499 1210 l 784 1210 q 784 1447 784 1317 l 891 1447 q 890 1210 891 1320 l 1221 1210 l 1221 779 l 1354 779 l 1354 684 l 914 684 q 1345 232 1025 374 q 1256 127 1312 199 q 840 623 948 302 q 442 117 758 317 q 363 208 397 175 q 754 684 688 399 l 407 684 l 407 779 m 209 1447 l 311 1447 l 311 1149 l 363 1184 q 515 994 452 1086 l 435 936 q 311 1108 376 1028 l 311 122 l 209 122 l 209 1447 m 1115 1115 l 888 1115 q 876 779 886 899 l 1115 779 l 1115 1115 m 77 1135 l 168 1122 q 109 776 148 959 q 18 798 71 785 q 77 1135 50 937 z " }, "棒": { "ha": 1389, "x_min": 8, "x_max": 1375, "o": "m 487 423 l 837 423 l 837 557 l 605 557 l 605 636 q 456 517 538 574 q 385 595 434 545 q 654 841 556 701 l 449 841 l 449 926 l 705 926 q 749 1039 732 981 l 528 1039 l 528 1124 l 770 1124 q 789 1236 781 1177 l 488 1236 l 488 1321 l 798 1321 q 806 1457 803 1386 l 906 1457 q 898 1321 903 1386 l 1312 1321 l 1312 1236 l 888 1236 q 871 1124 882 1176 l 1275 1124 l 1275 1039 l 852 1039 q 814 926 838 982 l 1366 926 l 1366 841 l 1085 841 q 1375 621 1191 690 q 1313 530 1341 576 q 1161 632 1229 575 l 1161 557 l 936 557 l 936 423 l 1290 423 l 1290 338 l 936 338 l 936 122 l 837 122 l 837 338 l 487 338 l 487 423 m 8 609 q 206 1101 130 807 l 24 1101 l 24 1195 l 209 1195 l 209 1459 l 304 1459 l 304 1195 l 461 1195 l 461 1101 l 304 1101 l 304 869 l 353 909 q 472 769 419 834 l 401 711 q 304 840 359 772 l 304 123 l 209 123 l 209 886 q 52 490 141 642 q 8 609 34 549 m 837 760 l 936 760 l 936 643 l 1147 643 q 989 841 1050 730 l 770 841 q 612 643 709 736 l 837 643 l 837 760 z " }, "稳": { "ha": 1389, "x_min": 7, "x_max": 1386, "o": "m 530 690 l 1183 690 l 1183 808 l 556 808 l 556 897 l 1183 897 l 1183 1013 l 559 1013 l 559 1099 l 540 1080 q 461 1146 506 1112 q 711 1469 614 1286 l 817 1449 q 749 1339 784 1393 l 1153 1339 l 1153 1252 q 1042 1104 1099 1179 l 1286 1104 l 1286 551 l 1183 551 l 1183 600 l 530 600 l 530 690 m 7 519 q 214 964 134 696 l 31 964 l 31 1058 l 222 1058 l 222 1275 q 58 1261 141 1268 q 39 1358 52 1303 q 484 1402 260 1371 l 506 1303 q 323 1284 415 1293 l 323 1058 l 492 1058 l 492 964 l 323 964 l 323 802 l 378 845 q 524 682 456 766 l 444 617 q 323 772 385 701 l 323 125 l 222 125 l 222 726 q 53 407 152 538 q 7 519 33 464 m 640 519 l 743 519 l 743 327 q 830 248 743 248 l 960 248 q 1061 316 1046 248 q 1081 442 1073 370 q 1184 401 1126 422 q 1154 274 1171 332 q 990 156 1124 156 l 810 156 q 640 321 640 156 l 640 519 m 1031 1251 l 689 1251 q 564 1104 629 1172 l 925 1104 q 1031 1251 982 1181 m 494 519 l 585 487 q 477 217 538 345 q 385 259 434 240 q 494 519 449 374 m 1177 477 l 1264 517 q 1386 274 1340 372 l 1293 229 q 1177 477 1248 339 m 795 544 l 868 594 q 1009 419 948 502 l 926 361 q 795 544 867 456 z " }, "给": { "ha": 1389, "x_min": 18, "x_max": 1378, "o": "m 551 693 l 1237 693 l 1237 121 l 1134 121 l 1134 212 l 654 212 l 654 119 l 551 119 l 551 693 m 184 646 q 467 667 191 646 q 454 581 460 625 q 68 543 228 560 l 46 628 q 252 914 127 705 q 46 899 165 909 l 18 983 q 273 1450 134 1116 l 380 1412 q 136 991 247 1157 q 297 994 217 993 q 399 1180 346 1078 l 499 1137 q 184 646 311 823 m 1134 601 l 654 601 l 654 304 l 1134 304 l 1134 601 m 971 1450 l 943 1404 q 1378 975 1101 1145 q 1299 888 1339 936 q 886 1313 1034 1077 q 502 871 738 1063 q 423 945 476 901 q 850 1450 697 1154 l 971 1450 m 597 947 l 1191 947 l 1191 854 l 597 854 l 597 947 m 23 331 q 476 425 275 378 q 477 330 475 376 q 58 232 201 273 l 23 331 z " }, "超": { "ha": 1389, "x_min": 23, "x_max": 1370, "o": "m 23 248 q 134 791 126 427 l 235 785 q 214 541 231 654 q 343 370 263 435 l 343 873 l 30 873 l 30 971 l 301 971 l 301 1166 l 77 1166 l 77 1264 l 301 1264 l 301 1457 l 407 1457 l 407 1264 l 609 1264 l 609 1166 l 407 1166 l 407 971 l 627 971 l 627 873 l 445 873 l 445 662 l 639 662 l 639 566 l 445 566 l 445 311 q 671 269 543 270 q 1370 274 929 264 q 1332 170 1345 214 q 637 172 922 167 q 193 408 309 180 q 83 121 153 232 q 23 248 56 184 m 711 836 l 1278 836 l 1278 351 l 1177 351 l 1177 410 l 811 410 l 811 343 l 711 343 l 711 836 m 644 1308 l 644 1398 l 1293 1398 q 1274 1086 1286 1214 q 1112 928 1259 932 q 943 932 1039 926 q 922 1039 935 981 q 1092 1024 1023 1023 q 1177 1111 1169 1024 q 1191 1308 1187 1190 l 933 1308 q 705 879 922 1001 q 640 964 680 921 q 831 1308 827 1067 l 644 1308 m 1177 745 l 811 745 l 811 500 l 1177 500 l 1177 745 z " }, "越": { "ha": 1389, "x_min": 26, "x_max": 1370, "o": "m 26 233 q 134 791 130 422 l 228 785 q 213 538 227 652 q 339 373 262 435 l 339 873 l 30 873 l 30 966 l 298 966 l 298 1166 l 77 1166 l 77 1259 l 298 1259 l 298 1455 l 393 1455 l 393 1259 l 602 1259 l 602 1166 l 393 1166 l 393 966 l 624 966 l 624 873 l 434 873 l 434 658 l 608 658 l 608 566 l 434 566 l 434 315 q 666 269 534 270 q 1370 274 981 264 q 1332 168 1345 214 q 637 172 947 168 q 191 406 316 178 q 83 121 155 232 q 26 233 56 184 m 770 395 q 987 644 895 511 q 917 1112 933 829 l 758 1112 l 758 650 q 897 773 819 703 q 917 674 905 720 q 755 529 837 606 q 692 457 726 500 l 624 525 q 666 658 666 579 l 666 1200 l 913 1200 q 909 1459 909 1328 l 1001 1459 q 1005 1200 1000 1336 l 1340 1200 l 1340 1112 l 1009 1112 q 1058 750 1020 902 q 1180 1017 1133 878 l 1271 979 q 1093 632 1196 792 q 1154 507 1120 560 q 1202 467 1179 467 q 1230 517 1222 467 q 1253 726 1242 604 q 1347 692 1316 703 q 1318 471 1332 544 q 1215 355 1298 355 q 1088 431 1142 355 q 1027 538 1054 476 q 844 331 944 426 q 770 395 818 362 m 1074 1404 l 1145 1455 q 1278 1298 1203 1392 l 1199 1242 q 1074 1404 1130 1340 z " }, "！": { "ha": 1389, "x_min": 608, "x_max": 781, "o": "m 761 1321 l 746 570 l 639 570 l 624 1321 l 761 1321 m 694 426 q 755 401 730 426 q 781 340 781 376 q 755 279 781 304 q 694 255 730 255 q 633 279 659 255 q 608 340 608 304 q 633 401 608 376 q 694 426 659 426 z " } }, "familyName": "Microsoft YaHei", "ascender": 1636, "descender": -296, "underlinePosition": -119, "underlineThickness": 80, "boundingBox": { "yMin": -186, "xMin": -220, "yMax": 1706, "xMax": 1763 }, "resolution": 1000, "original_font_information": { "format": 0, "copyright": "`2005 Microsoft Corporation. All rights reserved.", "fontFamily": "Microsoft YaHei", "fontSubfamily": "Regular", "uniqueID": "Microsoft YaHei-Regular", "fullName": "Microsoft YaHei", "version": "Version 0.71", "postScriptName": "MicrosoftYaHei", "trademark": "Microsoft YaHei is either a registered trademark or a trademark of Microsoft Corporation in the United States and/or other countries.", "manufacturer": "Microsoft Corporation", "designer": "Founder", "description": "Microsoft YaHei is a Simplified Chinese font developed by taking advantage of ClearType technology, and it provides excellent reading experience particularly onscreen. The font is very legible at small sizes.", "manufacturerURL": "http://www.microsoft.com/typography", "designerURL": "http://www.founder.com.cn/cn", "licence": "\r\nNOTIFICATION OF LICENSE AGREEMENT \r\n\r\nThis font software is part of the Microsoft software product in which it was included and is provided under the end user license agreement (“EULA”) for that Microsoft software product. The terms and conditions of the EULA govern the use of font software. Please refer to the applicable Microsoft product EULA if you have any questions about how you may use this font software. Microsoft reserves all rights that are not expressly granted in the EULA. For products that may have installed this font please see the license link.\r\n", "licenceURL": "http://www.microsoft.com/typography/fonts" }, "cssFontWeight": "normal", "cssFontStyle": "normal" };
var loader = new THREE.FontLoader();
var FONT;
loader.load(JSON.stringify(font), function (font) {
	FONT = font;
});
exports.default = FONT;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS = CryptoJS || function (u, p) {
  var d = {},
      l = d.lib = {},
      s = function s() {},
      t = l.Base = { extend: function extend(a) {
      s.prototype = this;var c = new s();a && c.mixIn(a);c.hasOwnProperty("init") || (c.init = function () {
        c.$super.init.apply(this, arguments);
      });c.init.prototype = c;c.$super = this;return c;
    }, create: function create() {
      var a = this.extend();a.init.apply(a, arguments);return a;
    }, init: function init() {}, mixIn: function mixIn(a) {
      for (var c in a) {
        a.hasOwnProperty(c) && (this[c] = a[c]);
      }a.hasOwnProperty("toString") && (this.toString = a.toString);
    }, clone: function clone() {
      return this.init.prototype.extend(this);
    } },
      r = l.WordArray = t.extend({ init: function init(a, c) {
      a = this.words = a || [];this.sigBytes = c != p ? c : 4 * a.length;
    }, toString: function toString(a) {
      return (a || v).stringify(this);
    }, concat: function concat(a) {
      var c = this.words,
          e = a.words,
          j = this.sigBytes;a = a.sigBytes;this.clamp();if (j % 4) for (var k = 0; k < a; k++) {
        c[j + k >>> 2] |= (e[k >>> 2] >>> 24 - 8 * (k % 4) & 255) << 24 - 8 * ((j + k) % 4);
      } else if (65535 < e.length) for (k = 0; k < a; k += 4) {
        c[j + k >>> 2] = e[k >>> 2];
      } else c.push.apply(c, e);this.sigBytes += a;return this;
    }, clamp: function clamp() {
      var a = this.words,
          c = this.sigBytes;a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);a.length = u.ceil(c / 4);
    }, clone: function clone() {
      var a = t.clone.call(this);a.words = this.words.slice(0);return a;
    }, random: function random(a) {
      for (var c = [], e = 0; e < a; e += 4) {
        c.push(4294967296 * u.random() | 0);
      }return new r.init(c, a);
    } }),
      w = d.enc = {},
      v = w.Hex = { stringify: function stringify(a) {
      var c = a.words;a = a.sigBytes;for (var e = [], j = 0; j < a; j++) {
        var k = c[j >>> 2] >>> 24 - 8 * (j % 4) & 255;e.push((k >>> 4).toString(16));e.push((k & 15).toString(16));
      }return e.join("");
    }, parse: function parse(a) {
      for (var c = a.length, e = [], j = 0; j < c; j += 2) {
        e[j >>> 3] |= parseInt(a.substr(j, 2), 16) << 24 - 4 * (j % 8);
      }return new r.init(e, c / 2);
    } },
      b = w.Latin1 = { stringify: function stringify(a) {
      var c = a.words;a = a.sigBytes;for (var e = [], j = 0; j < a; j++) {
        e.push(String.fromCharCode(c[j >>> 2] >>> 24 - 8 * (j % 4) & 255));
      }return e.join("");
    }, parse: function parse(a) {
      for (var c = a.length, e = [], j = 0; j < c; j++) {
        e[j >>> 2] |= (a.charCodeAt(j) & 255) << 24 - 8 * (j % 4);
      }return new r.init(e, c);
    } },
      x = w.Utf8 = { stringify: function stringify(a) {
      try {
        return decodeURIComponent(escape(b.stringify(a)));
      } catch (c) {
        throw Error("Malformed UTF-8 data");
      }
    }, parse: function parse(a) {
      return b.parse(unescape(encodeURIComponent(a)));
    } },
      q = l.BufferedBlockAlgorithm = t.extend({ reset: function reset() {
      this._data = new r.init();this._nDataBytes = 0;
    }, _append: function _append(a) {
      "string" == typeof a && (a = x.parse(a));this._data.concat(a);this._nDataBytes += a.sigBytes;
    }, _process: function _process(a) {
      var c = this._data,
          e = c.words,
          j = c.sigBytes,
          k = this.blockSize,
          b = j / (4 * k),
          b = a ? u.ceil(b) : u.max((b | 0) - this._minBufferSize, 0);a = b * k;j = u.min(4 * a, j);if (a) {
        for (var q = 0; q < a; q += k) {
          this._doProcessBlock(e, q);
        }q = e.splice(0, a);c.sigBytes -= j;
      }return new r.init(q, j);
    }, clone: function clone() {
      var a = t.clone.call(this);
      a._data = this._data.clone();return a;
    }, _minBufferSize: 0 });l.Hasher = q.extend({ cfg: t.extend(), init: function init(a) {
      this.cfg = this.cfg.extend(a);this.reset();
    }, reset: function reset() {
      q.reset.call(this);this._doReset();
    }, update: function update(a) {
      this._append(a);this._process();return this;
    }, finalize: function finalize(a) {
      a && this._append(a);return this._doFinalize();
    }, blockSize: 16, _createHelper: function _createHelper(a) {
      return function (b, e) {
        return new a.init(e).finalize(b);
      };
    }, _createHmacHelper: function _createHmacHelper(a) {
      return function (b, e) {
        return new n.HMAC.init(a, e).finalize(b);
      };
    } });var n = d.algo = {};return d;
}(Math);
(function () {
  var u = CryptoJS,
      p = u.lib.WordArray;u.enc.Base64 = { stringify: function stringify(d) {
      var l = d.words,
          p = d.sigBytes,
          t = this._map;d.clamp();d = [];for (var r = 0; r < p; r += 3) {
        for (var w = (l[r >>> 2] >>> 24 - 8 * (r % 4) & 255) << 16 | (l[r + 1 >>> 2] >>> 24 - 8 * ((r + 1) % 4) & 255) << 8 | l[r + 2 >>> 2] >>> 24 - 8 * ((r + 2) % 4) & 255, v = 0; 4 > v && r + 0.75 * v < p; v++) {
          d.push(t.charAt(w >>> 6 * (3 - v) & 63));
        }
      }if (l = t.charAt(64)) for (; d.length % 4;) {
        d.push(l);
      }return d.join("");
    }, parse: function parse(d) {
      var l = d.length,
          s = this._map,
          t = s.charAt(64);t && (t = d.indexOf(t), -1 != t && (l = t));for (var t = [], r = 0, w = 0; w < l; w++) {
        if (w % 4) {
          var v = s.indexOf(d.charAt(w - 1)) << 2 * (w % 4),
              b = s.indexOf(d.charAt(w)) >>> 6 - 2 * (w % 4);t[r >>> 2] |= (v | b) << 24 - 8 * (r % 4);r++;
        }
      }return p.create(t, r);
    }, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" };
})();
(function (u) {
  function p(b, n, a, c, e, j, k) {
    b = b + (n & a | ~n & c) + e + k;return (b << j | b >>> 32 - j) + n;
  }function d(b, n, a, c, e, j, k) {
    b = b + (n & c | a & ~c) + e + k;return (b << j | b >>> 32 - j) + n;
  }function l(b, n, a, c, e, j, k) {
    b = b + (n ^ a ^ c) + e + k;return (b << j | b >>> 32 - j) + n;
  }function s(b, n, a, c, e, j, k) {
    b = b + (a ^ (n | ~c)) + e + k;return (b << j | b >>> 32 - j) + n;
  }for (var t = CryptoJS, r = t.lib, w = r.WordArray, v = r.Hasher, r = t.algo, b = [], x = 0; 64 > x; x++) {
    b[x] = 4294967296 * u.abs(u.sin(x + 1)) | 0;
  }r = r.MD5 = v.extend({ _doReset: function _doReset() {
      this._hash = new w.init([1732584193, 4023233417, 2562383102, 271733878]);
    },
    _doProcessBlock: function _doProcessBlock(q, n) {
      for (var a = 0; 16 > a; a++) {
        var c = n + a,
            e = q[c];q[c] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360;
      }var a = this._hash.words,
          c = q[n + 0],
          e = q[n + 1],
          j = q[n + 2],
          k = q[n + 3],
          z = q[n + 4],
          r = q[n + 5],
          t = q[n + 6],
          w = q[n + 7],
          v = q[n + 8],
          A = q[n + 9],
          B = q[n + 10],
          C = q[n + 11],
          u = q[n + 12],
          D = q[n + 13],
          E = q[n + 14],
          x = q[n + 15],
          f = a[0],
          m = a[1],
          g = a[2],
          h = a[3],
          f = p(f, m, g, h, c, 7, b[0]),
          h = p(h, f, m, g, e, 12, b[1]),
          g = p(g, h, f, m, j, 17, b[2]),
          m = p(m, g, h, f, k, 22, b[3]),
          f = p(f, m, g, h, z, 7, b[4]),
          h = p(h, f, m, g, r, 12, b[5]),
          g = p(g, h, f, m, t, 17, b[6]),
          m = p(m, g, h, f, w, 22, b[7]),
          f = p(f, m, g, h, v, 7, b[8]),
          h = p(h, f, m, g, A, 12, b[9]),
          g = p(g, h, f, m, B, 17, b[10]),
          m = p(m, g, h, f, C, 22, b[11]),
          f = p(f, m, g, h, u, 7, b[12]),
          h = p(h, f, m, g, D, 12, b[13]),
          g = p(g, h, f, m, E, 17, b[14]),
          m = p(m, g, h, f, x, 22, b[15]),
          f = d(f, m, g, h, e, 5, b[16]),
          h = d(h, f, m, g, t, 9, b[17]),
          g = d(g, h, f, m, C, 14, b[18]),
          m = d(m, g, h, f, c, 20, b[19]),
          f = d(f, m, g, h, r, 5, b[20]),
          h = d(h, f, m, g, B, 9, b[21]),
          g = d(g, h, f, m, x, 14, b[22]),
          m = d(m, g, h, f, z, 20, b[23]),
          f = d(f, m, g, h, A, 5, b[24]),
          h = d(h, f, m, g, E, 9, b[25]),
          g = d(g, h, f, m, k, 14, b[26]),
          m = d(m, g, h, f, v, 20, b[27]),
          f = d(f, m, g, h, D, 5, b[28]),
          h = d(h, f, m, g, j, 9, b[29]),
          g = d(g, h, f, m, w, 14, b[30]),
          m = d(m, g, h, f, u, 20, b[31]),
          f = l(f, m, g, h, r, 4, b[32]),
          h = l(h, f, m, g, v, 11, b[33]),
          g = l(g, h, f, m, C, 16, b[34]),
          m = l(m, g, h, f, E, 23, b[35]),
          f = l(f, m, g, h, e, 4, b[36]),
          h = l(h, f, m, g, z, 11, b[37]),
          g = l(g, h, f, m, w, 16, b[38]),
          m = l(m, g, h, f, B, 23, b[39]),
          f = l(f, m, g, h, D, 4, b[40]),
          h = l(h, f, m, g, c, 11, b[41]),
          g = l(g, h, f, m, k, 16, b[42]),
          m = l(m, g, h, f, t, 23, b[43]),
          f = l(f, m, g, h, A, 4, b[44]),
          h = l(h, f, m, g, u, 11, b[45]),
          g = l(g, h, f, m, x, 16, b[46]),
          m = l(m, g, h, f, j, 23, b[47]),
          f = s(f, m, g, h, c, 6, b[48]),
          h = s(h, f, m, g, w, 10, b[49]),
          g = s(g, h, f, m, E, 15, b[50]),
          m = s(m, g, h, f, r, 21, b[51]),
          f = s(f, m, g, h, u, 6, b[52]),
          h = s(h, f, m, g, k, 10, b[53]),
          g = s(g, h, f, m, B, 15, b[54]),
          m = s(m, g, h, f, e, 21, b[55]),
          f = s(f, m, g, h, v, 6, b[56]),
          h = s(h, f, m, g, x, 10, b[57]),
          g = s(g, h, f, m, t, 15, b[58]),
          m = s(m, g, h, f, D, 21, b[59]),
          f = s(f, m, g, h, z, 6, b[60]),
          h = s(h, f, m, g, C, 10, b[61]),
          g = s(g, h, f, m, j, 15, b[62]),
          m = s(m, g, h, f, A, 21, b[63]);a[0] = a[0] + f | 0;a[1] = a[1] + m | 0;a[2] = a[2] + g | 0;a[3] = a[3] + h | 0;
    }, _doFinalize: function _doFinalize() {
      var b = this._data,
          n = b.words,
          a = 8 * this._nDataBytes,
          c = 8 * b.sigBytes;n[c >>> 5] |= 128 << 24 - c % 32;var e = u.floor(a / 4294967296);n[(c + 64 >>> 9 << 4) + 15] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360;n[(c + 64 >>> 9 << 4) + 14] = (a << 8 | a >>> 24) & 16711935 | (a << 24 | a >>> 8) & 4278255360;b.sigBytes = 4 * (n.length + 1);this._process();b = this._hash;n = b.words;for (a = 0; 4 > a; a++) {
        c = n[a], n[a] = (c << 8 | c >>> 24) & 16711935 | (c << 24 | c >>> 8) & 4278255360;
      }return b;
    }, clone: function clone() {
      var b = v.clone.call(this);b._hash = this._hash.clone();return b;
    } });t.MD5 = v._createHelper(r);t.HmacMD5 = v._createHmacHelper(r);
})(Math);
(function () {
  var u = CryptoJS,
      p = u.lib,
      d = p.Base,
      l = p.WordArray,
      p = u.algo,
      s = p.EvpKDF = d.extend({ cfg: d.extend({ keySize: 4, hasher: p.MD5, iterations: 1 }), init: function init(d) {
      this.cfg = this.cfg.extend(d);
    }, compute: function compute(d, r) {
      for (var p = this.cfg, s = p.hasher.create(), b = l.create(), u = b.words, q = p.keySize, p = p.iterations; u.length < q;) {
        n && s.update(n);var n = s.update(d).finalize(r);s.reset();for (var a = 1; a < p; a++) {
          n = s.finalize(n), s.reset();
        }b.concat(n);
      }b.sigBytes = 4 * q;return b;
    } });u.EvpKDF = function (d, l, p) {
    return s.create(p).compute(d, l);
  };
})();
CryptoJS.lib.Cipher || function (u) {
  var p = CryptoJS,
      d = p.lib,
      l = d.Base,
      s = d.WordArray,
      t = d.BufferedBlockAlgorithm,
      r = p.enc.Base64,
      w = p.algo.EvpKDF,
      v = d.Cipher = t.extend({ cfg: l.extend(), createEncryptor: function createEncryptor(e, a) {
      return this.create(this._ENC_XFORM_MODE, e, a);
    }, createDecryptor: function createDecryptor(e, a) {
      return this.create(this._DEC_XFORM_MODE, e, a);
    }, init: function init(e, a, b) {
      this.cfg = this.cfg.extend(b);this._xformMode = e;this._key = a;this.reset();
    }, reset: function reset() {
      t.reset.call(this);this._doReset();
    }, process: function process(e) {
      this._append(e);return this._process();
    },
    finalize: function finalize(e) {
      e && this._append(e);return this._doFinalize();
    }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function _createHelper(e) {
      return { encrypt: function encrypt(b, k, d) {
          return ("string" == typeof k ? c : a).encrypt(e, b, k, d);
        }, decrypt: function decrypt(b, k, d) {
          return ("string" == typeof k ? c : a).decrypt(e, b, k, d);
        } };
    } });d.StreamCipher = v.extend({ _doFinalize: function _doFinalize() {
      return this._process(!0);
    }, blockSize: 1 });var b = p.mode = {},
      x = function x(e, a, b) {
    var c = this._iv;c ? this._iv = u : c = this._prevBlock;for (var d = 0; d < b; d++) {
      e[a + d] ^= c[d];
    }
  },
      q = (d.BlockCipherMode = l.extend({ createEncryptor: function createEncryptor(e, a) {
      return this.Encryptor.create(e, a);
    }, createDecryptor: function createDecryptor(e, a) {
      return this.Decryptor.create(e, a);
    }, init: function init(e, a) {
      this._cipher = e;this._iv = a;
    } })).extend();q.Encryptor = q.extend({ processBlock: function processBlock(e, a) {
      var b = this._cipher,
          c = b.blockSize;x.call(this, e, a, c);b.encryptBlock(e, a);this._prevBlock = e.slice(a, a + c);
    } });q.Decryptor = q.extend({ processBlock: function processBlock(e, a) {
      var b = this._cipher,
          c = b.blockSize,
          d = e.slice(a, a + c);b.decryptBlock(e, a);x.call(this, e, a, c);this._prevBlock = d;
    } });b = b.CBC = q;q = (p.pad = {}).Pkcs7 = { pad: function pad(a, b) {
      for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, l = [], n = 0; n < c; n += 4) {
        l.push(d);
      }c = s.create(l, c);a.concat(c);
    }, unpad: function unpad(a) {
      a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255;
    } };d.BlockCipher = v.extend({ cfg: v.cfg.extend({ mode: b, padding: q }), reset: function reset() {
      v.reset.call(this);var a = this.cfg,
          b = a.iv,
          a = a.mode;if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor;else c = a.createDecryptor, this._minBufferSize = 1;this._mode = c.call(a, this, b && b.words);
    }, _doProcessBlock: function _doProcessBlock(a, b) {
      this._mode.processBlock(a, b);
    }, _doFinalize: function _doFinalize() {
      var a = this.cfg.padding;if (this._xformMode == this._ENC_XFORM_MODE) {
        a.pad(this._data, this.blockSize);var b = this._process(!0);
      } else b = this._process(!0), a.unpad(b);return b;
    }, blockSize: 4 });var n = d.CipherParams = l.extend({ init: function init(a) {
      this.mixIn(a);
    }, toString: function toString(a) {
      return (a || this.formatter).stringify(this);
    } }),
      b = (p.format = {}).OpenSSL = { stringify: function stringify(a) {
      var b = a.ciphertext;a = a.salt;return (a ? s.create([1398893684, 1701076831]).concat(a).concat(b) : b).toString(r);
    }, parse: function parse(a) {
      a = r.parse(a);var b = a.words;if (1398893684 == b[0] && 1701076831 == b[1]) {
        var c = s.create(b.slice(2, 4));b.splice(0, 4);a.sigBytes -= 16;
      }return n.create({ ciphertext: a, salt: c });
    } },
      a = d.SerializableCipher = l.extend({ cfg: l.extend({ format: b }), encrypt: function encrypt(a, b, c, d) {
      d = this.cfg.extend(d);var l = a.createEncryptor(c, d);b = l.finalize(b);l = l.cfg;return n.create({ ciphertext: b, key: c, iv: l.iv, algorithm: a, mode: l.mode, padding: l.padding, blockSize: a.blockSize, formatter: d.format });
    },
    decrypt: function decrypt(a, b, c, d) {
      d = this.cfg.extend(d);b = this._parse(b, d.format);return a.createDecryptor(c, d).finalize(b.ciphertext);
    }, _parse: function _parse(a, b) {
      return "string" == typeof a ? b.parse(a, this) : a;
    } }),
      p = (p.kdf = {}).OpenSSL = { execute: function execute(a, b, c, d) {
      d || (d = s.random(8));a = w.create({ keySize: b + c }).compute(a, d);c = s.create(a.words.slice(b), 4 * c);a.sigBytes = 4 * b;return n.create({ key: a, iv: c, salt: d });
    } },
      c = d.PasswordBasedCipher = a.extend({ cfg: a.cfg.extend({ kdf: p }), encrypt: function encrypt(b, c, d, l) {
      l = this.cfg.extend(l);d = l.kdf.execute(d, b.keySize, b.ivSize);l.iv = d.iv;b = a.encrypt.call(this, b, c, d.key, l);b.mixIn(d);return b;
    }, decrypt: function decrypt(b, c, d, l) {
      l = this.cfg.extend(l);c = this._parse(c, l.format);d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt);l.iv = d.iv;return a.decrypt.call(this, b, c, d.key, l);
    } });
}();
(function () {
  for (var u = CryptoJS, p = u.lib.BlockCipher, d = u.algo, l = [], s = [], t = [], r = [], w = [], v = [], b = [], x = [], q = [], n = [], a = [], c = 0; 256 > c; c++) {
    a[c] = 128 > c ? c << 1 : c << 1 ^ 283;
  }for (var e = 0, j = 0, c = 0; 256 > c; c++) {
    var k = j ^ j << 1 ^ j << 2 ^ j << 3 ^ j << 4,
        k = k >>> 8 ^ k & 255 ^ 99;l[e] = k;s[k] = e;var z = a[e],
        F = a[z],
        G = a[F],
        y = 257 * a[k] ^ 16843008 * k;t[e] = y << 24 | y >>> 8;r[e] = y << 16 | y >>> 16;w[e] = y << 8 | y >>> 24;v[e] = y;y = 16843009 * G ^ 65537 * F ^ 257 * z ^ 16843008 * e;b[k] = y << 24 | y >>> 8;x[k] = y << 16 | y >>> 16;q[k] = y << 8 | y >>> 24;n[k] = y;e ? (e = z ^ a[a[a[G ^ z]]], j ^= a[a[j]]) : e = j = 1;
  }var H = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
      d = d.AES = p.extend({ _doReset: function _doReset() {
      for (var a = this._key, c = a.words, d = a.sigBytes / 4, a = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], j = 0; j < a; j++) {
        if (j < d) e[j] = c[j];else {
          var k = e[j - 1];j % d ? 6 < d && 4 == j % d && (k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255]) : (k = k << 8 | k >>> 24, k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255], k ^= H[j / d | 0] << 24);e[j] = e[j - d] ^ k;
        }
      }c = this._invKeySchedule = [];for (d = 0; d < a; d++) {
        j = a - d, k = d % 4 ? e[j] : e[j - 4], c[d] = 4 > d || 4 >= j ? k : b[l[k >>> 24]] ^ x[l[k >>> 16 & 255]] ^ q[l[k >>> 8 & 255]] ^ n[l[k & 255]];
      }
    }, encryptBlock: function encryptBlock(a, b) {
      this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l);
    }, decryptBlock: function decryptBlock(a, c) {
      var d = a[c + 1];a[c + 1] = a[c + 3];a[c + 3] = d;this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s);d = a[c + 1];a[c + 1] = a[c + 3];a[c + 3] = d;
    }, _doCryptBlock: function _doCryptBlock(a, b, c, d, e, j, l, f) {
      for (var m = this._nRounds, g = a[b] ^ c[0], h = a[b + 1] ^ c[1], k = a[b + 2] ^ c[2], n = a[b + 3] ^ c[3], p = 4, r = 1; r < m; r++) {
        var q = d[g >>> 24] ^ e[h >>> 16 & 255] ^ j[k >>> 8 & 255] ^ l[n & 255] ^ c[p++],
            s = d[h >>> 24] ^ e[k >>> 16 & 255] ^ j[n >>> 8 & 255] ^ l[g & 255] ^ c[p++],
            t = d[k >>> 24] ^ e[n >>> 16 & 255] ^ j[g >>> 8 & 255] ^ l[h & 255] ^ c[p++],
            n = d[n >>> 24] ^ e[g >>> 16 & 255] ^ j[h >>> 8 & 255] ^ l[k & 255] ^ c[p++],
            g = q,
            h = s,
            k = t;
      }q = (f[g >>> 24] << 24 | f[h >>> 16 & 255] << 16 | f[k >>> 8 & 255] << 8 | f[n & 255]) ^ c[p++];s = (f[h >>> 24] << 24 | f[k >>> 16 & 255] << 16 | f[n >>> 8 & 255] << 8 | f[g & 255]) ^ c[p++];t = (f[k >>> 24] << 24 | f[n >>> 16 & 255] << 16 | f[g >>> 8 & 255] << 8 | f[h & 255]) ^ c[p++];n = (f[n >>> 24] << 24 | f[g >>> 16 & 255] << 16 | f[h >>> 8 & 255] << 8 | f[k & 255]) ^ c[p++];a[b] = q;a[b + 1] = s;a[b + 2] = t;a[b + 3] = n;
    }, keySize: 8 });u.AES = p._createHelper(d);
})();
exports.default = CryptoJS;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
/*
 * Tween.js
 * t: current time（当前时间）；
 * b: beginning value（初始值）；
 * c: change in value（变化量）；
 * d: duration（持续时间）。
 * you can visit 'http://easings.net/zh-cn' to get effect
*/
var Tween = {
    Linear: function Linear(t, b, c, d) {
        return c * t / d + b;
    },
    Quad: {
        easeIn: function easeIn(t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        easeOut: function easeOut(t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },
        easeInOut: function easeInOut(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t + b;
            return -c / 2 * (--t * (t - 2) - 1) + b;
        }
    },
    Cubic: {
        easeIn: function easeIn(t, b, c, d) {
            return c * (t /= d) * t * t + b;
        },
        easeOut: function easeOut(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        },
        easeInOut: function easeInOut(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t + 2) + b;
        }
    },
    Quart: {
        easeIn: function easeIn(t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        },
        easeOut: function easeOut(t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        },
        easeInOut: function easeInOut(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t + b;
            return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
        }
    },
    Quint: {
        easeIn: function easeIn(t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },
        easeOut: function easeOut(t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },
        easeInOut: function easeInOut(t, b, c, d) {
            if ((t /= d / 2) < 1) return c / 2 * t * t * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        }
    },
    Sine: {
        easeIn: function easeIn(t, b, c, d) {
            return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
        },
        easeOut: function easeOut(t, b, c, d) {
            return c * Math.sin(t / d * (Math.PI / 2)) + b;
        },
        easeInOut: function easeInOut(t, b, c, d) {
            return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
        }
    },
    Expo: {
        easeIn: function easeIn(t, b, c, d) {
            return t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
        },
        easeOut: function easeOut(t, b, c, d) {
            return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
        },
        easeInOut: function easeInOut(t, b, c, d) {
            if (t == 0) return b;
            if (t == d) return b + c;
            if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
            return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
        }
    },
    Circ: {
        easeIn: function easeIn(t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        },
        easeOut: function easeOut(t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        },
        easeInOut: function easeInOut(t, b, c, d) {
            if ((t /= d / 2) < 1) return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
            return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        }
    },
    Elastic: {
        easeIn: function easeIn(t, b, c, d, a, p) {
            var s;
            if (t == 0) return b;
            if ((t /= d) == 1) return b + c;
            if (typeof p == "undefined") p = d * .3;
            if (!a || a < Math.abs(c)) {
                s = p / 4;
                a = c;
            } else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        },
        easeOut: function easeOut(t, b, c, d, a, p) {
            var s;
            if (t == 0) return b;
            if ((t /= d) == 1) return b + c;
            if (typeof p == "undefined") p = d * .3;
            if (!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
        },
        easeInOut: function easeInOut(t, b, c, d, a, p) {
            var s;
            if (t == 0) return b;
            if ((t /= d / 2) == 2) return b + c;
            if (typeof p == "undefined") p = d * (.3 * 1.5);
            if (!a || a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else {
                s = p / (2 * Math.PI) * Math.asin(c / a);
            }
            if (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
        }
    },
    Back: {
        easeIn: function easeIn(t, b, c, d, s) {
            if (typeof s == "undefined") s = 1.70158;
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },
        easeOut: function easeOut(t, b, c, d, s) {
            if (typeof s == "undefined") s = 1.70158;
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },
        easeInOut: function easeInOut(t, b, c, d, s) {
            if (typeof s == "undefined") s = 1.70158;
            if ((t /= d / 2) < 1) return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
            return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
        }
    },
    Bounce: {
        easeIn: function easeIn(t, b, c, d) {
            return c - Tween.Bounce.easeOut(d - t, 0, c, d) + b;
        },
        easeOut: function easeOut(t, b, c, d) {
            if ((t /= d) < 1 / 2.75) {
                return c * (7.5625 * t * t) + b;
            } else if (t < 2 / 2.75) {
                return c * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + b;
            } else if (t < 2.5 / 2.75) {
                return c * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + b;
            } else {
                return c * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + b;
            }
        },
        easeInOut: function easeInOut(t, b, c, d) {
            if (t < d / 2) {
                return Tween.Bounce.easeIn(t * 2, 0, c, d) * .5 + b;
            } else {
                return Tween.Bounce.easeOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
            }
        }
    }
};

exports.default = Tween;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BattleGamePage = function () {
  function BattleGamePage(game) {
    _classCallCheck(this, BattleGamePage);

    this.game = game;
    this.model = this.game.gameModel;
    this.full2D = this.game.full2D;
    this.UI = this.game.UI;
    this.viewer = this.game.viewer;
    this.name = 'game';
  }

  _createClass(BattleGamePage, [{
    key: 'show',
    value: function show() {
      this.UI.showScore();

      this.UI.scoreText.obj.position.y = 21;
      this.UI.scoreText.obj.position.x = -13;
      this.UI.scoreText.changeStyle({ textAlign: 'left' });
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.UI.hideScore();
    }
  }]);

  return BattleGamePage;
}();

exports.default = BattleGamePage;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BattlePkPage = function () {
  function BattlePkPage(game) {
    _classCallCheck(this, BattlePkPage);

    this.game = game;
    this.model = this.game.gameModel;
    this.full2D = this.game.full2D;
    this.name = 'battlePage';
  }

  _createClass(BattlePkPage, [{
    key: 'show',
    value: function show(obj) {
      this.full2D.showPkPage(obj);
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.full2D.hide2D();
    }
  }]);

  return BattlePkPage;
}();

exports.default = BattlePkPage;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GroupPage = function () {
  function GroupPage(game) {
    _classCallCheck(this, GroupPage);

    this.game = game;
    this.model = this.game.gameModel;
    this.full2D = this.game.full2D;
    this.name = 'groupRankList';
  }

  _createClass(GroupPage, [{
    key: 'show',
    value: function show(list, myUserInfo) {
      this.full2D.showGroupRankList(list, myUserInfo);
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.full2D.hide2D();
    }
  }]);

  return GroupPage;
}();

exports.default = GroupPage;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _three = __webpack_require__(1);

var THREE = _interopRequireWildcard(_three);

var _config = __webpack_require__(2);

var _storage = __webpack_require__(5);

var _storage2 = _interopRequireDefault(_storage);

var _scrollHandler = __webpack_require__(11);

var _scrollHandler2 = _interopRequireDefault(_scrollHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Dpr = window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio; // 当前屏幕的Dpr， i7p 设置3 会挂
var W = window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth; // CSS像素
var H = window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth; // CSS像素
var HEIGHT = H * Dpr; // 设备像素
var WIDTH = W * Dpr; // 设备像素
var frustumSizeHeight = _config.FRUSTUMSIZE; // 动画的尺寸单位坐标高度
var frustumSizeWidth = WIDTH / HEIGHT * frustumSizeHeight; // 动画的尺寸单位坐标高度
var planList = ['bg'];

var Lookers = function () {
	function Lookers(options) {
		_classCallCheck(this, Lookers);

		this.texture = {};
		this.material = {};
		this.geometry = {};
		this.obj = {};
		this.canvas = {};
		this.context = {};
		this._touchInfo = { trackingID: -1, maxDy: 0, maxDx: 0 };
		this.cwidth = WIDTH;
		this.cheight = 50;
		this.options = Object.assign({}, {}, options);
		this._createPlane();
		// --- 显示X人围观和头像
		// this.showLookers({
		// 	avaImg: false,
		// 	icon: true,
		// 	wording: true,
		// 	num : 9,
		// 	avatar : ['','','']
		// })
		// 隐藏这个界面：
		// this.hideLookers()
		// --- 邀请围观
		// this.showLookersShare({});
	}

	// ----------------- show/hide 方法 -----------------


	_createClass(Lookers, [{
		key: 'showLookers',
		value: function showLookers(opt) {
			this.showState = true;
			opt = opt || {};
			this._drawLookers(opt);
		}
	}, {
		key: 'showLookersShare',
		value: function showLookersShare(opt) {
			this.showState = true;
			opt = opt || {};
		}
	}, {
		key: 'hideLookers',
		value: function hideLookers() {
			this.showState = false;
			for (var i = 0; i < planList.length; i++) {
				this.obj[planList[i]].visible = false;
				this.options.camera.remove(this.obj[planList[i]]);
			}
		}
		// ----------------- 背景绘制 -----------------

	}, {
		key: '_drawLookers',
		value: function _drawLookers(opt) {
			var _this = this;

			var ctx = this.context['bg'];
			ctx.fillStyle = 'pink';
			ctx.strokeStyle = 'red';
			ctx.lineWidth = 2 * Dpr;
			// ctx.fillRect(0, 0, this._cx( 414 ), this._cx( this.cheight ));
			ctx.clearRect(0, 0, this._cx(414), this._cx(this.cheight));
			// ctx.strokeRect(0, 0, this._cx( 414 ), this._cx( this.cheight ));
			var height = this.cheight;

			if (opt.avaImg) {
				var right_offset = WIDTH - opt.avatar.length * this._cx(32);
				var that = this;

				var _loop = function _loop() {
					var x = i * _this._cx(36) + right_offset;
					_this._drawImageCenter(opt.avatar[i], x, height / 2, that._cx(25), that._cx(25), 'bg', function () {
						that._drawImageCenter('res/ava_big1.png', x, height / 2, that._cx(29), that._cx(29), 'bg');
					});
				};

				for (var i = 0; i < opt.avatar.length; i++) {
					_loop();
				}
				// 绘制背景图

				ctx.fillStyle = 'rgba(0,0,0,0.56)';
				ctx.font = this._cf(14);
				ctx.textAlign = "right";
				ctx.textBaseline = "middle";
				ctx.fillText('有' + opt.num + '位好友正在围观', right_offset - this._cx(20), this._cx(16));
			}

			if (opt.icon) {
				this._drawImageCenter('res/observShare.png', this._cx(35), height / 2, this._cx(14), this._cx(16), 'bg');
			}
			if (opt.wording) {
				ctx.fillStyle = 'rgba(0,0,0,0.56)';
				ctx.font = this._cf(14);
				ctx.textAlign = "left";
				ctx.textBaseline = "middle";
				ctx.fillText('邀请围观', this._cx(55), this._cx(16));
			}

			this._updatePlane('bg');
		}
		// ----------------- 画布创建与更新 -----------------

	}, {
		key: '_createPlane',
		value: function _createPlane() {
			// 创建画布
			for (var i = 0; i < planList.length; i++) {
				this.canvas[planList[i]] = document.createElement('canvas');
				this.context[planList[i]] = this.canvas[planList[i]].getContext('2d');
				this.canvas[planList[i]].width = WIDTH;
				this.canvas[planList[i]].height = this.cheight * Dpr;
				this.texture[planList[i]] = new THREE.Texture(this.canvas[planList[i]]);
				this.material[planList[i]] = new THREE.MeshBasicMaterial({ map: this.texture[planList[i]], transparent: true });
				this.geometry[planList[i]] = new THREE.PlaneGeometry(frustumSizeWidth, this.cheight / H * frustumSizeHeight);
				this.obj[planList[i]] = new THREE.Mesh(this.geometry[planList[i]], this.material[planList[i]]);
				this.material[planList[i]].map.minFilter = THREE.LinearFilter;
				// console.log( HEIGHT, WIDTH)
				this.obj[planList[i]].position.y = -(0.5 - this.cheight / 2 / H) * frustumSizeHeight; // - frustumSizeHeight/15*7; // 上下
				this.obj[planList[i]].position.x = 0; // frustumSizeWidth/5; // 左右
				this.obj[planList[i]].position.z = 9 - i * 0.001;
			}
		}
	}, {
		key: '_updatePlane',
		value: function _updatePlane(type) {

			// 画布更新
			if (!this.showState) {
				return;
			}
			this.texture[type].needsUpdate = true;
			this.obj[type].visible = true;
			this.options.camera.add(this.obj[type]);
		}

		// ----------------- 工具函数 -----------------

	}, {
		key: '_drawImageCenter',
		value: function _drawImageCenter(src, x, y, width, height, type, cb) {
			// imgid 是渲染时候的imgid， 在每次改变画布的时候自增
			// 以xy为中心来显示一副图片

			if (src == '/0' || src == '/96' || src == '/64' || !src) {
				src = 'res/ava.png';
			}
			var img = new Image();
			var that = this;
			var ctx = this.context[type];
			img.onload = function () {
				ctx.drawImage(img, x - width / 2, y - height / 2, width, height);
				!!cb && cb();
				that._updatePlane(type); // 更新画布
			};
			img.onerror = function () {
				!!cb && cb();
			};
			img.src = src;
		}
	}, {
		key: '_cx',
		value: function _cx(x) {
			var realx = x * W / 414;
			return realx * Dpr;
		}
	}, {
		key: '_cf',
		value: function _cf(size) {
			// font size 
			var realf = size * Dpr * W / 414;
			return realf + 'px Helvetica';
		}
	}]);

	return Lookers;
}();

exports.default = Lookers;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GgPage = function () {
  function GgPage(game) {
    _classCallCheck(this, GgPage);

    this.game = game;
    this.model = this.game.gameModel;
    this.full2D = this.game.full2D;
    this.UI = this.game.UI;
    this.name = 'viewerGG';
  }

  _createClass(GgPage, [{
    key: 'show',
    value: function show(score) {
      var observeInfo = this.model.observeInfo;
      this.full2D.showLookersPage({
        type: 'gg',
        score: score,
        headimg: observeInfo.headimg,
        nickname: observeInfo.nickName
      });
      this.UI.hideScore();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.full2D.hide2D();
    }
  }]);

  return GgPage;
}();

exports.default = GgPage;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var outPage = function () {
  function outPage(game) {
    _classCallCheck(this, outPage);

    this.game = game;
    this.model = this.game.gameModel;
    this.full2D = this.game.full2D;
    this.UI = this.game.UI;
    this.name = 'viewerOut';
  }

  _createClass(outPage, [{
    key: 'show',
    value: function show() {
      var observeInfo = this.model.observeInfo;
      this.full2D.showLookersPage({
        type: 'out',
        headimg: observeInfo.headimg,
        nickname: observeInfo.nickName
      });
      this.UI.hideScore();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.full2D.hide2D();
    }
  }]);

  return outPage;
}();

exports.default = outPage;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WaitingPage = function () {
  function WaitingPage(game) {
    _classCallCheck(this, WaitingPage);

    this.game = game;
    this.model = this.game.gameModel;
    this.full2D = this.game.full2D;
    this.UI = this.game.UI;
    this.name = 'viewerWaiting';
  }

  _createClass(WaitingPage, [{
    key: 'show',
    value: function show() {
      var observeInfo = this.model.observeInfo;
      this.full2D.showLookersPage({
        type: 'in',
        headimg: observeInfo.headimg,
        nickname: observeInfo.nickName
      });
      this.UI.scoreText.obj.position.x = 0;
      this.UI.scoreText.obj.position.y = 11;
      this.UI.scoreText.changeStyle({ textAlign: 'center' });
      this.UI.showScore();
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.full2D.hide2D();
      this.UI.hideScore();
      this.UI.scoreText.obj.position.y = 21;
      this.UI.scoreText.obj.position.x = -13;
      this.UI.scoreText.changeStyle({ textAlign: 'left' });
    }
  }]);

  return WaitingPage;
}();

exports.default = WaitingPage;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GamePage = function () {
  function GamePage(game) {
    _classCallCheck(this, GamePage);

    this.game = game;
    this.model = this.game.gameModel;
    this.full2D = this.game.full2D;
    this.UI = this.game.UI;
    this.viewer = this.game.viewer;
    this.name = 'game';
  }

  _createClass(GamePage, [{
    key: 'show',
    value: function show() {
      // this.UI.observe.visible = true

      this.UI.showScore();

      this.UI.scoreText.obj.position.y = 21;
      this.UI.scoreText.obj.position.x = -13;
      this.UI.scoreText.changeStyle({ textAlign: 'left' });
      this.viewer.open();
    }
  }, {
    key: 'hide',
    value: function hide() {
      // this.UI.observe.visible = false
      this.viewer.close();
      this.UI.hideScore();
    }
  }]);

  return GamePage;
}();

exports.default = GamePage;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _storage = __webpack_require__(5);

var _storage2 = _interopRequireDefault(_storage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Dpr = window.devicePixelRatio > 2 ? 2 : window.devicePixelRatio; // 当前屏幕的Dpr， i7p 设置3 会挂
var W = window.innerHeight < window.innerWidth ? window.innerHeight : window.innerWidth; // CSS像素
var H = window.innerHeight > window.innerWidth ? window.innerHeight : window.innerWidth; // CSS像素
var HEIGHT = H * Dpr; // 设备像素
var WIDTH = W * Dpr; // 设备像素

var family = wx.loadFont('res/num.ttf');

var Rank = function () {
	function Rank(options) {
		_classCallCheck(this, Rank);

		this.texture = {};
		this.material = {};
	}

	_createClass(Rank, [{
		key: 'getShareCard',
		value: function getShareCard(opt, cb) {

			opt = opt || {};
			var cwidth = 693; // 553, 693
			var cheight = 558; // 543, 558 
			if (!this.canvas) {
				this.canvas = document.createElement('canvas');
				this.context = this.canvas.getContext('2d');
				this.canvas.width = cwidth;
				this.canvas.height = cheight;
			}

			// console.log('sharetype: ', opt)
			var ctx = this.context;
			if (opt.type == 'shareBattle') {
				ctx.fillStyle = 'white'; // 白色
				ctx.fillRect(0, 0, cwidth, cheight);

				var that = this;
				this._drawImageCanvas1('res/changlle_share.png', 0, 0, cwidth, cheight, 'share', function () {
					ctx.fillStyle = 'rgba(0,0,0,0.8)'; // 灰色文字
					ctx.font = '180px ' + family;
					ctx.textBaseline = "middle";
					ctx.textAlign = 'center';
					ctx.fillText(opt.score || 0, 0.5 * cwidth + 10, 0.6 * cheight);
					!!cb && cb(that.canvas);
				});
			}
			if (opt.type == 'history') {
				// 历史最高分的分享 history
				// new
				ctx.fillStyle = 'white'; // 白色
				ctx.fillRect(0, 0, cwidth, cheight);
				var that = this;
				this._drawImageCanvas1('res/high_score.png', 0, 0, cwidth, cheight, 'share', function () {
					ctx.fillStyle = '#00c777'; // 绿色文字
					ctx.font = '180px ' + family;
					ctx.textBaseline = "middle";
					ctx.textAlign = 'center';
					ctx.fillText(opt.score || 0, 0.5 * cwidth + 10, 0.68 * cheight);
					!!cb && cb(that.canvas);
				});
			}
			if (opt.type == 'week') {
				// 本周最高分的分享 week
				// new
				ctx.fillStyle = 'white'; // 白色
				ctx.fillRect(0, 0, cwidth, cheight);
				var that = this;
				this._drawImageCanvas1('res/high_score_week.png', 0, 0, cwidth, cheight, 'share', function () {
					ctx.fillStyle = '#00c777'; // 绿色文字
					ctx.font = '180px ' + family;
					ctx.textBaseline = "middle";
					ctx.textAlign = 'center';
					ctx.fillText(opt.score || 0, 0.5 * cwidth + 10, 0.68 * cheight);
					!!cb && cb(that.canvas);
				});
			}
			if (opt.type == 'rank') {
				// 排行榜第一的分享 highestRank
				ctx.fillStyle = 'white'; // 白色
				ctx.fillRect(0, 0, cwidth, cheight);
				var that = this;
				var userInfo = _storage2.default.getMyUserInfo();
				// console.log(userInfo.headimg)
				that._drawImageCanvas1(userInfo.headimg, 0.5 * cwidth + 10 - 51, 330 - 51, 102, 102, 'share', function () {
					that._drawImageCanvas1('res/high_rank.png', 0, 0, cwidth, cheight, 'share', function () {
						ctx.fillStyle = '#00c777'; // 绿色文字
						ctx.font = '60px ' + family;
						ctx.textBaseline = "middle";
						ctx.textAlign = 'center';
						ctx.fillText(opt.score || 5678, 0.5 * cwidth + 10, 0.8 * cheight);

						!!cb && cb(that.canvas);
					});
				});
			}
		}
	}, {
		key: '_smallReat',
		value: function _smallReat() {
			var ctx = this.context;
			var colors = ['red', 'blue', 'green', 'yellow', 'skyblue'];
			var cwidth = 553;
			var cheight = 691;

			for (var i = 0; i < colors.length; i++) {
				ctx.fillStyle = colors[i];
				for (var j = 0; j < 5; j++) {
					ctx.fillRect(Math.random() * cwidth, Math.random() * cheight, 15, 15);
				}
			}
		}
	}, {
		key: '_drawImageCanvas',
		value: function _drawImageCanvas(src, x, y, width, height, type, cb) {
			// 在画布里面显示一副图片
			var img = new Image();
			var that = this;
			img.onload = function () {
				that.context.drawImage(img, x - width / 2, y - height / 2, width, height);
				!!cb && cb(that.canvas);
			};
			img.onerror = function () {
				!!cb && cb(that.canvas);
			};
			img.src = src;
		}
	}, {
		key: '_drawImageCanvas1',
		value: function _drawImageCanvas1(src, x, y, width, height, type, cb) {
			// 在画布里面显示一副图片
			if (src == '/0' || src == '/96' || src == '/64' || !src) {
				src = 'res/ava.png';
			}
			var img = new Image();
			var that = this;
			img.onload = function () {
				that.context.drawImage(img, x, y, width, height);
				!!cb && cb(that.canvas);
			};
			img.onerror = function () {
				!!cb && cb(that.canvas);
			};
			img.src = src;
		}
	}]);

	return Rank;
}();

exports.default = Rank;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SingleFriendRankPage = function () {
  function SingleFriendRankPage(game) {
    _classCallCheck(this, SingleFriendRankPage);

    this.game = game;
    this.model = this.game.gameModel;
    this.full2D = this.game.full2D;
    this.name = 'friendRankList';
  }

  _createClass(SingleFriendRankPage, [{
    key: 'show',
    value: function show() {
      this.full2D.showFriendRankList({
        week_best_score: this.model.weekBestScore
      });
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.full2D.hide2D();
    }
  }]);

  return SingleFriendRankPage;
}();

exports.default = SingleFriendRankPage;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SingleGameOverPage = function () {
  function SingleGameOverPage(game) {
    _classCallCheck(this, SingleGameOverPage);

    this.game = game;
    this.model = this.game.gameModel;
    this.full2D = this.game.full2D;
    this.name = 'singleSettlementPgae';
  }

  _createClass(SingleGameOverPage, [{
    key: 'show',
    value: function show() {
      var _this = this;

      var score = this.model.currentScore;
      var highest_score = this.model.getHighestScore();
      var start_time = this.model.startTime;
      var week_best_score = this.model.weekBestScore;
      var game_cnt = this.game.historyTimes.getTimes();
      if (!this.full2D) {
        this.game.handleWxOnError({
          message: 'can not find full 2D gameOverPage',
          stack: ''
        });
      }

      setTimeout(function () {
        if (_this.full2D) {
          _this.full2D.showGameOverPage({
            score: score,
            highest_score: highest_score,
            start_time: start_time,
            week_best_score: week_best_score,
            game_cnt: game_cnt
          });
        } else {
          // wx.exitMiniProgram()
        }
      }, 0);
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.full2D.hide2D();
    }
  }]);

  return SingleGameOverPage;
}();

exports.default = SingleGameOverPage;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GamePage = function () {
  function GamePage(game) {
    _classCallCheck(this, GamePage);

    this.game = game;
    this.model = this.game.gameModel;
    this.full2D = this.game.full2D;
    this.UI = this.game.UI;
    this.viewer = this.game.viewer;
    this.name = 'game';
  }

  _createClass(GamePage, [{
    key: 'show',
    value: function show() {
      var is_from_wn = this.model.is_from_wn;
      var firstBlood = this.model.firstBlood;

      if (!is_from_wn && !this.game.guider) {
        // this.UI.observe.visible = true
        if (firstBlood) {
          this.viewer.lookers.showLookers({
            avaImg: false,
            icon: true,
            wording: true
          });
        } else {
          this.viewer.open();
        }
      }

      this.UI.showScore();

      this.UI.scoreText.obj.position.y = 21;
      this.UI.scoreText.obj.position.x = -13;
      this.UI.scoreText.changeStyle({ textAlign: 'left' });
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.viewer.close();
      // this.UI.observe.visible = false
      this.UI.hideScore();
    }
  }, {
    key: 'hideLookersShare',
    value: function hideLookersShare() {
      var firstBlood = this.model.firstBlood;
      if (firstBlood) {
        this.model.setFirstBlood(false);
        this.viewer.open();
      }
    }
  }]);

  return GamePage;
}();

exports.default = GamePage;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SingleStartPage = function () {
  function SingleStartPage(game) {
    _classCallCheck(this, SingleStartPage);

    this.game = game;
    this.model = this.game.gameModel;
    this.full2D = this.game.full2D;
    this.name = 'startPage';
  }

  _createClass(SingleStartPage, [{
    key: 'show',
    value: function show() {
      var _this = this;

      if (!this.full2D) {
        this.game.handleWxOnError({
          message: 'can not find full 2D',
          stack: ''
        });
      }
      setTimeout(function () {
        if (_this.full2D) {
          _this.full2D.showStartPage();
        } else {
          // wx.exitMiniProgram()
        }
      }, 0);
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.full2D.hide2D();
    }
  }]);

  return SingleStartPage;
}();

exports.default = SingleStartPage;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Report = function () {
	function Report(options) {
		_classCallCheck(this, Report);
	}

	_createClass(Report, null, [{
		key: 'frameReport',
		value: function frameReport(type, frame) {
			var key = 0; // 默认值
			switch (type) {
				case 'iPhone5':
					key = 1;break;
				case 'iPhone5s':
					key = 2;break;
				case 'iPhone6':
					key = 3;break;
				case 'iPhone6s':
					key = 4;break;
				case 'iPhone6Plus':
					key = 5;break;
				case 'iPhone6sPlus':
					key = 6;break;
				case 'iPhone7':
					key = 7;break;
				case 'iPhone7s':
					key = 8;break;
				case 'iPhone7Plus':
					key = 9;break;
				case 'iPhone7sPlus':
					key = 10;break;
				case 'iPhone8':
					key = 11;break;
				case 'iPhone8Plus':
					key = 12;break;
				case 'iPhoneX':
					key = 13;break;
			}

			new Image().src = "https://mp.weixin.qq.com/mp/jsmonitor?idkey=58121_" + key * 3 + "_" + frame + ";58121_" + (key * 3 + 1) + "_1&t=" + Math.random();
		}
	}]);

	return Report;
}();

exports.default = Report;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Friction = function () {
  /***
   * Friction physics simulation. Friction is actually just a simple
   * power curve; the only trick is taking the natural log of the
   * initial drag so that we can express the answer in terms of time.
   */
  function Friction(drag) {
    _classCallCheck(this, Friction);

    this._drag = drag;
    this._dragLog = Math.log(drag);
    this._x = 0;
    this._v = 0;
    this._startTime = 0;
  }

  _createClass(Friction, [{
    key: "set",
    value: function set(x, v) {
      this._x = x;
      this._v = v;
      this._startTime = new Date().getTime();
    }
  }, {
    key: "x",
    value: function x(dt) {
      if (dt === undefined) dt = (new Date().getTime() - this._startTime) / 1000;
      var powDragDt;
      if (dt === this._dt && this._powDragDt) {
        powDragDt = this._powDragDt;
      } else {
        powDragDt = this._powDragDt = Math.pow(this._drag, dt);
      }
      this._dt = dt;
      return this._x + this._v * powDragDt / this._dragLog - this._v / this._dragLog;
    }
  }, {
    key: "dx",
    value: function dx(dt) {
      if (dt === undefined) dt = (new Date().getTime() - this._startTime) / 1000;
      var powDragDt;
      if (dt === this._dt && this._powDragDt) {
        powDragDt = this._powDragDt;
      } else {
        powDragDt = this._powDragDt = Math.pow(this._drag, dt);
      }
      this._dt = dt;
      return this._v * powDragDt;
    }
  }, {
    key: "done",
    value: function done() {
      return Math.abs(this.dx()) < 3;
    }
  }]);

  return Friction;
}();

exports.default = Friction;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _friction = __webpack_require__(56);

var _friction2 = _interopRequireDefault(_friction);

var _spring = __webpack_require__(58);

var _spring2 = _interopRequireDefault(_spring);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Scroll = function () {
  /***
   * Scroll combines Friction and Spring to provide the
   * classic "flick-with-bounce" behavior.
   */
  function Scroll(extent) {
    _classCallCheck(this, Scroll);

    this._extent = extent;
    this._friction = new _friction2.default(0.01);
    this._spring = new _spring2.default(1, 90, 20);
    this._startTime = 0;
    this._springing = false;
    this._springOffset = 0;
  }

  _createClass(Scroll, [{
    key: 'set',
    value: function set(x, v) {
      this._friction.set(x, v);

      // If we're over the extent or zero then start springing. Notice that we also consult
      // velocity because we don't want flicks that start in the overscroll to get consumed
      // by the spring.
      if (x > 0 && v >= 0) {
        this._springOffset = 0;
        this._springing = true;
        this._spring.snap(x);
        this._spring.setEnd(0);
      } else if (x < -this._extent && v <= 0) {
        this._springOffset = 0;
        this._springing = true;
        this._spring.snap(x);
        this._spring.setEnd(-this._extent);
      } else {
        this._springing = false;
      }
      this._startTime = new Date().getTime();
    }
  }, {
    key: 'x',
    value: function x(t) {
      if (!this._startTime) return 0;
      if (!t) t = (new Date().getTime() - this._startTime) / 1000.0;
      // We've entered the spring, use the value from there.
      if (this._springing) return this._spring.x() + this._springOffset;
      // We're still in friction.
      var x = this._friction.x(t);
      var dx = this.dx(t);
      // If we've gone over the edge the roll the momentum into the spring.
      // console.log('x: ', x, 'dx: ', dx, ' _extent:', this._extent, ' _springOffset: ', this._springOffset)
      if ( /*(x > 0 && dx >= 0) || */x < -this._extent && dx <= 0) {
        this._springing = true;
        this._spring.setEnd(0, dx);
        if (x < -this._extent) this._springOffset = -this._extent;else this._springOffset = 0;
        x = this._spring.x() + this._springOffset;
      }
      return x;
    }
  }, {
    key: 'dx',
    value: function dx(t) {
      var dx = 0;

      if (this._lastTime === t) {
        dx = this._lastDx;
      } else if (this._springing) {
        dx = this._spring.dx(t);
      } else {
        dx = this._friction.dx(t);
      }

      this._lastTime = t;
      this._lastDx = dx;
      return dx;
    }
  }, {
    key: 'done',
    value: function done() {
      if (this._springing) return this._spring.done();else return this._friction.done();
    }
  }]);

  return Scroll;
}();

exports.default = Scroll;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var epsilon = 0.4;

var Spring = function () {

  /***
   * Simple Spring implementation -- this implements a damped spring using a symbolic integration
   * of Hooke's law: F = -kx - cv. This solution is significantly more performant and less code than
   * a numerical approach such as Facebook Rebound which uses RK4.
   *
   * This physics textbook explains the model:
   *  http://www.stewartcalculus.com/data/CALCULUS%20Concepts%20and%20Contexts/upfiles/3c3-AppsOf2ndOrders_Stu.pdf
   *
   * A critically damped spring has: damping*damping - 4 * mass * springConstant == 0. If it's greater than zero
   * then the spring is overdamped, if it's less than zero then it's underdamped.
   */
  function Spring(mass, springConstant, damping) {
    _classCallCheck(this, Spring);

    this._m = mass;
    this._k = springConstant;
    this._c = damping;
    this._solution = null;
    this._endPosition = 0;
    this._startTime = 0;
  }

  _createClass(Spring, [{
    key: "_solve",
    value: function _solve(initial, velocity) {
      var c = this._c;
      var m = this._m;
      var k = this._k;
      // Solve the quadratic equation; root = (-c +/- sqrt(c^2 - 4mk)) / 2m.
      var cmk = c * c - 4 * m * k;
      if (cmk == 0) {
        // The spring is critically damped.
        // x = (c1 + c2*t) * e ^(-c/2m)*t
        var r = -c / (2 * m);
        var c1 = initial;
        var c2 = velocity / (r * initial);
        return {
          x: function x(t) {
            return (c1 + c2 * t) * Math.pow(Math.E, r * t);
          },
          dx: function dx(t) {
            var pow = Math.pow(Math.E, r * t);return r * (c1 + c2 * t) * pow + c2 * pow;
          }
        };
      } else if (cmk > 0) {
        // The spring is overdamped; no bounces.
        // x = c1*e^(r1*t) + c2*e^(r2t)
        // Need to find r1 and r2, the roots, then solve c1 and c2.
        var r1 = (-c - Math.sqrt(cmk)) / (2 * m);
        var r2 = (-c + Math.sqrt(cmk)) / (2 * m);
        var c2 = (velocity - r1 * initial) / (r2 - r1);
        var c1 = initial - c2;

        return {
          x: function x(t) {
            var powER1T, powER2T;
            if (t === this._t) {
              powER1T = this._powER1T;
              powER2T = this._powER2T;
            }

            this._t = t;

            if (!powER1T) {
              powER1T = this._powER1T = Math.pow(Math.E, r1 * t);
            }
            if (!powER2T) {
              powER2T = this._powER2T = Math.pow(Math.E, r2 * t);
            }

            return c1 * powER1T + c2 * powER2T;
          },
          dx: function dx(t) {
            var powER1T, powER2T;
            if (t === this._t) {
              powER1T = this._powER1T;
              powER2T = this._powER2T;
            }

            this._t = t;

            if (!powER1T) {
              powER1T = this._powER1T = Math.pow(Math.E, r1 * t);
            }
            if (!powER2T) {
              powER2T = this._powER2T = Math.pow(Math.E, r2 * t);
            }

            return c1 * r1 * powER1T + c2 * r2 * powER2T;
          }
        };
      } else {
        // The spring is underdamped, it has imaginary roots.
        // r = -(c / 2*m) +- w*i
        // w = sqrt(4mk - c^2) / 2m
        // x = (e^-(c/2m)t) * (c1 * cos(wt) + c2 * sin(wt))
        var w = Math.sqrt(4 * m * k - c * c) / (2 * m);
        var r = -(c / 2 * m);
        var c1 = initial;
        var c2 = (velocity - r * initial) / w;

        return {
          x: function x(t) {
            return Math.pow(Math.E, r * t) * (c1 * Math.cos(w * t) + c2 * Math.sin(w * t));
          },
          dx: function dx(t) {
            var power = Math.pow(Math.E, r * t);
            var cos = Math.cos(w * t);
            var sin = Math.sin(w * t);
            return power * (c2 * w * cos - c1 * w * sin) + r * power * (c2 * sin + c1 * cos);
          }
        };
      }
    }
  }, {
    key: "x",
    value: function x(dt) {
      if (dt == undefined) dt = (new Date().getTime() - this._startTime) / 1000.0;
      return this._solution ? this._endPosition + this._solution.x(dt) : 0;
    }
  }, {
    key: "dx",
    value: function dx(dt) {
      if (dt == undefined) dt = (new Date().getTime() - this._startTime) / 1000.0;
      return this._solution ? this._solution.dx(dt) : 0;
    }
  }, {
    key: "setEnd",
    value: function setEnd(x, velocity, t) {
      if (!t) t = new Date().getTime();
      if (x == this._endPosition && this.almostZero(velocity, epsilon)) return;
      velocity = velocity || 0;
      var position = this._endPosition;
      if (this._solution) {
        // Don't whack incoming velocity.
        if (this.almostZero(velocity, epsilon)) velocity = this._solution.dx((t - this._startTime) / 1000.0);
        position = this._solution.x((t - this._startTime) / 1000.0);
        if (this.almostZero(velocity, epsilon)) velocity = 0;
        if (this.almostZero(position, epsilon)) position = 0;
        position += this._endPosition;
      }
      if (this._solution && this.almostZero(position - x, epsilon) && this.almostZero(velocity, epsilon)) {
        return;
      }
      this._endPosition = x;
      this._solution = this._solve(position - this._endPosition, velocity);
      this._startTime = t;
    }
  }, {
    key: "snap",
    value: function snap(x) {
      this._startTime = new Date().getTime();
      this._endPosition = x;
      this._solution = {
        x: function x() {
          return 0;
        },
        dx: function dx() {
          return 0;
        }
      };
    }
  }, {
    key: "done",
    value: function done(t) {
      if (!t) t = new Date().getTime();
      return this.almostEqual(this.x(), this._endPosition, epsilon) && this.almostZero(this.dx(), epsilon);
    }
  }, {
    key: "almostEqual",
    value: function almostEqual(a, b, epsilon) {
      return a > b - epsilon && a < b + epsilon;
    }
  }, {
    key: "almostZero",
    value: function almostZero(a, epsilon) {
      return this.almostEqual(a, 0, epsilon);
    }
  }]);

  return Spring;
}();

exports.default = Spring;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encrypt = encrypt;

var _aes = __webpack_require__(40);

var _aes2 = _interopRequireDefault(_aes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function encrypt(data, originKey) {
  var originKey = originKey.slice(0, 16);
  var key = _aes2.default.enc.Utf8.parse(originKey);
  var iv = _aes2.default.enc.Utf8.parse(originKey);

  var msg = data;
  msg = JSON.stringify(msg);
  // console.log('msgmsgmsgmsgmsg', msg)
  // console.log('keykeykeykey',originKey)
  var passWord = _aes2.default.AES.encrypt(msg, key, { iv: iv, mode: _aes2.default.mode.CBC, padding: _aes2.default.pad.Pkcs7 });
  passWord = passWord.toString();

  // console.log('passWordpassWordpassWord', passWord)
  return passWord;
}

// export function testEncription(msg, fullKey) {
//   var fullKey = fullKey.slice(0, 16)
//   var key = CryptoJS.enc.Utf8.parse(fullKey)
//   var iv = CryptoJS.enc.Utf8.parse(fullKey)

//   var passWord = CryptoJS.AES.encrypt(msg, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 })
//   var base64 = passWord.toString()

//   console.log('passWord', passWord)
//   console.log('sessionId', sessionId)
//   console.log('key', key)
//   console.log('base64', base64)

//   var bytes = CryptoJS.AES.decrypt(base64, key, {
//     iv: iv
//   });
//   console.log('bytes', bytes)
//   var plaintext = CryptoJS.enc.Utf8.stringify(bytes);
//   console.log('plaintext', plaintext)
// }

/***/ })
/******/ ]); 
 			}); 	require("game.js");
 	